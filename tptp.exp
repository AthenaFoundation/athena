def concat(lines) = 
  match lines with 
    [] =>  ""
  | l::more => l ++ concat(more)


def sym_table = cell({})

declare var: 1, symbol:1, list: *, term_app: 2, atom: 1, binaryFormula: 3, negatedFormula: 1, formula_name:1, formula_role: 1, formula_ast:1, forall: 2, exists: 2, tptp_formula: *

def [lp, lb, comma, rp, rb, blank, newline, tab, equality_sign, colon, period, comment, negation_sign] = ['(', '[', ',', ')', ']', ' ', '\n', '\t', '=', ':', '.', '%', '~']

def tptpTokenizer(s) = tokenize(s,[blank,tab,newline],[lp,lb, comma,rp, rb, period, '!', '?', '&', '|', '=>', '<=>', colon, equality_sign, negation_sign])

updateGlobalParsingOptions({case_sensitive_parsing=true,tokenizer=tptpTokenizer,flex_parsing=false,include_derivations=false})

def startsWithUpperLetter(s) = isUpperCaseLetter(first(s))
def startsWithLowerLetter(s) = isLowerCaseLetter(first(s))

def leaf = consumeAndPushAnyWord * semant(fun (s::rest) => if startsWithUpperLetter(s) then (var(s)::rest) else if startsWithLowerLetter(s) then (symbol(s)::rest) else fail())

def [term,terms] = 
   let T = leaf * (id + lp * Ts * rp * semant(fun arg_list::sym::rest => term_app(sym,arg_list)::rest))
   and Ts = T * (semant(fun t::more => list(t)::more) + ", " * Ts * semant(fun args::arg::more => list(arg::children(args))::more))
   in [T,Ts]

def makeEquality(t1,t2) = term_app(symbol("="),list(t1,t2))

def atomicFormula = term * (id + equality_sign * term * semant(fun t2::t1::S => makeEquality(t1,t2)::S))

memoize(atomicFormula)

def conditional = '=' * '>' * push('=>')
def biconditional = '<' * '=' * '>' * push('<=>')

def connective = consumeAndPush('&') + consumeAndPush('|') + conditional + biconditional

def makeBinaryFormula(connective,p1,p2) = binaryFormula(connective,p1,p2)

def variable = consumeAndPushAnyWord * semant(fun (s::rest) => if startsWithUpperLetter(s) then (var(s)::rest) else fail())

def variables = variable * app(list) * (id + comma * variables * semant(fun (var_list::v::rest) => list(first(children(v))::children(var_list))::rest))

# This simple version works: 
def formula = atomicFormula 
            + '~' * formula * semant(fun p::more => negatedFormula(p)::more) 
            + lp * formula * connective * formula * rp * semant(fun p2::c::p1::more => makeBinaryFormula(c,p1,p2)::more)
            + '!' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)
            + '?' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)


def formula = atomicFormula 
            + '~' * formula * semant(fun p::more => negatedFormula(p)::more) 
            + lp * '~' * formula * rp * semant(fun p::more => negatedFormula(p)::more) 
            + lp * formula * connective * formula * rp * semant(fun p2::c::p1::more => makeBinaryFormula(c,p1,p2)::more)
            + '!' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)
            + lp * '!' * lb * variables * rb * colon * formula * rp * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)
            + '?' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)
            + lp * '?' * lb * variables * rb * colon * formula * rp * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)

def formula = atomicFormula 
            + '~' * formula * semant(fun p::more => negatedFormula(p)::more) 
            + lp * formula * connective * formula * rp * semant(fun p2::c::p1::more => makeBinaryFormula(c,p1,p2)::more)
            + '!' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)
            + '?' * lb * variables * rb * colon * formula * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)
            + lp * formula * rp 


# WORKING:
def form = 
   let E = T * (failAt('&') + consumeAndPush('&') * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp
   in E

def form = 
   let E1 = E * (failAt('!') + ('!' * lb * variables * rb * colon * E1 * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)))
   and E = T * (failAt('&') + consumeAndPush('&') * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E1 * rp
   in E1

# WORKS!!!
def form = 
   let E = T * (failAt('&') + consumeAndPush('&') * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = ('!' * lb * variables * rb * colon * T * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)) +  (F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp
   in E


# BEST SO FAR: 
def form = 
   let E = ('!' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)) + 
           ('?' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)) + 
           T * (failAt('&') + consumeAndPush('&') * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = (F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp
   in E


def form = 
   let E = ('!' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)) + 
           ('?' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)) + 
           T1 * (conditional * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T1 = (T * (failAt('&') + consumeAndPush('&') * T1 * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and T = (F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp
   in E

# PERFECT: 
def form = 
   let E = ('!' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)) + 
           ('?' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)) + 
           (T1 * (failOnFirst(conditional) + conditional * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))) + 
           (T1 * (failOnFirst(biconditional) + biconditional * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S)))  
   and T1 = T * (failAt('&') + consumeAndPush('&') * T1 * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = (F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp
   in E

# MOST PERFCT 
def formula = 
   let E = ('!' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => forall(var_list,body)::rest)) + 
           ('?' * lb * variables * rb * colon * E * semant(fun (body::var_list::rest) => exists(var_list,body)::rest)) + 
           (T1 * ((failOnFirst(conditional) + conditional * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S)) +         
                  (failOnFirst(biconditional) + biconditional * E * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))))
   and T1 = T * (failAt('&') + consumeAndPush('&') * T1 * (fun e::c::t::S => makeBinaryFormula(c,t,e)::S))
   and T = (F * (failAt('|') + consumeAndPush('|') * T * (fun t::c::f::S => makeBinaryFormula(c,f,t)::S)))
   and F = G + '~' * F * (fun f::S => negatedFormula(f)::S) 
   and G = atomicFormula + lp * E * rp 
   in let _ = memoize([E,T1,T,F,G]) in E 




def name = consumeAndPushAnyWord * semant(fun w::S => formula_name(w)::S)

# Valid TPTP roles: axiom, hypothesis, definition, assumption, lemma, theorem, corollary, conjecture, negated_conjecture, plain, type, interpretation, logic, and unknown

def role = consumeAndPushAnyWord * semant(fun w::S => formula_role(w)::S)

def fof_line = 'fof' * lp * name * comma * role * comma * formula * rp * period * semant(fun p::r::n::S => tptp_formula(n,r,formula_ast(p))::S)

def fof_lines = fof_line * semant(fun f::more => list(f)::more) * (failAt('fof') + fof_lines * semant(fun l2::l1::more => list(children(l1)++children(l2))::more))

def fof_file_parser = consumeAnyWords * fof_lines * consumeAnyWords

def tptp_dir_prefix = '/mnt/c/athenaGit/athena/ft/data/TPTP/TPTP-v9.0.0/'

def isJunk(line) = let tl = trim(line) in (whiteSpace(tl) || (len(tl) > 0 && first(tl) == comment))

def is_include_file_line(l) = if isPrefix("include(",l) then tptp_dir_prefix ++ substr(l,9,len(l)-12) else ""

def readTPTPFileAsString(file_name) = 
    let lines = filterOut(readFile(file_name), isJunk); 
        lines' = map(fun l => match is_include_file_line(trim(l)) with "" => l | included_file_name => readTPTPFileAsString(included_file_name),lines)
    in
       concatAll(lines')
       
   
def file = "/mnt/c/athenaGit/athena/ft/data/TPTP/TPTP-v9.0.0/Axioms/AGT001+1.ax"
def s = readTPTPFileAsString(file)
#fof_lines(s)
#fof_lines(readTPTPFileAsString("foo.p"))
#formula('(foo(bar) & foo(X))')

def formulaMeaning(formula_string) = let res = formula(formula_string) in first(res.interpretations[0].semantics)

def termMeaning(term_string) = let res = term(term_string) in first(res.interpretations[0].semantics)

def extractSymbolsFromTermAux(t,D) = 
      match t with 
         symbol([x]) => extendDict(D,[[x,[0,'D']]])
       | term_app(symbol(f)::list(args)) => let D' = fold(extractSymbolsFromTermAux,D,args) in extendDict(D', [[f, [len(args),'D']]])
       | _ => D

def termToAthena(t) = 
      match t with 
         symbol([x]) => x
       | var([x]) => '?' ++ x
       | term_app(symbol(f)::list(args)) => lp ++ f ++ blank ++ concatAllWithSeparator(map(termToAthena,args),blank) ++ rp

def athenaConnective(c) = match c with '&' => 'and' | '|' => 'or' | '=>' => 'if' | '<=>' => 'iff'
  

def formulaToAthena(p) = 
  match p with
    term_app(_) => termToAthena(p)
  | negatedFormula(p) => lp ++ 'not ' ++ formulaToAthena(p) ++ rp 
  | binaryFormula(c::args) => lp ++ athenaConnective(c) ++ blank ++ concatAllWithSeparator(map(formulaToAthena,args)," ") ++ rp 
  | forall(list(vars),p) => lp ++ 'forall ' ++  concatAllWithSeparator(map(termToAthena,vars),blank) ++ blank ++ formulaToAthena(p) ++ rp
  | exists(list(vars),p) => lp ++ 'exists ' ++  concatAllWithSeparator(map(termToAthena,vars),blank) ++ blank ++ formulaToAthena(p) ++ rp

def extractSymbolsFromFormulaAux(p,D) = 
      match p  with 
        term_app(children as symbol(fsym)::list(args)) => let D' = fold(extractSymbolsFromTermAux,D,args) in extendDict(D',[[fsym, [len(args),'Boolean']]])
      | negatedFormula(q) => extractSymbolsFromFormulaAux(q,D)
      | binaryFormula(_::args) => fold(extractSymbolsFromFormulaAux,D,args)
      | forall(list(_),q) => extractSymbolsFromFormulaAux(q,D)
      | exists(list(_),q) => extractSymbolsFromFormulaAux(q,D)


def extractSymbolsFromFormula(p) = extractSymbolsFromFormulaAux(p,{})

def test(str) = 
{'signature': extractSymbolsFromFormula(formulaMeaning(str)),
 'athena_translation': formulaToAthena(formulaMeaning(str))}

def analyze_formula_line(formula_meaning,D) = 
    match formula_meaning with
       tptp_formula(formula_name(n),formula_role(r),formula_ast(p)) => 
         {'signature': extractSymbolsFromFormulaAux(p,D), 
	 'name': n,
	 'role': r,
	 'athenaTranslation': formulaToAthena(p)}


def role_plural_dict = {'hypothesis': 'hypotheses', 'corollary': 'corollaries', 'axiom': 'axioms', 'definition': 'definitions', 'assumption': 'assumptions', 'lemma': 'lemmas', 'theorem': 'theorems', 'conjecture': 'conjectures',
                        'negated_conjecture': 'negated_conjectures', 'plain': 'plains', 'type': 'types', 'interpretation': 'interpretations', 'logic': 'logics', 'unknown': 'unknowns'}
           
def getPluralForm(tptp_role) = role_plural_dict[tptp_role]
  
def extendPossiblyFromScratch(D,tptp_role,tptp_name,athena_version) = 
  let plural_form = getPluralForm(tptp_role)
  in if member(plural_form,keys(D)) then extendDict(D,[[plural_form,({'name':tptp_name, 'athena_translation': athena_version})::D[plural_form]]])
     else extendDict(D,[[plural_form,[{'name':tptp_name, 'athena_translation': athena_version}]]])


def analyze_formula_lines(s) = 
  let meaning_rep = first(semantics(fof_lines(s)));
      updateAthenaFormulas(D,tptp_name,tptp_role,athena_version) = extendPossiblyFromScratch(D,tptp_role,tptp_name,athena_version)
  in letrec loop(fms,athena_formulas,D) = 
               match fms with 
                 [] => {'signature': D, 'all_formulas': athena_formulas}
               | fm::more => let res = analyze_formula_line(fm,D);
                                 res_sig = res['signature'];
				 tptp_formula_name = res['name'];
				 tptp_formula_role = res['role'];
                                 athena_translation = res['athenaTranslation'] 
                             in loop(more,
                                     updateAthenaFormulas(athena_formulas,tptp_formula_name,tptp_formula_role,athena_translation),
			             extendDict(D,zip(keys(res_sig),vals(res_sig)))) 
     in loop(children(meaning_rep),{},{'signature':{}})


def file = "/mnt/c/athenaGit/athena/ft/data/TPTP/TPTP-v9.0.0/Axioms/AGT001+1.ax"

def test(file) = analyze_formula_lines(readTPTPFileAsString(file))
   

EOF
load "tptp"

def f = "/mnt/c/athenaGit/athena/ft/data/TPTP/TPTP-v9.0.0/Problems/AGT/AGT001+1.p"
      
def lines = filterOut(readFile(f), fun l => let t = trim(l) in len(t) > 0 && first(t) == '%')

def s = concat(lines);

def test1 = "fof(query_1,conjecture, \n accept_team(countryamedicalorganization,countryacivilorganization,towna,n6) )."
def test2 = "fof(a1_1,axiom,    ! [A,C,N,L] :      ( accept_team(A,L,C,N)    <=> ( accept_city(A,C)        & accept_leader(A,L)        & accept_number(A,N) ) ) )."    
def test = "fof(left_zero_for_f,hypothesis, left_zero(f,f_left_zero)).\n %------------------------------------------------------------------------------ \n " ++ test1
    
fof_file_parser(test)


def test2 = "fof(query_1,conjecture,accept_team(countryamedicalorganization,countryacivilorganization,towna,n6))."

      (tptp_formula (formula_name "event_213")
                    (formula_role "axiom")
                    (formula_ast (negatedFormula (term_app (symbol "accept_team")
                                                           (list (symbol "christiansufferterrahumanitarianorganization")
                                                                 (symbol "sufferterragovernment")
                                                                 (symbol "towna")
                                                                 (symbol "n6"))))))
