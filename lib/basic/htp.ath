load "polarities"

(declare (A B C D E F G H I J) Boolean)


define (inconsistent? ab inconsistent-pair-cell) :=
  match ab {
    (split _ (list-of (some-sentence p) (split _ ((list-of q _) where (complements? p q))))) => let {_ := (set! inconsistent-pair-cell [p (not p)])} true 
  | _ => false 
  }

define MAX-ITERS := 50 

define (transform-forward hyp K) :=
  match hyp {
    (if p q) => let {p1 := (!force (or (complement p) q))}
                  (!K [p1])
  | (or (not p) q) => let {p1 := (!force (if p q))} (!K [p1])
  | (and (some-list props)) => (!decompose hyp K)
  | (iff p q) =>  let {p1 := (!force (and (if p q) (if q p)));
                       p2 := (!force (or (and p q) (and (not p) (not q))))}
                   (!K [p1 p2])
  | (not (and p q)) => let {p1 := (!force (or (complement p) (complement q)))}
                         (!K [p1])
  | (not (or p q)) => let {p1 := (!force (and (complement p) (complement q)))}
                        (!K [p1])
  | (not (not p)) => let {p1 := (!force p)}
                       (!K [p1])
  | _ => let {p1 := (!claim hyp)} (!K [p1])                       
  }

define (transform-forward* props K) := (!thread-method transform-forward props K)

define K1 := (method (results) #let {_ := (print "\nRESULTS:\n" results "\n")}
                (!true-intro))

define (forward-inference p K) :=
  letrec {combine := method (premise) 
                       match premise {
                         (if p1 p2) => check {(equal? p p1) => (!mp premise p)
                                            | (equal? p (complement p2)) => (!mt premise p)}
                       | (or p1 p2) => check {(|| (equal? p (complement p1)) (equal? p (complement p2))) => (!dsyl premise p)}
                       }}
    (!map-method-non-strictly combine (ab) K)
  
(define (forward-inference* props K)
   (!thread-method forward-inference props K))
                   
(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!forward-inference* results K)
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!loop results' (join results' results) (plus i 1))))})}
    (!loop props [] 0))

(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!K (dedup results))
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!forward-inference* results'
                                                             (method (results'')
                                                                    let {#_ := (print "\nNew results:\n" results');
                                                                         #_ := (print "\nOld results:\n" results);                                                                    
                                                                         D := (list-diff results'' results');
                                                                         #_ := (print "\nDIFF:\n" D "\n");
                                                                         R := (join results' results'')}
                                                                      (!loop R (join R results) (plus i 1))))))})}
    (!loop props [] 0))

define (all-disjunctions) := (merge-sort (filter (ab) disjunction?) (lambda (p1 p2) (less? (size p1) (size p2))))

define (htp goal) :=
  let {inconsistent-pair-cell := (cell [])}
     letrec {backward-tp := method (goal iteration)
                              match goal {
                                (and (some-list args)) => (!map-method (method (arg)
                                                                          (!tp arg (plus iteration 1)))
                                                                       args 
                                                                       method (_)
                                                                         match args {
                                                                           [(some-sentence p)] => (!claim p)
                                                                            | [p1 p2] => (!both p1 p2)
                                                                            | _ => (!conj-intro args)
                                                                          })
                              | (not (not p)) => let {_ := (!dn goal);
                                                      _ := (!tp p)}
                                                  (!bdn p)
                              | (if p q) => assume p
                                             (!process-hyps [p] (method (results) (!tp q (plus iteration 1))))
                              | (iff p q) => let {dir1 := (!tp (if p q) (plus iteration 1));
                                                  dir2 := (!tp (if q p) (plus iteration 1))}
                                              (!equiv dir1 dir2)
                              | (or p q) => try {(!left-either (!tp p (plus iteration 1)) q) | (!right-either p (!tp q (plus iteration 1))) | (!tp (!force (if (complement p) q)) (plus iteration 1))}
                              };
             tp := method (goal iteration)
                     check {(greater? iteration MAX-ITERS) => (!proof-error "Reached max iterations")
                          | (member? goal (ab)) => (!claim goal)
                          | (inconsistent? ab inconsistent-pair-cell) => (!from-complements goal (first (ref inconsistent-pair-cell)) (second (ref inconsistent-pair-cell)))
                          | else => try { (!backward-tp goal (plus 1 iteration))
                                        | (!dfind-element'*
                                            (ab) 
                                            lambda (premise) (Polarities.find-universally-positive-parent goal premise)
                                            method (premise polarity-result)
                                                match polarity-result {
                                                  [(some-sentence parent) parent-position-in-premise theta] =>
                                                    (!proof-error "")
                                                }
                                            method () (!proof-error "Failed application of extraction..."))
                                        | (!find-some (all-disjunctions) (method (d)
                                                                           (!map-method (method (disjunct)
                                                                                           (assume disjunct (!process-hyps [disjunct] (method (results) (!tp goal (plus iteration 1))))))
                                                                                         (get-disjuncts d)
                                                                                         (method (case-conditionals)
                                                                                            (!cases d case-conditionals)))))
                                        | (!by-contradiction goal
                                             assume h := (complement goal)
                                                (!process-hyps [h] (method (results) (!tp false (plus iteration 1)))))}}}
       (!tp goal 1)
       
EOF
load "lib/basic/htp"

assert p := (and (not (not A)) (iff B C))
#assert q := (if A D)


(!process-hyps [p] K1) 

(!htp (if A A))

(!htp (if (A ==> B) (if (B ==> C) (if A C))))

Every time a hypothesis enters the assumption base, it should not only be decomposed, but every decomposed conjunct should be transformed, potentially to multiple sentences, each of which
should again be decomposed and transformed etc. up until a fixed point. 