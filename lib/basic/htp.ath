load "polarities"

(declare (A B C D E F G H I J) Boolean)


define (inconsistent? abase inconsistent-pair-cell) :=
  let {#_     := (print "Checking if this is ab inconsistent:\n" abase "\n");
       is-in := lambda (x x' L) check {(member? x' L) => (seq (set! inconsistent-pair-cell [x x']) true) | else => false}}
    letrec {loop := lambda (p rest)
                      match rest {
                        [] => false
                      | (list-of h t) => (|| (is-in p (complement p) rest) (loop h t))
                      }}
       match abase {
         [] => false
       | (list-of p more) => (loop p more)
       }

define UPPER-BOUND := 100000
define MAX-ITERS := (cell 8)

define (transform-forward hyp K) :=
  match hyp {
    (if p q) => let {p1 := (!cond-def hyp)}
                  (!K [p1])
  | (or (not p) q) => let {p1 := (!cond-def hyp)} (!K [p1])
  | (and (some-list props)) => (!decompose hyp K)
  | (iff p q) =>  let {p1 := (!both (!left-iff hyp) (!right-iff hyp));
                       p2 := (!bicond-def' hyp)}
                   (!K [p1 p2])
  | (not (if p q)) => let {th := (!neg-cond hyp)}
                       (!K [th])
  | (not (iff p q)) => let {th := (!force (or (and p (complement q)) (and q (complement p))))}
                         (!K [th])                       
  | (not (and p q)) => let {p1 := (!dm hyp)}
                         (!K [p1])
  | (not (or p q)) => let {p1 := (!dm hyp)}
                        (!K [p1])
  | (not (not p)) => let {p1 := (!dn hyp)}
                       (!K [p1])
  | _ => let {p1 := (!claim hyp)} (!K [p1])                       
  }

define (transform-forward* props K) := (!thread-method transform-forward props K)

define K1 := (method (results) let {_ := (print "\nRESULTS:\n" results "\n")}
                (!true-intro))

define (forward-inference p K) :=
  letrec {combine := method (premise) 
                       match premise {
                         (if p1 p2) => check {(equal? p p1) => (!mp premise p)
                                            | (equal? p (complement p2)) => (!mt premise p)}
                       | (or p1 p2) => check {(|| (equal? p (complement p1)) (equal? p (complement p2))) => (!dsyl premise p)}
                       }}
    (!map-method-non-strictly combine (ab) K)
  
(define (forward-inference* props K)
   (!thread-method forward-inference props K))
                   
(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!forward-inference* results K)
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!loop results' (join results' results) (plus i 1))))})}
    (!loop props [] 0))

define (replace-atoms-by-vars p) :=
  let {make-var := lambda (atom)
                    (evaluate (join "?" (val->string atom) ":Boolean"))}
  match p {
    ((some-sent-con sc) (some-list args)) => (sc (map replace-atoms-by-vars args))
  | _ => (make-var p)
  }

define (tsat' L) := (tsat (map replace-atoms-by-vars L))

define (implies? p q) := (negate (tsat' [p (not q)]))

define (equivalent? p q) := (&& (implies? p q) (implies? q p))

define (truncate props) := 
   match props {
     [] => []
   | (list-of p more) =>
         let {rest := (filter-out more (lambda (q) (equivalent? q p)));
             delta := (minus (length props) (length rest));
                 _ := check {(greater? delta 0) => (print "\nEliminated" delta "candidates!") | else => ()}}
        (add p )
   }

define (truncate props) := props

(define (process-hyps given-props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => let {results' := (list-diff (dedup results) given-props)}                                                 
                                              (!K results')
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!forward-inference* results'
                                                             (method (results'')
                                                                    let {#_ := (print "\nNew results:\n" results');
                                                                         #_ := (print "\nOld results:\n" results);                                                                    
                                                                         D := (list-diff results'' results');
                                                                         #_ := (print "\nDIFF:\n" D "\n");
                                                                         R := (join results' results'')}
                                                                      (!loop R (join R results) (plus i 1))))))})}
    (!loop given-props [] 0))


define (all-disjunctions) := (merge-sort (filter (ab) disjunction?) (lambda (p1 p2) (less? (size p1) (size p2))))

define (increment i) := #let {_ := (print "\nIncrementing iteration to: " (plus i 1))}
                         (plus i 1)

define (pr x) :=
  match x {
    (some-sentence p) => 
       let {s := (replace-string "\n" " " (athena->tptp p))}
         (replace-string "  " " " s)
  | (some-list L) => (join "[" (separate (map pr L) ", ") "]")        
  }

define (decide L) :=
  match L {
     [] => ""
   | _ => (join " -- namely:" (pr L))
  }

define (htp goal) :=
  let {inconsistent-pair-cell := (cell []);
       table := (HashTable.table 1000);
       goal->string := lambda (goal) (join (ab->string) "|-" (pr goal)); 
       memoize := lambda (goal) (HashTable.add table [(goal->string goal) true]);
       cached? := lambda (goal) try {(HashTable.lookup table (goal->string goal)) | false };
       _                      := (execute-command "clear-assumption-base");
       #_ := (print "\nLength of ab after clearing it: " (length (ab)));
       _ := ()
       }
     letrec {backward-tp := method (goal iteration)
                              let {spaces0 := (join (copies "    " iteration));
                                   spaces := (join "\n" spaces0)}
                              match goal {
                                (and (some-list args)) => (!map-method (method (arg)
                                                                          (!tp arg (increment iteration)))
                                                                       args 
                                                                       method (_)
                                                                         match args {
                                                                           [(some-sentence p)] => (!claim p)
                                                                            | [p1 p2] => (!both p1 p2)
                                                                            | _ => (!conj-intro args)
                                                                          })
                              | (not (not p)) => let {_ := (!dn goal);
                                                      _ := (!tp p (increment iteration))}
                                                  (!bdn p)
                              | (if p q) => assume p
                                             (!process-hyps [p] (method (results)
                                                                  #let {_ := (print spaces "** Derived" (length results) "new results by processing this hypothesis:" (pr p) (decide results))}
                                                                  (!tp q (increment iteration))))
                              | (iff p q) => let {dir1 := (!tp (if p q) (increment iteration));
                                                  dir2 := (!tp (if q p) (increment iteration))}
                                              (!equiv dir1 dir2)
                              | (or p q) => try {(!left-either (!tp p (increment iteration)) q)
                                               | (!right-either p (!tp q (increment iteration)))
                                               | let {transformed    := (if (complement p) q);
                                                      transformed-th := (!tp transformed (increment iteration))}
                                                  (!cond-def transformed-th)
                                            }
                              };
             extract := method (goal premise polarity-result iteration)
                          match polarity-result {
                            [(some-sentence parent) parent-position-in-premise theta] =>
                              let {instantiated-parent := (theta parent);
                                   parent-polarity-in-premise := (Polarities.get-polarity parent-position-in-premise premise);
                                   negative-parent-polarity := (Polarities.negative-pol? parent-polarity-in-premise);       
                                   non-negative-parent-polarity := (negate negative-parent-polarity)}
                                match instantiated-parent {
                                  (and (some-list props)) =>
                                    let {parent-th := (!tp instantiated-parent (increment iteration))}
                                      match parent-th {
                                        (and (val-of goal) (some-sentence _)) => (!left-and parent-th)
                                      | (and (some-sentence _) (val-of goal)) => (!right-and parent-th)
                                      | (and (some-list _)) => (!conj-elim goal instantiated-parent) 
                                      }
                                | (or (some-list _))  =>
                                    let {disjuncts := (get-disjuncts instantiated-parent)}
                                      check {(member? goal disjuncts) =>
                                        let {disjunction-theorem := (!tp instantiated-parent (increment iteration))}
                                          (!map-method method (d) (!tp (if d goal) (increment iteration))
                                                       disjuncts
                                                        method (disjunct-conditionals)
                                                          (!cases disjunction-theorem
                                                                  disjunct-conditionals))}
                                | (if antecedent (val-of goal)) =>
                                    let {conditional-th := (!tp instantiated-parent (increment iteration));
                                         ant-th := (!tp antecedent  (increment iteration))}
                                      (!mp conditional-th ant-th)
                                | ((iff  left right) where non-negative-parent-polarity) =>
                                    let {bi-cond-th  := (!tp instantiated-parent (increment iteration))}
                                      check {(equal? goal left) =>  let {cond-th  := (!left-iff bi-cond-th);
                                                                         left-ant := (!tp left (increment iteration))}
                                                                      (!mp cond-th left-ant)
                                           | (equal? goal right) => let {cond-th  := (!right-iff bi-cond-th);
                                                                         right-ant := (!tp right (increment iteration))}
                                                                      (!mp cond-th right-ant)
                                      }
                                | ((|| (not (some-sentence body)) (if (val-of goal) (some-sentence consequent))) where negative-parent-polarity) =>
                                    let {dn-parent := (!tp (not instantiated-parent) (increment iteration))}
                                      match instantiated-parent {
                                        (not _)  => (!dn dn-parent)
                                      | (if _ _) => let {nc-th := (!neg-cond dn-parent)}
                                                     (!left-and nc-th)
                                    }
                                }
                          };
             prove := method (goal limit) 
                       check {(greater? limit UPPER-BOUND) => (!dhalt) 
                            | else => let {_ := (set! MAX-ITERS limit);
                                           _ := (print "\nWill try with MAX-ITERS: " limit);
                                           _ := ()
                                          }
                                        try {(!tp goal 1)
                                           | (!prove goal (times limit 2))}};
             tp := method (goal iteration)
                     let {abase := (ab);
                          #_ := (print "\nITERATION: " iteration);
                          spaces0 := (join (copies "    " iteration));
                          spaces := (join "\n" spaces0);
                          #_ := (print spaces "Given goal: " (pr goal) " and ab: " abase ", hence (member? goal (ab)) is: " (member? goal abase));
                          _ := ()}
                     check {(cached? goal) => #let {_ := (print "\nCYCLE DETECTED!")}
                                                (!proof-error "")
                          | else => 
                     let {_ := (memoize goal)}                                        
                     check {(greater? iteration (ref MAX-ITERS)) => #let {_ := (print spaces "Reached max iterations:" (ref MAX-ITERS))}
                                                                      (!proof-error "Reached max iterations")
                          | (member? goal abase) => (!claim goal)
                          | (inconsistent? abase inconsistent-pair-cell) =>
                                 #let {_ := (print spaces "Inconsistent ab, nice...")} 
                                   (!from-complements goal (first (ref inconsistent-pair-cell)) (second (ref inconsistent-pair-cell)))
                          | else => try { let {#_    := (print spaces "Trying a backward tactic on this goal:" (pr goal));
                                                res := (cell false);
                                              b-th  := try {let {th := (!backward-tp goal (plus 1 iteration));
                                                                  _ := (set! res true)}
                                                              (!claim th) |
                                                            let {_ := (set! res false)}
                                                              (!true-intro)}}
                                             match (ref res) {
                                                 true => #let {_ := (print spaces "Backward tactic SUCCEDED on this goal:" (pr goal))}
                                                           (!claim b-th)
                                               | _ => #let {_ := (print spaces "Backward tactic failed...")}
                                                        (!proof-error "")
                                             }
                                        | let {cands := (filter (ab) lambda (premise) (unequal? (Polarities.find-universally-positive-parent goal premise) ()));
                                               cands := (truncate (merge-sort cands (lambda (p1 p2) (leq? (size p1) (size p2)))));
                                                   #_ := (print spaces "For the goal" (pr goal) "there are" (length cands) "extraction candidates:" (pr cands));
                                                   _ := ()}
                                          (!dfind-element'*
                                            cands 
                                            lambda (premise) (Polarities.find-universally-positive-parent goal premise)
                                            method (premise polarity-result) let {#_ := (print spaces "{About to try extraction on this goal:" (pr goal) "from this premise:" (pr premise));
                                                                                  e-th := (!extract goal premise polarity-result iteration);
                                                                                  #   _ := (print spaces "Extraction worked...\n")
                                                                                      _ := ()
                                                                                  }
                                                                               (!claim e-th)                                                                                    
                                            method () # let {_ := (print spaces "Failed all extraction attempts for this goal: " (pr goal) "}")}
                                                        (!proof-error "Failed application of extraction..."))
                                        | let {AD := (all-disjunctions);
                                              #     _ := (print spaces "For the goal" (pr goal) ", there are" (length AD) "candidates for case analysis:" (pr AD));                                        
                                               cands := (truncate (merge-sort AD (lambda (p1 p2) (leq? (size p1) (size p2)))));
                                               cands := (take cands 2);
                                                _ := ()
                                               }
                                            (!find-some AD 
                                                        (method (d)
                                                           let {_ := ();
                                                               # _ := (print spaces "Will try a case analysis on this goal:" (pr goal) " using this disjunction:" (pr d));
                                                                _ := ()
                                                              }
                                                             (!map-method (method (disjunct)
                                                                             (assume disjunct
                                                                                (!process-hyps
                                                                                   [disjunct]
                                                                                   (method (results)
                                                                                      #let {_ := (print spaces "** Derived" (length results) "new results by processing this disjunct:" (pr disjunct) (decide results))}
                                                                                        (!tp goal (increment iteration))))))
                                                                          (get-disjuncts d)
                                                                          (method (case-conditionals)
                                                                            (!cases d case-conditionals))))
                                                        (method () #let {_ := (print spaces "No case analysis succeeded on this goal:" (pr goal))}
                                                                      (!proof-error "All case analysis failed.")))
                                        | check {(equal? goal false) => (!proof-error "")
                                                | else => let {#_ := (print spaces "Trying a proof by contradiction on this goal: " (pr goal));
                                                               _ := ()
                                                              } 
                                                            (!by-contradiction goal
                                                              assume h := (complement goal)
                                                                (!process-hyps [h] (method (results)
                                                                                     #let {_ := (print spaces "** Derived" (length results) "new results by processing this hypothesis:" (pr h) (decide results))}
                                                                                       (!tp false (increment iteration)))))}}}}}
       (!prove goal 8)

clear-assumption-base

define (solve-problem random-line) :=
  let {toks := (map trim-ws (tokenize random-line "#"));
       goal := (evaluate (last toks));
       premises := (map evaluate (all-but-last toks));
       _ := (execute-command "clear-assumption-base");
       success := (cell false);
       res := try { let {_ := (!dtime-out (method () (!htp (if (and* premises) goal))) 30000); _ := (set! success true)} (!true-intro) | let {_ := (print "\nFailed on this problem: " random-line)} (!true-intro)}}
    (ref success)
    
       
define (solve-all random-problem-file) :=
  let {lines := (tokenize (read-file random-problem-file) "\n");
       failures := (cell 0);
       counter := (cell 1);
       _ := (map-proc (lambda (line)
                         let {_ := check {(equal? (mod (ref counter) 100) 0) => (print "\nProcessed " (ref counter) " problems, with " (ref failures) " failures...") | else => ()};
                              _ := (inc counter)}
                         check {(solve-problem line) => ()
                              | else => (inc failures)})
                      lines)}
    (print "\nTotal number of failures: " (ref failures))                       

define rf := "/mnt/c/athenaGit/athena/lib/basic/random.txt"

define random-line := "((A & C) | (C <==> (~ (B | A)))) # (C ==> A) # ((~A & B) ==> (~ (A ==> C))) # A"
define toks := (map trim-ws (tokenize random-line "#"))
define goal := (evaluate (last toks))
define premises := (map evaluate (all-but-last toks))
define g := (if (and* premises) goal)

define (make-problem line) := 
 let {toks := (map trim-ws (tokenize line "#"));
      goal := (evaluate (last toks));
      premises := (map evaluate (all-but-last toks))}
    (if (and* premises) goal)


define (solve line) :=
 let {toks := (map trim-ws (tokenize line "#"));
      goal := (evaluate (last toks));
      premises := (map evaluate (all-but-last toks));
      g := (if (and* premises) goal)}
   (!htp g)      

   
# (!solve "((E | (B ==> ~A)) ==> (C ==> (~ (C & D)))) # D # (C | E) # ((A ==> E) & (D | B)) # (E | (B & E))")

EOF
load "lib/basic/htp"
(!solve "(A ==> (B & ~A)) # ((~A ==> C) | (B & ~A)) # ((C ==> A) | (~C & (C | A))) # B")

(clear-assumption-base)
(!solve "((A & C) ==> (C <==> B)) # ((B ==> C) <==> (B | C)) # ((~ (C & B)) | (A & C)) # ((B | A) ==> (B & A))")
(clear-assumption-base)
(!solve "(A ==> (B & ~A)) # ((~A ==> C) | (B & ~A)) # ((C ==> A) | (~C & (C | A))) # B")
(clear-assumption-base)
(!solve "((~ (C ==> D)) ==> (A & ~C)) # (~D <==> B) # (D ==> B) # (B <==> ~C)")
(clear-assumption-base)
(!solve "(A ==> (B & A)) # ((A ==> ~B) & (A | C)) # ((C & ~B) <==> (A & C)) # B")
(clear-assumption-base)
(!solve "((A <==> (A & C)) & (A | (~ (B | C)))) # ((~ (B & (A ==> B))) ==> (~C ==> (A | B))) # (A <==> (B & C)) # B")
(clear-assumption-base)

(solve-problem random-line)





(solve-all rf)

1K problems in 10 minutes
10K problems in about 1.5 hours 

#Extraction-relevant examples: 

(!htp (or A (not A)))




(set! MAX-ITERS 10)

(!htp (if B (if (not (if A B)) C)))



assert [(A ==> B) (B ==> C) (~ C)]

assume  A (!process-hyps [A] K1)


#assert p := (and (not (not A)) (iff B C))
#assert q := (if A D)

(!process-hyps [p] K1) 

(!htp (if A A))
(!htp (or A (not A)))
(!htp (if (A ==> B) (if (B ==> C) (if A C))))

(!htp (if (A ==> B) (if (A ==> C) (if A (and B C)))))

(!htp (if (and (if A (if B C))
               (if A (if C D)))
          (if A (if B D))))



qqq          
(!htp (if (and (if A B)
               (if C D))
          (if (or A C)
              (or B D))))

          
(!htp (iff (and A A) A))


(!htp (if (and (if A B)
               (and (if (not A) C)
                    (if C D)))
          (or B D)))                    
                      
(set! MAX-ITERS 40)

(!htp (if (and (if A B)
               (and (if B C)
                    (not C)))
          (not (or A B))))                    


          
Every time a hypothesis enters the assumption base, it should not only be decomposed, but every decomposed conjunct should be transformed, potentially to multiple sentences, each of which
should again be decomposed and transformed etc. up until a fixed point.



define p1 := (( A ==> B) & (C ==> D ))
define p2 := (A | C)
define p3 := ((A ==> ~D) & (C ==> ~B))
define p4 := ((~(B & ~D)) | E)
define p5 := (D ==> (~ ~ B) | F )
define goal := (~ (~E & ~F))


(!dtime-out (method () (!htp ((p1 & p2 & p3 & p4 & p5) ==> goal))) 30000)


define (solve-problem random-line) :=
  let {toks := (map trim-ws (tokenize random-line "#"));
       goal := (evaluate (last toks));
       premises := (map evaluate (all-but-last toks));
       _ := (execute-command "clear-assumption-base");
       success := (cell false);
       res := try { let {_ := (!dtime-out (method () (!htp (if (and* premises) goal))) 50000); _ := (set! success true)} (!true-intro) | let {_ := (print "\nFailed on this problem: " random-line)} (!true-intro)}}
    (ref success)
    
       
define (solve-all random-problem-file) :=
  let {lines := (tokenize (read-file random-problem-file) "\n")
       failures := (cell 0);
       counter := (cell 0);
       _ := (map-proc (lambda (line)
                         let {_ := check {(equal? (mod (inc counter) 100) 0) => (print "\nProcessed " (ref counter) " problems so far...") | else => ()}}
                         check {(solve-problem line) => ()
                              | else => (inc failures)})
                      lines)}
    (print "\nTotal number of failures: " (ref failures))                       


  
define rf := "/mnt/c/athenaGit/athena/lib/basic/random.txt"

(solve-all rf)

define l := (if (and (B | A) ((~ (C <==> A)) | (C & B))  C)  B)

define p1 := ((A & (A | C)) ==> (C & (C | B)))
define p2 := ((~ (B | (~ (B ==> ~A)))) | (A & (B | ~B)))
define p3 := B
define goal := (B & C)
(clear-assumption-base)

(!dtime-out (method () (!htp ((p1 & p2 & p3) ==> goal))) 30000)