load "polarities"

(declare (A B C D E F G H I J) Boolean)


define (inconsistent? ab inconsistent-pair-cell) :=
  match ab {
    (split _ (list-of (some-sentence p) (split _ ((list-of q _) where (complements? p q))))) => let {_ := (set! inconsistent-pair-cell [p (not p)])} true 
  | _ => false 
  }

define MAX-ITERS := 50 

define (transform-forward hyp K) :=
  match hyp {
    (if p q) => let {p1 := (!force (or (complement p) q))}
                  (!K [p1])
  | (or (not p) q) => let {p1 := (!force (if p q))} (!K [p1])
  | (and (some-list props)) => (!decompose hyp K)
  | (iff p q) =>  let {p1 := (!force (and (if p q) (if q p)));
                       p2 := (!force (or (and p q) (and (not p) (not q))))}
                   (!K [p1 p2])
  | (not (and p q)) => let {p1 := (!force (or (complement p) (complement q)))}
                         (!K [p1])
  | (not (or p q)) => let {p1 := (!force (and (complement p) (complement q)))}
                        (!K [p1])
  | (not (not p)) => let {p1 := (!force p)}
                       (!K [p1])
  | _ => let {p1 := (!claim hyp)} (!K [p1])                       
  }

define (transform-forward* props K) := (!thread-method transform-forward props K)

define K1 := (method (results) #let {_ := (print "\nRESULTS:\n" results "\n")}
                (!true-intro))

define (forward-inference p K) :=
  letrec {combine := method (premise) 
                       match premise {
                         (if p1 p2) => check {(equal? p p1) => (!mp premise p)
                                            | (equal? p (complement p2)) => (!mt premise p)}
                       | (or p1 p2) => check {(|| (equal? p (complement p1)) (equal? p (complement p2))) => (!dsyl premise p)}
                       }}
    (!map-method-non-strictly combine (ab) K)
  
(define (forward-inference* props K)
   (!thread-method forward-inference props K))
                   
(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!forward-inference* results K)
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!loop results' (join results' results) (plus i 1))))})}
    (!loop props [] 0))

(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!K (dedup results))
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!forward-inference* results'
                                                             (method (results'')
                                                                    let {#_ := (print "\nNew results:\n" results');
                                                                         #_ := (print "\nOld results:\n" results);                                                                    
                                                                         D := (list-diff results'' results');
                                                                         #_ := (print "\nDIFF:\n" D "\n");
                                                                         R := (join results' results'')}
                                                                      (!loop R (join R results) (plus i 1))))))})}
    (!loop props [] 0))

define (all-disjunctions) := (merge-sort (filter (ab) disjunction?) (lambda (p1 p2) (less? (size p1) (size p2))))

define (htp goal) :=
  let {inconsistent-pair-cell := (cell [])}
     letrec {backward-tp := method (goal iteration)
                              match goal {
                                (and (some-list args)) => (!map-method (method (arg)
                                                                          (!tp arg (plus iteration 1)))
                                                                       args 
                                                                       method (_)
                                                                         match args {
                                                                           [(some-sentence p)] => (!claim p)
                                                                            | [p1 p2] => (!both p1 p2)
                                                                            | _ => (!conj-intro args)
                                                                          })
                              | (not (not p)) => let {_ := (!dn goal);
                                                      _ := (!tp p)}
                                                  (!bdn p)
                              | (if p q) => assume p
                                             (!process-hyps [p] (method (results) (!tp q (plus iteration 1))))
                              | (iff p q) => let {dir1 := (!tp (if p q) (plus iteration 1));
                                                  dir2 := (!tp (if q p) (plus iteration 1))}
                                              (!equiv dir1 dir2)
                              | (or p q) => try {(!left-either (!tp p (plus iteration 1)) q) | (!right-either p (!tp q (plus iteration 1))) | (!tp (!force (if (complement p) q)) (plus iteration 1))}
                              };
             extract := method (goal premise polarity-result iteration)
                          match polarity-result {
                            [(some-sentence parent) parent-position-in-premise theta] =>
                              let {instantiated-parent := (theta parent);
                                   parent-polarity-in-premise := (Polarities.get-polarity parent-position-in-premise premise);
                                   negative-parent-polarity := (Polarities.negative-pol? parent-polarity-in-premise);       
                                   non-negative-parent-polarity := (negate negative-parent-polarity)}
                                match instantiated-parent {
                                  (and (some-list props)) =>
                                    let {parent-th := (!tp instantiated-parent (plus iteration 1))}
                                      match parent-th {
                                        (and (val-of goal) (some-sentence _)) => (!left-and parent-th)
                                      | (and (some-sentence _) (val-of goal)) => (!right-and parent-th)
                                      | (and (some-list _)) => (!conj-elim goal instantiated-parent) 
                                      }
                                | (or (some-list _))  =>
                                    let {disjuncts := (get-disjuncts instantiated-parent)}
                                      check {(member? goal disjuncts) =>
                                        let {disjunction-theorem := (!tp instantiated-parent (plus iteration 1))}
                                          (!map-method method (d) (!tp (if d goal) (plus iteration 1))
                                                       disjuncts
                                                        method (disjunct-conditionals)
                                                          (!cases disjunction-theorem
                                                                  disjunct-conditionals))}
                                | (if antecedent (val-of goal)) =>
                                    let {conditional-th := (!tp instantiated-parent (plus iteration 1));
                                         ant-th := (!tp antecedent  (plus iteration 1))}
                                      (!mp conditional-th ant-th)
                                | ((iff  left right) where non-negative-parent-polarity) =>
                                    let {bi-cond-th  := (!tp instantiated-parent (plus iteration 1))}
                                      check {(equal? goal left) =>  let {cond-th  := (!left-iff bi-cond-th);
                                                                         left-ant := (!tp left (plus iteration 1))}
                                                                      (!mp cond-th left-ant)
                                           | (equal? goal right) => let {cond-th  := (!right-iff bi-cond-th);
                                                                         right-ant := (!tp right (plus iteration 1))}
                                                                      (!mp cond-th right-ant)
                                      }
                                | ((|| (not (some-sentence body)) (if (val-of goal) (some-sentence consequent))) where negative-parent-polarity) =>
                                    let {dn-parent := (!tp (not instantiated-parent) (plus iteration 1))}
                                      match instantiated-parent {
                                        (not _)  => (!dn dn-parent)
                                      | (if _ _) => let {nc-th := (!neg-cond dn-parent)}
                                                     (!left-and nc-th)
                                    }
                                }
                          };
             tp := method (goal iteration)
                     check {(greater? iteration MAX-ITERS) => (!proof-error "Reached max iterations")
                          | (member? goal (ab)) => (!claim goal)
                          | (inconsistent? ab inconsistent-pair-cell) => (!from-complements goal (first (ref inconsistent-pair-cell)) (second (ref inconsistent-pair-cell)))
                          | else => try { (!backward-tp goal (plus 1 iteration))
                                        | (!dfind-element'*
                                            (ab) 
                                            lambda (premise) (Polarities.find-universally-positive-parent goal premise)
                                            method (premise polarity-result) (!extract goal premise polarity-result iteration)
                                            method () (!proof-error "Failed application of extraction..."))
                                        | (!find-some (all-disjunctions) (method (d)
                                                                           (!map-method (method (disjunct)
                                                                                           (assume disjunct (!process-hyps [disjunct] (method (results) (!tp goal (plus iteration 1))))))
                                                                                         (get-disjuncts d)
                                                                                         (method (case-conditionals)
                                                                                            (!cases d case-conditionals)))))
                                        | (!by-contradiction goal
                                             assume h := (complement goal)
                                                (!process-hyps [h] (method (results) (!tp false (plus iteration 1)))))}}}
       (!tp goal 1)
       
EOF
load "lib/basic/htp"

assert p := (and (not (not A)) (iff B C))
#assert q := (if A D)

(!process-hyps [p] K1) 

(!htp (if A A))

(!htp (if (A ==> B) (if (B ==> C) (if A C))))

Every time a hypothesis enters the assumption base, it should not only be decomposed, but every decomposed conjunct should be transformed, potentially to multiple sentences, each of which
should again be decomposed and transformed etc. up until a fixed point. 