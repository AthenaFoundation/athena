load "polarities"

(declare (A B C D E F G H I J) Boolean)


define (inconsistent? abase inconsistent-pair-cell) :=
  let {#_     := (print "Checking if this is ab inconsistent:\n" abase "\n");
       is-in := lambda (x x' L) check {(member? x' L) => (seq (set! inconsistent-pair-cell [x x']) true) | else => false}}
    letrec {loop := lambda (p rest)
                      match rest {
                        [] => false
                      | (list-of h t) => (|| (is-in p (complement p) rest) (loop h t))
                      }}
       match abase {
         [] => false
       | (list-of p more) => (loop p more)
       }


define MAX-ITERS := (cell 10)

define (transform-forward hyp K) :=
  match hyp {
    (if p q) => let {p1 := (!force (or (complement p) q))}
                  (!K [p1])
  | (or (not p) q) => let {p1 := (!force (if p q))} (!K [p1])
  | (and (some-list props)) => (!decompose hyp K)
  | (iff p q) =>  let {p1 := (!force (and (if p q) (if q p)));
                       p2 := (!force (or (and p q) (and (not p) (not q))))}
                   (!K [p1 p2])
  | (not (if p q)) => let {th := (!force (and p (not q)))}
                       (!K [th])
  | (not (and p q)) => let {p1 := (!force (or (complement p) (complement q)))}
                         (!K [p1])
  | (not (or p q)) => let {p1 := (!force (and (complement p) (complement q)))}
                        (!K [p1])
  | (not (not p)) => let {p1 := (!force p)}
                       (!K [p1])
  | _ => let {p1 := (!claim hyp)} (!K [p1])                       
  }

define (transform-forward* props K) := (!thread-method transform-forward props K)

define K1 := (method (results) let {_ := (print "\nRESULTS:\n" results "\n")}
                (!true-intro))

define (forward-inference p K) :=
  letrec {combine := method (premise) 
                       match premise {
                         (if p1 p2) => check {(equal? p p1) => (!mp premise p)
                                            | (equal? p (complement p2)) => (!mt premise p)}
                       | (or p1 p2) => check {(|| (equal? p (complement p1)) (equal? p (complement p2))) => (!dsyl premise p)}
                       }}
    (!map-method-non-strictly combine (ab) K)
  
(define (forward-inference* props K)
   (!thread-method forward-inference props K))
                   
(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!forward-inference* results K)
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!loop results' (join results' results) (plus i 1))))})}
    (!loop props [] 0))

(define (process-hyps props K)
 letrec {loop := (method (props results i)
                    check {(greater? i 3) => (!K (dedup results))
                         | else => (!transform-forward* props
                                                        (method (results')
                                                          (!forward-inference* results'
                                                             (method (results'')
                                                                    let {#_ := (print "\nNew results:\n" results');
                                                                         #_ := (print "\nOld results:\n" results);                                                                    
                                                                         D := (list-diff results'' results');
                                                                         #_ := (print "\nDIFF:\n" D "\n");
                                                                         R := (join results' results'')}
                                                                      (!loop R (join R results) (plus i 1))))))})}
    (!loop props [] 0))

define (all-disjunctions) := (merge-sort (filter (ab) disjunction?) (lambda (p1 p2) (less? (size p1) (size p2))))

define (increment i) := #let {_ := (print "\nIncrementing iteration to: " (plus i 1))}
                         (plus i 1)

define (htp goal) :=
  let {inconsistent-pair-cell := (cell [])}
     letrec {backward-tp := method (goal iteration)
                              match goal {
                                (and (some-list args)) => (!map-method (method (arg)
                                                                          (!tp arg (increment iteration)))
                                                                       args 
                                                                       method (_)
                                                                         match args {
                                                                           [(some-sentence p)] => (!claim p)
                                                                            | [p1 p2] => (!both p1 p2)
                                                                            | _ => (!conj-intro args)
                                                                          })
                              | (not (not p)) => let {_ := (!dn goal);
                                                      _ := (!tp p (increment iteration))}
                                                  (!bdn p)
                              | (if p q) => assume p
                                             (!process-hyps [p] (method (results) (!tp q (increment iteration))))
                              | (iff p q) => let {dir1 := (!tp (if p q) (increment iteration));
                                                  dir2 := (!tp (if q p) (increment iteration))}
                                              (!equiv dir1 dir2)
                              | (or p q) => try {(!left-either (!tp p (increment iteration)) q)
                                               | (!right-either p (!tp q (increment iteration)))
                                               | let {transformed    := (if (complement p) q);
                                                      transformed-th := (!tp transformed (increment iteration))}
                                                  (!cond-def transformed-th)
                                            }
                              };
             extract := method (goal premise polarity-result iteration)
                          match polarity-result {
                            [(some-sentence parent) parent-position-in-premise theta] =>
                              let {instantiated-parent := (theta parent);
                                   parent-polarity-in-premise := (Polarities.get-polarity parent-position-in-premise premise);
                                   negative-parent-polarity := (Polarities.negative-pol? parent-polarity-in-premise);       
                                   non-negative-parent-polarity := (negate negative-parent-polarity)}
                                match instantiated-parent {
                                  (and (some-list props)) =>
                                    let {parent-th := (!tp instantiated-parent (increment iteration))}
                                      match parent-th {
                                        (and (val-of goal) (some-sentence _)) => (!left-and parent-th)
                                      | (and (some-sentence _) (val-of goal)) => (!right-and parent-th)
                                      | (and (some-list _)) => (!conj-elim goal instantiated-parent) 
                                      }
                                | (or (some-list _))  =>
                                    let {disjuncts := (get-disjuncts instantiated-parent)}
                                      check {(member? goal disjuncts) =>
                                        let {disjunction-theorem := (!tp instantiated-parent (increment iteration))}
                                          (!map-method method (d) (!tp (if d goal) (increment iteration))
                                                       disjuncts
                                                        method (disjunct-conditionals)
                                                          (!cases disjunction-theorem
                                                                  disjunct-conditionals))}
                                | (if antecedent (val-of goal)) =>
                                    let {conditional-th := (!tp instantiated-parent (increment iteration));
                                         ant-th := (!tp antecedent  (increment iteration))}
                                      (!mp conditional-th ant-th)
                                | ((iff  left right) where non-negative-parent-polarity) =>
                                    let {bi-cond-th  := (!tp instantiated-parent (increment iteration))}
                                      check {(equal? goal left) =>  let {cond-th  := (!left-iff bi-cond-th);
                                                                         left-ant := (!tp left (increment iteration))}
                                                                      (!mp cond-th left-ant)
                                           | (equal? goal right) => let {cond-th  := (!right-iff bi-cond-th);
                                                                         right-ant := (!tp right (increment iteration))}
                                                                      (!mp cond-th right-ant)
                                      }
                                | ((|| (not (some-sentence body)) (if (val-of goal) (some-sentence consequent))) where negative-parent-polarity) =>
                                    let {dn-parent := (!tp (not instantiated-parent) (increment iteration))}
                                      match instantiated-parent {
                                        (not _)  => (!dn dn-parent)
                                      | (if _ _) => let {nc-th := (!neg-cond dn-parent)}
                                                     (!left-and nc-th)
                                    }
                                }
                          };
             tp := method (goal iteration)
                     let {abase := (ab);
                          _ := (print "\nTrying to derive:\n" goal "\nfrom ab tag: " (ab-tag) "\n")}
                     check {(greater? iteration (ref MAX-ITERS)) =>   #let {_ := (print "\nReached max iterations!\n")}
                                                                    (!proof-error "Reached max iterations")
                          | (member? goal abase) => (!claim goal)
                          | (inconsistent? abase inconsistent-pair-cell) => (!from-complements goal (first (ref inconsistent-pair-cell)) (second (ref inconsistent-pair-cell)))
                          | else => try { let {b-th := (!backward-tp goal (plus 1 iteration));
                                               #  _ := (print "\nBackward tactic succeeded on this goal: " goal "\nwith this theorem:\n" b-th "\n")
                                                  _ := ()
                                              }
                                            (!claim b-th)
                                        | (!dfind-element'*
                                            (ab) 
                                            lambda (premise) (Polarities.find-universally-positive-parent goal premise)
                                            method (premise polarity-result) let {_ := (print "\nAbout to try extraction on this goal:\n" goal "\nfrom this premise:\n" premise);
                                                                                  e-th := (!extract goal premise polarity-result iteration);
                                                                                     _ := (print "\nExtraction worked...\n")}
                                                                               (!claim e-th)                                                                                    
                                            method () (!proof-error "Failed application of extraction..."))
                                        | let {AD := (all-disjunctions);
                                               #_ := (print "\nALL DISJUNCTIONS:\n" AD "\n")
                                                _ := ()
                                               }
                                            (!find-some (all-disjunctions)
                                                        (method (d)
                                                           let {_ := ()} # (print "\nWill try a case analysis on this goal:\n" goal "\nusing this disjunction:\n" d "\n")}
                                                             (!map-method (method (disjunct)
                                                                             (assume disjunct
                                                                                (!process-hyps
                                                                                   [disjunct]
                                                                                   (method (results)
                                                                                     let {_ := ()} # (print "\nHere's results from processing the disjunct " disjunct ":\n" results "\nWILL now go on to prove:\n" goal "\n")}
                                                                                     (!tp goal (increment iteration))))))
                                                                          (get-disjuncts d)
                                                                          (method (case-conditionals)
                                                                            (!cases d case-conditionals))))
                                                        (method () let {_ := ()} # (print "\nNo case analysis succeeded!!!\n")}
                                                                      (!proof-error "No case analysis succeeded.")))
                                        | check {(equal? goal false) => (!proof-error "")
                                                | else => let {_ := ()} # (print "\nTrying by contradiction on this: " goal "\nat iteration: " iteration "\n")}
                                                            (!by-contradiction goal
                                                              assume h := (complement goal)
                                                                (!process-hyps [h] (method (results) (!tp false (increment iteration)))))}}}}
       (!tp goal 1)

(clear-assumption-base)       
EOF
load "lib/basic/htp"

(set! MAX-ITERS 10)

(!htp (if B (if (not (if A B)) C)))



assert [(A ==> B) (B ==> C) (~ C)]

assume  A (!process-hyps [A] K1)


#assert p := (and (not (not A)) (iff B C))
#assert q := (if A D)

(!process-hyps [p] K1) 

(!htp (if A A))

(!htp (or A (not A)))
(!htp (if (A ==> B) (if (B ==> C) (if A C))))

(!htp (if (A ==> B) (if (A ==> C) (if A (and B C)))))

(!htp (if (and (if A (if B C))
               (if A (if C D)))
          (if A (if B D))))



qqq          
(!htp (if (and (if A B)
               (if C D))
          (if (or A C)
              (or B D))))

          
(!htp (iff (and A A) A))


(!htp (if (and (if A B)
               (and (if (not A) C)
                    (if C D)))
          (or B D)))                    
                      
(set! MAX-ITERS 40)

(!htp (if (and (if A B)
               (and (if B C)
                    (not C)))
          (not (or A B))))                    

Every time a hypothesis enters the assumption base, it should not only be decomposed, but every decomposed conjunct should be transformed, potentially to multiple sentences, each of which
should again be decomposed and transformed etc. up until a fixed point. 