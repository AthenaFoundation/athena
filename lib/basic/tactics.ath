module Tactics {

# A record (or frame) on the goal stack has the following form:
# |{
#   'goal           := <a sentence>,
#   'id             := <a unique identifier (e.g. a Dewey path)>
#   'assumptions    := <a list of assumptions>,
#   'eigenvariables := <a list of eigenvariables>,
#   'witnesses      := <a list of witness variables>,
#   'parent         := <uplink to the parent or to ()>
#   'children       := <downinks to children or to ()> 
# }|    


 define goal-stack := (cell [])

 define goal-id-counter := (cell 0)

 define root-goal := (cell ())

 define fresh-goal-id := lambda () (join "g" (val->string (inc goal-id-counter)))

 define (add-all p assumptions) :=
    (join assumptions (dedup (get-conjuncts-recursive p)))
 
 define clear-state :=
   lambda ()
      (seq (set! root-goal (cell ()))
           (set! goal-id-counter 0))
           
define set-goal :=
  lambda (goal-sentence)
    let {_         := (clear-state);
         goal-node := |{'id             := (fresh-goal-id),
                        'path           := [],
                        'goal           := goal-sentence,
                        'assumptions    := [],
                        'eigenvariables := [],
                        'witnesses      := [],
                        'parent         := (),
                        'children       := (cell [])}|;
         _ := (set! root-goal goal-node)}
     (set! goal-stack [goal-node])

define (set-parent g1 g2) :=
# Make g1 the parent of g2 and g2 a child of g1:
  let {_ := (set! (g1 'children)
                  (join (ref (g1 'children)) [g2]))}
    (seq (set! (g2 'parent) g1))
       
define (set-parent* g1 goal-records) :=
  (map-proc (lambda (g) (set-parent g1 g)) goal-records)

# Apply a given tactic to the top goal:

define (add-child goal child) := 
  let {goal-children-cell := (goal 'children);
       goal-children      := (ref goal-children-cell)}
    (set! goal-children-cell (join goal-children [child]))
  
define (make-child goal new-child-bindings) :=
  let {child :=   (Map.add goal (join [['parent goal]
                                       ['id (fresh-goal-id)]
                                       ['children (cell [])]]
                                       new-child-bindings));
       _ := (add-child goal child)}
    child 

define (extend-path goal index) := (join (goal 'path) [index])

define (make-subgoals goal subgoals) := 
  let {make-subgoal := lambda (p index) (make-child goal [['goal p] ['path (extend-path goal index)]]);
       counter := (cell 1)}
    (map lambda (p) (make-subgoal p (inc counter))
         subgoals)
  
define (backward-tactic goal-stack tactic-name) :=
   match goal-stack {
     (list-of goal-record rest) =>
         match (goal-record 'goal) {
           (and (some-list conjuncts)) => 
             let {make-new-goal-record := lambda (conjunct) (make-child goal-record [['goal conjunct]]);
                  new-goal-records := (make-subgoals goal-record conjuncts);
                         new-stack := (join new-goal-records rest)}
               new-stack
         | (if (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal q] ['assumptions  (add-all p (goal-record 'assumptions))]])}
               (add goal-record' rest)
         | (iff (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal (and (if p q) (if q p))]])}
               (add goal-record' rest)
         | (or (some-sentence p) (some-sentence q)) =>
             let {[new-goal new-assumption] := check {(tactic-name equals? 'back-lor) => [p (not q)] | else => [q (not p)]};
                  goal-record'   := (make-child goal-record [['goal new-goal] ['assumptions  (add-all new-assumption (goal-record 'assumptions))]])}
               (add goal-record' rest)                                    
         | _ => goal-stack
         }
   | _ => (error "Error: Attempt to apply the backward tactic to an empty goal stack.")         
   }

define tactic-dictionary :=
  |{
    'back-lor := lambda (goal-stack) (backward-tactic goal-stack 'lor),
    'back-ror := lambda (goal-stack) (backward-tactic goal-stack 'back-ror),
    'back-if  := lambda (goal-stack) (backward-tactic goal-stack 'back-if),
    'back-iff := lambda (goal-stack) (backward-tactic goal-stack 'back-iff),
    'back-and := lambda (goal-stack) (backward-tactic goal-stack 'back-end),                
  }|
  
define (show-goal-record g i N) :=
  (print "\n\n****************************** Stack record" i "out of" N "\n--Goal: " (g 'goal) "\n--Goal id: " (g 'id)
         "\n--Assumptions:\n" (g 'assumptions) "\n--Eigenvariables: " (g 'eigenvariables) "\n--Witnesses: " (g 'witnesses))
   
define (show-stack) :=
 let {counter := (cell 1);
      N := (length (ref goal-stack))}
   (seq (print "\n[[[[[[[[[[[[[")
        (map-proc (lambda (r) (show-goal-record r (inc counter) N))
                  (ref goal-stack))
        (print "\n\n]]]]]]]]]]]]]\n"))

define (apply-tactic tactic-name) := 
  let {# Retrieve the tactic by name: 
       tactic := (tactic-dictionary tactic-name);
       # Apply the tactic to the goal-stack: 
        new-stack      := (tactic (ref goal-stack));
        _ := (set! goal-stack new-stack);
        _ := (print "\nTactic application successful, new goal stack:\n")}
    (show-stack)        
    
} # close module Tactics 

declare A, B, C, D, E: Boolean

open Tactics

EOF

load "lib/basic/tactics"

(set-goal (if (and A B) (and B A)))

(apply-tactic 'back-if)
(apply-tactic 'back-and)