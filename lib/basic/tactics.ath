module Tactics {

define (flip pol) :=
    match pol {
      'p  => 'n
    | 'n  => 'p
    | 'pn => 'pn}

  define (polarities p q) := 
    match q {
      (val-of p) => ['p]
    | (~ q1) => (map flip (polarities p q1))
    | (q1 ==> q2) => (join (map flip (polarities p q1))
                           (polarities p q2))
    | (q1 <==> q2) => (map lambda (_) 'pn
                           (join (polarities p q1) (polarities p q2)))
    | ((some-sent-con _) (some-list args)) =>
         (flatten (map lambda (q) (polarities p q) 
                       args))
    | _ => []
    }
    

define (sub-sentence-map p) :=
  letrec {loop := lambda (p M pos) 
                    match p {
                      ((some-sent-con _) (some-list args)) => (loop* args (Map.add M [[pos p]]) pos 1)
                    | _ => (Map.add M [[pos p]])
                    };
          loop* := lambda (props M pos i)
                     match props {
                       [] => M
                     | (list-of p more) => (loop* more (loop p M (join pos [i])) pos (plus i 1))
                     }}
   (loop p |{}| [])


define (extend-map M k v) := 
  let {res := try { (M k) | [] }}
    (Map.add M [[k (add v res)]])

# (sub-sentence-map p) returns a dictionary that maps every subsentence q of p
# to a list of pairs of the form [position polarity], where position is a Dewey path
# indicating the position of q in p (viewing p as a tree) and polarity indicates the polarity of q in p.
# A list of such pairs is returned because a single subsentence may have multiple occurrences in p. 

define (sub-sentence-map p) :=
  letrec {loop := lambda (p pos pol M) 
                    match p {
                      (~ q) => (loop q (join pos [1]) (flip pol) (extend-map M p [pos pol]))
                    | (and (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (or (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (if p1 p2) => (loop p2
                                          (join pos [2])
                                          pol 
                                          (loop p1
                                               (join pos [1])
                                               (flip pol)
                                               (extend-map M p [pos pol])))
                    | (iff p1 p2) => let {M1 := (loop p1 (join pos [1]) 'pn M);
                                          M2 := (loop p2 (join pos [2]) 'pn M1)}
                                      (extend-map M2 p [pos pol])
                    | _ => (extend-map M p [pos pol])
                    };
          loop* := lambda (props pos pol M i) 
                     match props {
                       [] => M
                     | (list-of p more) =>
                          (loop* more
                                 pos
                                 pol
                                 (loop p (join pos [i]) pol M)
                                 (plus i 1))
                     }}
   (loop p [] 'p |{}|)
   
define (polarities-and-positions p q) :=
    let {prepend-and-process := 
           lambda (i f)
             lambda (pos-pol-pair)
               match pos-pol-pair {
                 [pos pol] => [(add i pos) (f pol)]
               };
         id := lambda (x) x;
         make-pos-neg := lambda (_) 'pn}
      match q {
        (val-of p) => [[[] 'p]]
      | (~ q1) => (map (prepend-and-process 1 flip)
                       (polarities-and-positions p q1))
      | (q1 ==> q2) =>  (join (map (prepend-and-process 1 flip) 
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 id)
                                   (polarities-and-positions p q2)))
      | (q1 <==> q2) => (join (map (prepend-and-process 1 make-pos-neg)
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 make-pos-neg)
                                   (polarities-and-positions p q2)))
      | ((some-sent-con _) (some-list args)) =>
          let {i := (cell 1)}
            (flatten (map lambda (q)
                             (map (prepend-and-process (inc i) id)
                                  (polarities-and-positions p q))
                          args))
      | _ => []
      }

define (find-positive-goal-parent goal premise) :=
# Find a positive subsentence of the premise, call it p, that is a parent of the goal. Return a pair of p and the position of p in premise. 
# If no such subsentences exists, return ().
# If more than one such subsentence exists, return the first one (in a DFS ordering of all subsentences of the premise).
  let {subsentence-map := (sub-sentence-map premise);
       parent? := lambda (parent child)
                    (member? child (children parent));
       complex-non-negation := lambda (p)
                                 (|| (conjunction? p) (disjunction? p) (conditional? p) (biconditional? p));
       positive?       := lambda (position-polarity-pair)
                            (member? (second position-polarity-pair)
                                     ['p 'pn])}
    (find-element' (Map.keys subsentence-map)
                   lambda (ss-pos-pair)
                     let {[ss pos] := ss-pos-pair}
                       (&& (parent? ss goal)
                           (complex-non-negation ss)
                           (for-some (subsentence-map ss) positive?))
                   lambda (ss) [ss (first (first (subsentence-map ss)))]
                   lambda (ss-pair) ss-pair
                   lambda () ())                      
                    
# A record (or frame) on the goal stack has the following form:
# |{
#   'goal           := <a sentence>,
#   'id             := <a unique identifier>,
#   'path           := <a unique Dewey list>,
#   'assumptions    := <a list of assumptions>,
#   'eigenvariables := <a list of eigenvariables>,
#   'witnesses      := <a list of witness variables>,
#   'parent         := <uplink to the parent or to ()>,
#   'children       := <a cell of downinks to children or to ()>,
#   'tactic         := <a cell of a pair of the form [<tactic-name> <tactic-args>] used to obtain the children goals> 
# }|    


 define goal-stack := (cell [])

 define goal-id-counter := (cell 0)

 define root-goal := (cell ())

 define fresh-goal-id := lambda () (join "g" (val->string (inc goal-id-counter)))

 define (add-all p assumptions) :=
    (join assumptions (dedup (add p (get-conjuncts-recursive p))))
 
 define clear-state :=
   lambda ()
      (seq (set! root-goal (cell ()))
           (set! goal-id-counter 0))
           
# Apply a given tactic to the top goal:

define (add-child goal child) := 
  let {goal-children-cell := (goal 'children);
       goal-children      := (ref goal-children-cell)}
    (set! goal-children-cell (join goal-children [child]))

define (extend-path goal index) := (join (goal 'path) [index])

define (make-new-goal starting-goal bindings) := 
  (Map.add starting-goal bindings)
  
define (make-child goal new-child-bindings) :=
  let {child :=   (Map.add goal (join [['parent goal]
                                       ['path (extend-path goal 1)]
                                       ['id (fresh-goal-id)]
                                       ['children (cell [])]
                                       ['tactic (cell [])]]
                                       new-child-bindings));
       _ := (add-child goal child)}
    child 

define (make-subgoals goal subgoals) := 
  let {make-subgoal := lambda (p index) (make-child goal [['goal p] ['path (extend-path goal index)]]);
       counter := (cell 1)}
    (map lambda (p) (make-subgoal p (inc counter))
         subgoals)
  
define (backward-tactic goal-stack tactic-name) :=
# This essentially ignores tactic-name for all cases except disjunctions. What if a tactic like 'back-and is applied to a conditional? 
   match goal-stack {
     (list-of goal-record rest) =>
       let {_ := (set! (goal-record 'tactic) [tactic-name []])}
         match (goal-record 'goal) {
           (and (some-list conjuncts)) => 
             let {make-new-goal-record := lambda (conjunct) (make-child goal-record [['goal conjunct]]);              
                  new-goal-records := (make-subgoals goal-record conjuncts);
                         new-stack := (join new-goal-records rest)}
               new-stack
         | (if (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal q] ['assumptions  (add-all p (goal-record 'assumptions))]])}
               (add goal-record' rest)
         | (iff (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal (and (if p q) (if q p))]])}
               (add goal-record' rest)
         | (or (some-sentence p) (some-sentence q)) =>
             let {[new-goal new-assumption] := check {(tactic-name equals? 'back-lor) => [p (not q)] | else => [q (not p)]};
                  goal-record'   := (make-child goal-record [['goal new-goal] ['assumptions  (add-all new-assumption (goal-record 'assumptions))]])}
               (add goal-record' rest)                                    
         | _ => goal-stack
         }
   | _ => (error "Error: Attempt to apply the backward tactic to an empty goal stack.")         
   }
  
define (show-goal-record g i N) :=
  (print "\n\n****************************** Stack record" i "out of" N "\n--Goal: " (g 'goal)
         "\n--Goal id: " (g 'id) "\n--Path: " (g 'path)
         "\n--Assumptions:\n" (g 'assumptions) "\n--Eigenvariables: " (g 'eigenvariables) "\n--Witnesses: " (g 'witnesses))
   
define (show-stack) :=
 let {counter := (cell 1);
      N := (length (ref goal-stack))}
   (seq (print "\n[[[[[[[[[[[[[")
        (map-proc (lambda (r) (show-goal-record r (inc counter) N))
                  (ref goal-stack))
        (print "\n\n]]]]]]]]]]]]]\n"))

define set-goal :=
  lambda (goal-sentence)
    check {(holds? goal-sentence) => (print "\nThis sentence already holds.")
         | else => let {_         := (clear-state);
                        goal-node := |{'id             := (fresh-goal-id),
                                       'path           := [],
                                       'goal           := goal-sentence,
                                       'assumptions    := [],
                                       'eigenvariables := [],
                                       'witnesses      := [],
                                       'parent         := (),
                                       'tactic         := (cell ()),
                                       'children       := (cell [])}|;
                        _ := (set! root-goal goal-node);
                        _ := (set! goal-stack [goal-node]);
                        _ := (print "\nCreated a new goal stack:\n")}
                     (show-stack)
          }                     

define (proper-extraction-tactic goal premise parent parent-position-in-premise) :=
# This will produce a dictionary of the form
# |{
#   'tactic-info := [<extraction-tactic-name> args],
#   'subgoals := <list of subgoals>
# }|
#
# where <extraction-tactic-name> is a meta-identifier representing a proper (fully specified) extraction 
# tactic name, and args is the list of all those values that are necessary for the tactic to work.
  let {aux-info := |{'premise := premise, 'goal-parent := parent, 'parent-position-in-premise := parent-position-in-premise}|}
    match parent {
      
      ((and (some-list props)) where (member? goal props)) => |{'tactic-info := ['and-> aux-info], 'subgoals := [parent]}|
      
    | ((or (some-list props)) where (member? goal props))  => |{'tactic-info := ['or-> aux-info],
                                                                'subgoals := (add parent
                                                                                  (map-select-2 lambda (disjunct)
                                                                                                  (if disjunct goal)
                                                                                                props
                                                                                                lambda (disjunct)
                                                                                                (unequal? disjunct goal)))}|
                                                                                             
    | (if antecedent (val-of goal))                        => |{'tactic-info := ['if-> aux-info], 'subgoals := [parent antecedent]}|
    
    | (iff left (val-of goal))                             => |{'tactic-info := ['iff-left->  aux-info], 'subgoals := [parent left]}|
    
    | (iff (val-of goal) right)                            => |{'tactic-info := ['iff-right-> aux-info], 'subgoals := [parent right]}|
    
    }

define extraction-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the extraction tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
         # We need to extract goal from premise, but first we must verify that the goal is positively embedded in the premise: 
            [goal [premise]] => check {(negate (|| (member? premise (goal-record 'assumptions))
                                                   (holds? premise))) => (error "Invalid application of the extraction tactic: the given premise does not hold:\n" premise)
                                     | else => match (find-positive-goal-parent goal premise) {
                                                 () => (error "Invalid application of the extraction tactic: the given premise does not have any positive occurrences of a goal parent")
                                               | [(some-sentence parent) position] =>
                                                        let {                     D := (proper-extraction-tactic goal premise parent position);
                                                             [tactic-info subgoals] := [(D 'tactic-info) (D 'subgoals)];
                                                                                  _ := (set! (goal-record 'tactic) tactic-info);
                                                                            counter := (cell 1);                                                                                  
                                                                  new-goal-records' := (map lambda (subgoal) (make-child goal-record [['goal subgoal] ['path (extend-path goal-record (inc counter))]])
                                                                                            subgoals)
                                                            }
                                                          (join new-goal-records' rest)
                                               }}
         }
     }

define tactic-dictionary :=
  |{
    'back-lor := lambda (goal-stack _) (backward-tactic goal-stack 'lor),
    'back-ror := lambda (goal-stack _) (backward-tactic goal-stack 'back-ror),
    'back-if  := lambda (goal-stack _) (backward-tactic goal-stack 'back-if),
    'back-iff := lambda (goal-stack _) (backward-tactic goal-stack 'back-iff),
    'back-and := lambda (goal-stack _) (backward-tactic goal-stack 'back-and),
    'extract  := extraction-tactic,
    'back     := lambda (goal-stack _)
                   match goal-stack {
                     (list-of goal-record _) =>
                        match (goal-record 'goal) {
                          (and (some-list _)) => (backward-tactic goal-stack 'back-and)
                        | (or (some-list _)) => (backward-tactic goal-stack 'lor)
                        | (if _ _) => (backward-tactic goal-stack 'back-if)
                        | (iff _ _) => (backward-tactic goal-stack 'back-iff)
                        | _ => goal-stack
                        }
                   | _ => goal-stack                        
                   },
    'claim := lambda (goal-stack _)  
                match goal-stack {
                  (list-of goal-record rest) =>
                    let {goal := (goal-record 'goal);
                         cond1 := (holds? goal);
                         cond2 := (member? goal (goal-record 'assumptions));
                            _ := (print "\nWe'll try to claim this goal:" goal ". Does it hold?: " cond1 ". Is it in the assumptions?: " cond2)
                        }
                      check {(|| cond1 cond2) =>
                          let {_ := (set! (goal-record 'tactic) ['claim []])}
                            rest
                           | else => let {_ := (print "\nNO DICE...\n")} (error "Incorrect application of 'claim tactic--the top goal does not hold.")}
                | _ => goal-stack
              }
  }|


define (spaces n) :=
  check {(n less? 1) => ""
       | else => (join " " (spaces (n minus 1)))}

define (stringify v) :=
  letrec {loop := lambda (chars so-far)
                    match chars {
                      [] => (rev so-far)
                    | (list-of c more) => check {(c equals? `\n) => (loop more so-far)
                                               | (&& (c equals? `\032) (negate (null? so-far)) (equals? (first so-far) `\032)) => (loop more so-far)
                                               | else => (loop more (add c so-far))}
                    }}
    (loop (val->string v) [])                   
   
     
define (tac->string tac) :=
  match tac {
    [tactic-name tactic-info] =>
      check {(tactic-name equals? 'claim) => "'claim ** LEAF **"
           | else => (stringify tac)}
  | _ => (stringify tac)
  }

define (show-tree current-goal-id) :=
  let {start := (ref root-goal)}
    letrec {display-goal-record  := lambda (goal-record level)
                                      let {goal := (goal-record 'goal);
                                           goal-id := (goal-record 'id);
                                           is-current := (equals? goal-id current-goal-id);
                                           goal-line := check {(equals? goal-id current-goal-id) => (join "---> Goal: " (stringify goal))
                                                             | else => (join "Goal: " (stringify goal))};
                                           _ := (print "\n" (spaces level) (stringify (goal-record 'path))
                                                       goal-line 
                                                       "Assumptions:" (stringify (goal-record 'assumptions))
                                                       "Tactic:" (tac->string (ref (goal-record 'tactic))))}
                                       (display-goal-records (ref (goal-record 'children)) (plus level 2));
            display-goal-records := lambda (goal-records level)
                                      match goal-records {
                                        [] => ()
                                      | (list-of goal-record more) => let {_ := (display-goal-record goal-record level)}
                                                                        (display-goal-records more level)
                                      }}
       (display-goal-record start 0)                                      
  
define done? := lambda () (null? (ref goal-stack))

define (apply-tactic tactic-name args) :=
  let {# Retrieve the tactic by name: 
       tactic := (tactic-dictionary tactic-name);
       _ := (print "\nGot the tactic, and here's the args: " args);
       # Apply the tactic to the goal-stack: 
       new-stack      := (try (tactic (ref goal-stack) args) 'error)}
    match new-stack {
      'error => 'error
    | _ => let {_ := (set! goal-stack new-stack);
                _ := (print "\nApplied tactic" (val->string tactic-name) "successfully.\n");
                current-goal-id := check {(null? new-stack) => ()
                                        | else => ((first new-stack) 'id)};
                _ := check {(done?) => (print "\nGoal completely proven!")
                          | else => (seq (print "\nHere's the new goal stack:\n") 
                                         (show-stack)
                                         (print "\nWill now try to apply the claim tactic...\n")
                                         (apply-tactic 'claim [])
                                         (print "\nAnd the new search tree:\n")
                                         (show-tree current-goal-id))
                           }
               }
             'success                                         
    }

define (apply-tactic* tactic-name args) :=
## As long as it can be successfully applied and we are not completely done, keep applying the given tactic. 
  match (apply-tactic tactic-name args) {
    'success => check {(done?) => ()
                     | else => (apply-tactic* tactic-name args)}
  | _ => ()                     
  }                                         



} # close module Tactics 

declare A, B, C, D, E: Boolean

open Tactics

EOF

load "lib/basic/tactics"

(set-goal (if (and A B) (and B A)))

define p := (and (not A) (not not A) (iff (A & B) (B & A)) (not not A));;

(find-positive-goal-parent A p)

(apply-tactic 'back [])

(apply-tactic* 'back [])

(apply-tactic 'back-and [])


define [p1 p2] := [(A ==> B & C) (A & E)]
assert [p1 p2]
(set-goal C)
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p2])