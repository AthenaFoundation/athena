module Tactics {

# A record (or frame) on the goal stack has the following form:
# |{
#   'goal           := <a sentence>,
#   'id             := <a unique identifier>,
#   'assumptions    := <a list of assumptions>,
#   'eigenvariables := <a list of eigenvariables>,
#   'witnesses      := <a list of eigenvariables>,
#   'parent         := <uplink to the parent or to ()>
#   'children       := <downinks to children or to ()> 
# }|    


 define goal-stack := (cell [])

 define goal-id-counter := (cell 0)

 define ht := (HashTable.table 500)

 define root-id := (cell "g1")

 define fresh-goal-id := lambda () (join "g" (val->string (inc goal-id-counter)))

 define clear-state :=
   lambda ()
      (seq (HashTable.clear ht)
           (set! goal-id-counter 0))
           
define set-goal :=
  lambda (goal-sentence)
    let {_    := (clear-state);
         root := (fresh-goal-id);
         _    := (set! root-id root)}
     (set! goal-stack [|{'id             := root,
                         'goal           := goal-sentence,
                         'assumptions    := [],
                         'eigenvariables := [],
                         'witnesses      := [],
                         'parent         := (cell ()),
                         'children       := (cell [])}|])

define (set-parent g1 g2) :=
# Make g1 the parent of g2 and g2 a child of g1:
  let {_ := (set! (g1 'children)
                  (join (ref (g1 'children)) [g2]))}
    (seq (set! (g2 'parent) g1))
       
define (set-parent* g1 goal-records) :=
  (map-proc (lambda (g) (set-parent g1 g)) goal-records)

# Apply a given tactic to the topmost goal:

define (make-new goal-record new-bindings) :=
  (Map.add goal-record (join [['parent (cell ())] ['id (fresh-goal-id)] ['children (cell [])]] new-bindings))

define (backward-tactic goal-stack tactic-name) :=
   match goal-stack {
     (list-of goal-record rest) =>
         match (goal-record 'goal) {
           (and (some-list conjuncts)) => 
             let {make-new-goal-record := lambda (conjunct) (make-new goal-record [['goal conjunct]]);
                  new-goal-records := (map make-new-goal-record conjuncts);
                  _                := (set-parent* goal-record new-goal-records);
                         new-stack := (join new-goal-records rest);
                         _         := (print "\nNEW STACK: " new-stack)}
               new-stack
         | (if (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-new goal-record [['goal q] ['assumptions  (add p (goal-record 'assumptions))]]);
                  _            := (set-parent goal-record goal-record')}
               (add goal-record' rest)
         | (iff (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-new goal-record [['goal (and (if p q) (if q p))]]);
                  _            := (set-parent goal-record goal-record')}
               (add goal-record' rest)
         | (or (some-sentence p) (some-sentence q)) =>
             let {[new-goal new-assumption] := check {(tactic-name equals? 'back-lor) => [p q] | else => [q p]};
                  goal-record'   := (make-new goal-record [['goal new-goal] ['assumptions  (add new-assumption (goal-record 'assumptions))]]);
                  _            := (set-parent goal-record goal-record')}
               (add goal-record' rest)                                    
         | _ => goal-stack
         }
   | _ => (error "Error: Attempt to apply the backward tactic to an empty goal stack.")         
   }

 
define tactic-dictionary :=
  |{
    'back-lor := lambda (goal-stack) (backward-tactic goal-stack 'lor),
    'back-ror := lambda (goal-stack) (backward-tactic goal-stack 'back-ror),
    'back-if  := lambda (goal-stack) (backward-tactic goal-stack 'back-if),
    'back-iff := lambda (goal-stack) (backward-tactic goal-stack 'back-iff),
    'back-and := lambda (goal-stack) (backward-tactic goal-stack 'back-end),                
  }|
  
define (apply-tactic tactic-name) := 
  let {# Retrieve the tactic by name: 
       tactic := (tactic-dictionary tactic-name);
       # Apply the tactic to the goal-stack: 
        new-stack      := (tactic (ref goal-stack))}
    (set! goal-stack new-stack)

define (show-goal-record g i N) :=
  (print "\n*** Stack record #" i " out of " N ":\n--Goal: " (g 'goal) "\n--Goal id: " (g 'id)
         "\n--Assumptions:\n" (g 'assumptions) "\n--Eigenvariables: " (g 'eigenvariables) "\n--Witnesses: " (g 'witnesses))
   
define (show-stack) :=
 let {counter := (cell 0);
      N := (length (ref goal-stack))}
   (seq (print "\n[[[[[[[[[[[[[\n")
        (map-proc (lambda (r) (show-goal-record r (inc counter) N))
                  (ref goal-stack))
        (print "\n]]]]]]]]]]]]]"))
    
} # close module Tactics 

EOF
load "lib/basic/tactics"