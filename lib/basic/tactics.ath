module Tactics {

define (flip pol) :=
    match pol {
      'p  => 'n
    | 'n  => 'p
    | 'pn => 'pn}

  define (polarities p q) := 
    match q {
      (val-of p) => ['p]
    | (~ q1) => (map flip (polarities p q1))
    | (q1 ==> q2) => (join (map flip (polarities p q1))
                           (polarities p q2))
    | (q1 <==> q2) => (map lambda (_) 'pn
                           (join (polarities p q1) (polarities p q2)))
    | ((some-sent-con _) (some-list args)) =>
         (flatten (map lambda (q) (polarities p q) 
                       args))
    | _ => []
    }
    
define (silence-on) := (process-input-from-string "(set-flag silent-mode \"on\")")
define (silence-off) := (process-input-from-string "(set-flag silent-mode \"off\")")

define (merror str) := let {_ := (print str)}
                         (error str)
define marker := "**"

define (sub-sentence-map p) :=
  letrec {loop := lambda (p M pos) 
                    match p {
                      ((some-sent-con _) (some-list args)) => (loop* args (Map.add M [[pos p]]) pos 1)
                    | _ => (Map.add M [[pos p]])
                    };
          loop* := lambda (props M pos i)
                     match props {
                       [] => M
                     | (list-of p more) => (loop* more (loop p M (join pos [i])) pos (plus i 1))
                     }}
   (loop p |{}| [])


define (extend-map M k v) := 
  let {res := try { (M k) | [] }}
    (Map.add M [[k (add v res)]])

# (sub-sentence-map p) returns a dictionary that maps every subsentence q of p
# to a list of pairs of the form [position polarity], where position is a Dewey path
# indicating the position of q in p (viewing p as a tree) and polarity indicates the polarity of q in p.
# A list of such pairs is returned because a single subsentence may have multiple occurrences in p. 

define (sub-sentence-map p) :=
  letrec {loop := lambda (p pos pol M) 
                    match p {
                      (~ q) => (loop q (join pos [1]) (flip pol) (extend-map M p [pos pol]))
                    | (and (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (or (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (if p1 p2) => (loop p2
                                          (join pos [2])
                                          pol 
                                          (loop p1
                                               (join pos [1])
                                               (flip pol)
                                               (extend-map M p [pos pol])))
                    | (iff p1 p2) => let {M1 := (loop p1 (join pos [1]) 'pn M);
                                          M2 := (loop p2 (join pos [2]) 'pn M1)}
                                      (extend-map M2 p [pos pol])
                    | _ => (extend-map M p [pos pol])
                    };
          loop* := lambda (props pos pol M i) 
                     match props {
                       [] => M
                     | (list-of p more) =>
                          (loop* more
                                 pos
                                 pol
                                 (loop p (join pos [i]) pol M)
                                 (plus i 1))
                     }}
   (loop p [] 'p |{}|)
   
define (polarities-and-positions p q) :=
    let {prepend-and-process := 
           lambda (i f)
             lambda (pos-pol-pair)
               match pos-pol-pair {
                 [pos pol] => [(add i pos) (f pol)]
               };
         id := lambda (x) x;
         make-pos-neg := lambda (_) 'pn}
      match q {
        (val-of p) => [[[] 'p]]
      | (~ q1) => (map (prepend-and-process 1 flip)
                       (polarities-and-positions p q1))
      | (q1 ==> q2) =>  (join (map (prepend-and-process 1 flip) 
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 id)
                                   (polarities-and-positions p q2)))
      | (q1 <==> q2) => (join (map (prepend-and-process 1 make-pos-neg)
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 make-pos-neg)
                                   (polarities-and-positions p q2)))
      | ((some-sent-con _) (some-list args)) =>
          let {i := (cell 1)}
            (flatten (map lambda (q)
                             (map (prepend-and-process (inc i) id)
                                  (polarities-and-positions p q))
                          args))
      | _ => []
      }

define (find-positive-parent goal premise) :=
# Find a positive subsentence of the premise, call it p, that is a parent of the given goal.
# Return a pair of p and the position of p in premise. 
# If no such subsentence exists, return ().
# If more than one such subsentence exists, return the first one (in a DFS ordering of all subsentences of the premise).

  let {subsentence-map := (sub-sentence-map premise);
       parent? := lambda (parent child)
                    (member? child (children parent));
       complex-non-negation := lambda (p)
                                 (|| (conjunction? p) (disjunction? p) (conditional? p) (biconditional? p));
       positive?       := lambda (position-polarity-pair)
                            (member? (second position-polarity-pair)
                                     ['p 'pn])}
    (find-element' (Map.keys subsentence-map)
                   lambda (ss-pos-pair)
                     let {[ss pos] := ss-pos-pair}
                       (&& (parent? ss goal)
                           (complex-non-negation ss)
                           (for-some (subsentence-map ss) positive?))
                   lambda (ss) [ss (first (first (subsentence-map ss)))]
                   lambda (ss-pair) ss-pair
                   lambda () ())                      


define (positive-in-ab? p props) :=
  let {F := lambda () false;
       S := lambda (_) true}
   (find-element props 
                 lambda (q)
                    let {M := (sub-sentence-map q)}
                      try {let {_ := (M p)} true | false }
                 S
                 F)

# A record (or frame) on the goal stack has the following form:
# |{
#   'goal           := <a sentence>,
#   'id             := <a unique identifier>,
#   'path           := <a unique Dewey list>,
#   'assumptions    := <a list of assumptions>,
#   'eigenvariables := <a list of eigenvariables>,
#   'witnesses      := <a list of witness variables>,
#   'parent         := <uplink to the parent or to ()>,
#   'children       := <a cell of downinks to children or to ()>,
#   'tactic         := <a cell of a pair of the form [<tactic-name> <tactic-args>] used to obtain the children goals>
#   'proof          := <a cell containing a list of strings, which, when joined, represents a partial proof>h
# }|    


 define goal-stack := (cell [])

 define goal-id-counter := (cell 0)

 define root-goal := (cell ())

 define fresh-goal-id := lambda () (join "g" (val->string (inc goal-id-counter)))

 define (add-all p assumptions) :=
    (join assumptions (dedup (add p (get-conjuncts-recursive p))))
 
 define clear-state :=
   lambda ()
      (seq (set! root-goal (cell ()))
           (set! goal-id-counter 0))
           
# Apply a given tactic to the top goal:

define (add-child goal-record child) := 
  let {goal-children-cell := (goal-record 'children);
       goal-children      := (ref goal-children-cell)}
    (set! goal-children-cell (join goal-children [child]))

define (extend-path goal index) := (join (goal 'path) [index])

define (make-new-goal starting-goal bindings) := 
  (Map.add starting-goal bindings)
  
define (make-child goal-record new-child-bindings) :=
  let {child :=   (Map.add goal-record (join [['parent goal-record]
                                              ['path (extend-path goal-record 1)]
                                              ['id (fresh-goal-id)]
                                              ['children (cell [])]
                                              ['proof (cell "")]
                                              ['tactic (cell [])]]
                                              new-child-bindings));
       _ := (add-child goal-record child)}
    child 


define (leaf? goal-record) := (&& (null? (ref (goal-record 'children))) (unequal? (ref (goal-record 'tactic)) []))

define (make-subgoals goal subgoals) := 
  let {make-subgoal := lambda (p index) (make-child goal [['goal p] ['path (extend-path goal index)]]);
       counter := (cell 1)}
    (map lambda (p) (make-subgoal p (inc counter))
         subgoals)
  
define (backward-tactic goal-stack tactic-name) :=
# This essentially ignores tactic-name for all cases except disjunctions. What if a tactic like 'back-and is applied to a conditional? 
   match goal-stack {
     (list-of goal-record rest) =>
       let {_ := (set! (goal-record 'tactic) [tactic-name []])}
         match (goal-record 'goal) {
           (and (some-list conjuncts)) => 
             let {make-new-goal-record := lambda (conjunct) (make-child goal-record [['goal conjunct]]);              
                  new-goal-records := (make-subgoals goal-record conjuncts);
                         new-stack := (join new-goal-records rest);
                         proof-chunks := check {(equal? (length new-goal-records) 2) => ["(!both " marker " " marker ")"]
                                              | else => (join ["(!conj-intro "] (separate (map (lambda (_) marker) conjuncts) " ") [")"])};
                         _ := (set! (goal-record 'proof) proof-chunks)}                                             
               new-stack
         | (if (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal q] ['assumptions  (add-all p (goal-record 'assumptions))]]);
                  proof-chunks := [(join "assume " (val->string p) "\n   ")
                                   marker];
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)
         | (iff (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal (and (if p q) (if q p))]]);
                  proof-chunks := ["let {biconditional := " marker "}\n  (!equiv (!left-and biconditional) (!right-and biconditional))"];
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)
         | (or (some-sentence p) (some-sentence q)) =>
             let {[new-goal new-assumption] := check {(tactic-name equals? 'back-lor) => [p (not q)] | else => [q (not p)]};
                  goal-record'   := (make-child goal-record [['goal new-goal] ['assumptions  (add-all new-assumption (goal-record 'assumptions))]]);
                  [p-str q-str] := [(val->string p) (val->string q)];
                  proof-chunks := check {(tactic-name equals? 'back-lor) =>
                                           ["(!two-cases \n  assume " q-str "\n    (!right-either " p-str " " q-str ")\n  "
                                            "\n  assume (~ " q-str ")\n let {_ := conclude " p-str "\n    "
                                            marker "}\n  (!left-either " p-str " " q-str "))"]
                                       | else =>
                                           ["(!two-cases \n  assume " p-str "\n    (!left-either " p-str " " q-str ")\n  "
                                            "\n  assume (~ " p-str ")\n let {_ := conclude " q-str "\n    "
                                            marker "}\n  (!right-either " p-str " " q-str "))"]};
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)                                    
         | _ => goal-stack
         }
   | _ => (error "Error: Attempt to apply the backward tactic to an empty goal stack.")         
   }
  
define (show-goal-record g i N) :=
  (print "\n\n****************************** Stack record" i "out of" N "\n--Goal: " (g 'goal)
         "\n--Goal id: " (g 'id) "\n--Path: " (g 'path)
         "\n--Assumptions:\n" (g 'assumptions) "\n--Eigenvariables: " (g 'eigenvariables) "\n--Witnesses: " (g 'witnesses))
   
define (show-stack) :=
 let {counter := (cell 1);
      N := (length (ref goal-stack))}
   (seq (print "\n[[[[[[[[[[[[[")
        (map-proc (lambda (r) (show-goal-record r (inc counter) N))
                  (ref goal-stack))
        (print "\n\n]]]]]]]]]]]]]\n"))

define set-goal :=
  lambda (goal-sentence)
    check {(holds? goal-sentence) => (print "\nThis sentence already holds.")
         | else => let {_         := (clear-state);
                        goal-node := |{'id             := (fresh-goal-id),
                                       'path           := [],
                                       'goal           := goal-sentence,
                                       'assumptions    := [],
                                       'eigenvariables := [],
                                       'witnesses      := [],
                                       'parent         := (),
                                       'tactic         := (cell []),
                                       'proof          := (cell ""),
                                       'children       := (cell [])}|;
                        _ := (set! root-goal goal-node);
                        _ := (set! goal-stack [goal-node]);
                        _ := (print "\nCreated a new goal stack:\n")}
                     (show-stack)
          }                     

define (proper-extraction-tactic goal premise parent parent-position-in-premise) :=
# This will produce a dictionary of the form
# |{
#   'tactic-info := [<extraction-tactic-name> args],
#   'subgoals := <list of subgoals>,
#   'proof := <list of proof chunks>
# }|
#
# where <extraction-tactic-name> is a meta-identifier representing a proper (fully specified) extraction 
# tactic name, and args is the list of all those values that are necessary for the tactic to work.
  let {aux-info := |{'premise := premise, 'goal-parent := parent, 'parent-position-in-premise := parent-position-in-premise}|}
    match parent {
      
      ((and (some-list props)) where (member? goal props)) => |{'tactic-info := ['and-> aux-info],
                                                                'subgoals := [parent],
                                                                'proof := check {(equal? (length props) 2) =>
                                                                                      check {(equal? goal (first props)) => ["let {_ := " marker "\n    }\n  (!left-and " (val->string parent) ")"]
                                                                                           | else => ["let {_ := " marker "\n    }\n  (!right-and " (val->string parent) ")"]
                                                                                      } 
                                                                               | else => ["let {_ := " marker "\n    }\n  (!conj-elim " (val->string goal) " " (val->string parent) ")"]
                                                                          }
                                                              }|
    | ((or (some-list props)) where (member? goal props))  => |{'tactic-info := ['or-> aux-info],
                                                                'proof := let {index := (cell 1);
                                                                               goal-str := (val->string goal);
                                                                               trivial-case := (join "assume h := " goal-str "\n  (!claim h)");
                                                                               case-chunks := (flatten
                                                                                                (map lambda (disjunct)
                                                                                                       check {(equal? disjunct goal) => ["\ncase-" (val->string (inc index)) " := " trivial-case ";\n"]
                                                                                                            | else => ["\ncase-" (val->string (inc index)) " := " marker ";\n"]}
                                                                                                     props));
                                                                               _ := (set! index 1)}
                                                                            (join ["let {disjunction := " (val->string parent)]
                                                                                  case-chunks
                                                                                  ["}\n  (!cases disjunction "
                                                                                  (separate (map lambda (_)
                                                                                                   (join "case-" (val->string (inc index)))
                                                                                                 props)
                                                                                             " ")
                                                                                  ")"]),
                                                                'subgoals := (add parent
                                                                                  (map-select-2 lambda (disjunct)
                                                                                                  (if disjunct goal)
                                                                                                props
                                                                                                lambda (disjunct)
                                                                                                  (unequal? disjunct goal)))}|
    | (if antecedent (val-of goal))                        => |{'tactic-info := ['if-> aux-info],
                                                                'proof := ["let {cond := " marker ";\n     ant := " marker "\n    }\n  (!mp cond ant)"],
                                                                'subgoals := [parent antecedent]}|
    
    | (iff left (val-of goal))                             => |{'tactic-info := ['iff-left->  aux-info],
                                                                'proof := ["let {bicond := " marker ";\n     left := " marker "\n    }\n  (!mp (!left-iff bicond) left)"],    
                                                                'subgoals := [parent left]}|
    
    | (iff (val-of goal) right)                            => |{'tactic-info := ['iff-right-> aux-info],
                                                                'proof := ["let {bicond := " marker ";\n     right := " marker "\n    }\n  (!mp (!right-iff bicond) right)"],    
                                                                'subgoals := [parent right]}|
    
    }

define extraction-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the extraction tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
         # We need to extract goal from premise, but first we must verify that the goal is positively embedded in the premise: 
            [goal [premise]] => check {(negate (|| (member? premise (goal-record 'assumptions))
                                                   (holds? premise))) => (error "Invalid application of the extraction tactic: the given premise does not hold:\n" premise)
                                     | else => match (find-positive-parent goal premise) {
                                                 () => (error "Invalid application of the extraction tactic: the given premise does not have any positive occurrences of a goal parent")
                                               | [(some-sentence parent) position] =>
                                                        let {                     D := (proper-extraction-tactic goal premise parent position);
                                                             [tactic-info subgoals] := [(D 'tactic-info) (D 'subgoals)];
                                                                                  _ := (set! (goal-record 'tactic) tactic-info);
                                                                                  _ := (set! (goal-record 'proof) (D 'proof));
                                                                            counter := (cell 1);                                                                                  
                                                                  new-goal-records' := (map lambda (subgoal) (make-child goal-record [['goal subgoal] ['path (extend-path goal-record (inc counter))]])
                                                                                            subgoals)
                                                            }
                                                          (join new-goal-records' rest)
                                               }}
         }
     }
     
define case-analysis-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the case-analysis tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
         # We need to extract goal from premise, but first we must verify that the goal is positively embedded in the premise:
         [goal [(disjunction as (or (some-list _)))]] =>
               let {disjuncts := (get-disjuncts disjunction)}
               check {(positive-in-ab? disjunction (join (ab) (goal-record 'assumptions))) =>
                       let {subgoals := (add disjunction (map lambda (disjunct) (if disjunct goal)
                                                              disjuncts));
                                   _ := (set! (goal-record 'tactic) ['case-analysis [disjunction]]);
                               index := (cell 1);
                                   _ := (set! (goal-record 'proof) (join ["let {disjunction := " marker "}\n  " "(!cases disjunction\n  "]                                                                          
                                                                         (map lambda (d) marker
                                                                              disjuncts)
                                                                         [")"]));
                             counter := (cell 1);
                             new-goal-records' := (map lambda (subgoal)
                                                         (make-child goal-record [['goal subgoal] ['path (extend-path goal-record (inc counter))]])
                                                       subgoals)}
                         (join new-goal-records' rest)
                    | else => (error "Invalid application of the case-analysis tactic: the given disjunction is not positively embedded in the current a.b.")
               }
         }
     }

define contradiction-tactic :=
  lambda (goal-stack _)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         let {goal := (goal-record 'goal);
              goal-complement := (complement goal);
              _ := (set! (goal-record 'tactic) ['contradiction []]);
              _ := (set! (goal-record 'proof) ["(!by-contradiction " (val->string goal) "\n  assume " (val->string goal-complement) "\n    " marker ")"]);
              new-goal-record := (make-child goal-record [['assumptions  (add-all goal-complement (goal-record 'assumptions))] ['goal false]])}
           (add new-goal-record rest)
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }           

define (holds-in p goal-record) :=
   (|| (holds? p) (member? p (goal-record 'assumptions)))

define (fails-in p goal-record) := (negate (holds-in p goal-record))

define (hold-in props goal-record) := (for-each props lambda (p) (holds-in p goal-record))
   
define from-complements-tactic := 
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the from-complements tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
           [goal [complement-1 complement-2]] =>
             check {(hold-in [complement-1 complement-2] goal-record) =>
                     let {_ := (mark `1);
                          _ := (set! (goal-record 'tactic) ['from-complements [complement-1 complement-2]]);
                          _ := (set! (goal-record 'proof) ["(!from-complements " (val->string goal) " " (val->string complement-1) " " (val->string complement-2) ")"]) 
                         }
                       rest
                   | else => (error "Incorrect application of 'from-complements, at least one of the given complements does not hold.")}
         | _ => (print "Invalid information given to the tactic from-complements: exactly two sentences are required, each a complement of the other.")
         }
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }

    
define (execute-thunk M assumptions) := 
  let {p := assume (and assumptions) (!M)}
    (consequent p)

define infer-tactic := 
  lambda (goal-stack args)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         match args {
           [M] =>
                  let {_ := (print "\nINSIDE INFER-TACTIC...");
                       lemma := (execute-thunk M (goal-record 'assumptions));
                       _ := (print "\nGOT THIS LEMMA: " lemma);
                       new-goal := (make-child goal-record [['assumptions  (add-all lemma (goal-record 'assumptions))]]);
                              _ := (set! (goal-record 'tactic) ['infer args]);
                              _ := (set! (goal-record 'proof) ["let {_ := " (unparse-body M) "}\n  " marker])
                      }
                    (add new-goal rest)
         | _ => (print "Invalid argument given to the infer tactic: A nullary method is expected.")
         }
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }

define (go-back-to goal-stack target-path) :=
  let {new-stack := (filter-out goal-stack
                                lambda (goal-record)
                                   (prefix? target-path (goal-record 'path)))}
    letrec {navigate-to := lambda (current-goal-record current-path)
                             match current-path {
                               [] => current-goal-record
                             | (list-of index more) => (navigate-to (nth index (current-goal-record 'children)) more)
                             }}
       try {let {target-goal := (navigate-to (ref root-goal) target-path);
                           _ := (set! (target-goal 'children) []);
                           _ := (set! (target-goal 'tactic) []);
                           _ := (set! (target-goal 'proof) "")}
              (add target-goal new-stack)
          | (error "Invalid path")}
         
define go-back-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         match args {
           ([path] where (for-each path numeral?)) => (go-back-to goal-stack path)
         | _ => (merror "Invalid tactic application - the 'go-back tactic expects an argument of the form [<path>]")
         }
     | _ => (merror "Invalid tactic application - there are no open goals currently.")
     }         
     
define tactic-dictionary :=
  |{
    'back-lor := lambda (goal-stack _) (backward-tactic goal-stack 'lor),
    'back-ror := lambda (goal-stack _) (backward-tactic goal-stack 'back-ror),
    'back-if  := lambda (goal-stack _) (backward-tactic goal-stack 'back-if),
    'back-iff := lambda (goal-stack _) (backward-tactic goal-stack 'back-iff),
    'back-and := lambda (goal-stack _) (backward-tactic goal-stack 'back-and),
    'extract  := extraction-tactic,
    'infer  := infer-tactic,
    'contradiction  := contradiction-tactic,
    'case-analysis  := case-analysis-tactic,
    'from-complements  := from-complements-tactic,    
    'back     := lambda (goal-stack _)
                   match goal-stack {
                     (list-of goal-record _) =>
                        match (goal-record 'goal) {
                          (and (some-list _)) => (backward-tactic goal-stack 'back-and)
                        | (or (some-list _)) => (backward-tactic goal-stack 'lor)
                        | (if _ _) => (backward-tactic goal-stack 'back-if)
                        | (iff _ _) => (backward-tactic goal-stack 'back-iff)
                        | _ => goal-stack
                        }
                   | _ => goal-stack                        
                   },
    'go-back := go-back-tactic,
    'claim := lambda (goal-stack _)  
                match goal-stack {
                  (list-of goal-record rest) =>
                    let {goal := (goal-record 'goal);
                         cond1 := (holds? goal);
                         cond2 := (member? goal (goal-record 'assumptions));
                            _ := (print "\nWe'll try to claim this goal:" goal ". Does it hold?: " cond1 ". Is it in the assumptions?: " cond2)
                        }
                      check {(|| cond1 cond2) =>
                          let {_ := (set! (goal-record 'proof) ["(!claim " (val->string goal) ")"]);
                               _ := (set! (goal-record 'tactic) ['claim []])}
                            rest
                           | else => let {_ := (print "\nNO DICE...\n")} (error "Incorrect application of 'claim tactic--the top goal does not hold.")}
                | _ => goal-stack
              }
  }|

define (spaces n) :=
  check {(n less? 1) => ""
       | else => (join " " (spaces (n minus 1)))}

define (stringify v) :=
  letrec {loop := lambda (chars so-far)
                    match chars {
                      [] => (rev so-far)
                    | (list-of c more) => check {(c equals? `\n) => (loop more so-far)
                                               | (&& (c equals? `\032) (negate (null? so-far)) (equals? (first so-far) `\032)) => (loop more so-far)
                                               | else => (loop more (add c so-far))}
                    }}
    (loop (val->string v) [])                   
   
     
define (tac->string tac) :=
  match tac {
    [tactic-name tactic-info] =>
      check {(tactic-name equals? 'claim) => "'claim " 
           | else => (stringify tac)}
  | _ => (stringify tac)
  }

define (show-tree) :=
  let {start := (ref root-goal);
       current-stack := (ref goal-stack);
       current-goal-id := check {(null? current-stack) => ()
                               | else => ((first current-stack) 'id)}}
    letrec {display-goal-record  := lambda (goal-record level)
                                      let {goal := (goal-record 'goal);
                                           goal-id := (goal-record 'id);
                                           leaf-suffix := check {(leaf? goal-record) => " ** LEAF **"
                                                               | else => ""};
                                           is-current := (equals? goal-id current-goal-id);
                                           goal-line := check {(equals? goal-id current-goal-id) => (join "---> Goal: " (stringify goal))
                                                             | else => (join "Goal: " (stringify goal))};
                                           _ := (print "\n" (spaces level) (stringify (goal-record 'path))
                                                       goal-line 
                                                       "Assumptions:" (stringify (goal-record 'assumptions))
                                                       "Tactic:" (join (tac->string (ref (goal-record 'tactic))) leaf-suffix))}
                                       (display-goal-records (ref (goal-record 'children)) (plus level 2));
            display-goal-records := lambda (goal-records level)
                                      match goal-records {
                                        [] => ()
                                      | (list-of goal-record more) => let {_ := (display-goal-record goal-record level)}
                                                                        (display-goal-records more level)
                                      }}
       (display-goal-record start 0)                                      
  
define done? := lambda () (null? (ref goal-stack))

define (apply-tactic tactic-name args) :=
  let {# Retrieve the tactic by name: 
       tactic := (tactic-dictionary tactic-name);
       _ := (print "\nGot the tactic, and here's the args: " args);
       # Apply the tactic to the goal-stack: 
       new-stack      := (try (tactic (ref goal-stack) args) 'error)}
    match new-stack {
      'error => 'error
    | _ => let {_ := (set! goal-stack new-stack);
                _ := (print "\nApplied tactic" (val->string tactic-name) "successfully.\n");
                _ := check {(done?) => (print "\nGoal completely proven!")
                          | else => (seq (print "\nHere's the new goal stack:\n") 
                                         (show-stack)
                                         (print "\nWill now try to apply the claim tactic...\n")
                                         (apply-tactic 'claim [])
                                         (print "\nAnd the new search tree:\n")
                                         (show-tree))
                           }
               }
             'success                                         
    }

define (apply-tactic* tactic-name args) :=
## As long as it can be successfully applied and we are not completely done, keep applying the given tactic. 
  match (apply-tactic tactic-name args) {
    'success => check {(done?) => ()
                     | else => (apply-tactic* tactic-name args)}
  | _ => ()                     
  }                                         



define (show-proof) :=
  letrec {join-proof-chunks := lambda (proof-chunks children-proofs res) 
                                 match proof-chunks {
                                   [] => (flatten (join (rev res)))
                                 | (list-of chunk more) => check {(&& (equal? chunk marker) (negate (null? children-proofs))) =>
                                                                    (join-proof-chunks more
                                                                                      (tail children-proofs)
                                                                                      (add (first children-proofs) res))
                                                                | else => (join-proof-chunks more children-proofs (add chunk res))}
                                 };
          compose-proof := lambda (goal-record)
                             check {(leaf? goal-record) => (flatten (join (ref (goal-record 'proof))))
                                  | else => let {children-proofs := (map compose-proof (ref (goal-record 'children)));
                                                 proof-chunks := (ref (goal-record 'proof))}
                                              (join-proof-chunks proof-chunks children-proofs [])}}
    (compose-proof (ref root-goal))

} # close module Tactics 

declare A, B, C, D, E: Boolean

open Tactics

EOF

load "lib/basic/tactics"

assert d := (A | B | C)
assert con := (and (if A D) (if B D) (if C D))
(set-goal D)

(apply-tactic 'case-analysis [d])

assert p1 := (A ==> B & C)
assert p2 := (~ B)
(set-goal (not A))
(apply-tactic 'contradiction [])
(apply-tactic 'infer [method () (!mp p1 A)])
(apply-tactic 'go-back [[]])

(apply-tactic 'from-complements [B p2])



(!by-contradiction (not A)
  let {_ := (!mp p1 A)}
  (!from-complements false B (not B)))

  

(set-goal (if (and A B) (and B A)))

define p := (and (not A) (not not A) (iff (A & B) (B & A)) (not not A));;

(find-positive-parent A p)

(apply-tactic 'back [])

(apply-tactic* 'back [])

(apply-tactic 'back-and [])


define [p1 p2] := [(A ==> B & C) (A & E)]
assert [p1 p2]
(set-goal C)
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p2])



let {_ := let {cond := (!claim (if A (and B C)));
               ant := let {_ := (!claim (and A E))}
                       (!left-and (and A E))}
    }
  (!mp cond ant)
    }
  (!right-and (and B C))



  let {_ := let {cond := (!claim (if A (and B C)));
                  ant := let {_ := (!claim (and A E))}
                          (!left-and (and A E))}
             (!mp cond ant)}
    (!right-and (and B C))
