# load "/mnt/c/papers/dpls/dbook/proofs/pol"

load "polarities"

module Tactics {

  define (silence-on) := (process-input-from-string "(set-flag silent-mode \"on\")")
  define (silence-off) := (process-input-from-string "(set-flag silent-mode \"off\")")

  define error' := error 
  define (error str) := let {_ := (print (join "\n" str "\n"))}
                         (error' str)
  define marker := "**"

  # A record (or frame) on the goal stack has the following form:
  # |{
  #   'goal           := <a sentence>,
  #   'id             := <a unique identifier>,
  #   'path           := <a unique Dewey list>,
  #   'assumptions    := <a list of assumptions>,
  #   'eigenvariables := <a list of eigenvariables>,
  #   'witnesses      := <a list of witness variables>,
  #   'parent         := <uplink to the parent or to ()>,
  #   'children       := <a cell of downinks to children or to ()>,
  #   'tactic         := <a cell of a pair of the form [<tactic-name> <tactic-args>] used to obtain the children goals>
  #   'proof          := <a cell containing a list of strings, which, when joined, represents a partial proof>h
  # }|    

 define goal-stack := (cell [])

 define goal-id-counter := (cell 0)

 define root-goal := (cell ())

 define fresh-goal-id := lambda () (join "g" (val->string (inc goal-id-counter)))

 define (add-all p assumptions) :=
    (join assumptions (dedup (add p (get-conjuncts-recursive p))))
 
 define clear-state :=
   lambda ()
      (seq (set! root-goal (cell ()))
           (set! goal-id-counter 0))
           
 # Apply a given tactic to the top goal:

define (add-child goal-record child) := 
  let {goal-children-cell := (goal-record 'children);
       goal-children      := (ref goal-children-cell)}
    (set! goal-children-cell (join goal-children [child]))

define (extend-path goal index) := (join (goal 'path) [index])

define (make-new-goal starting-goal bindings) := 
  (Map.add starting-goal bindings)
  
define (make-child goal-record new-child-bindings) :=
  let {child :=   (Map.add goal-record (join [['parent goal-record]
                                              ['path (extend-path goal-record 1)]
                                              ['id (fresh-goal-id)]
                                              ['children (cell [])]
                                              ['proof (cell "")]
                                              ['tactic (cell [])]]
                                              new-child-bindings));
       _ := (add-child goal-record child)}
    child 


define (leaf? goal-record) := (&& (null? (ref (goal-record 'children))) (unequal? (ref (goal-record 'tactic)) []))

define (make-subgoals goal subgoals) := 
  let {make-subgoal := lambda (p index) (make-child goal [['goal p] ['path (extend-path goal index)]]);
       counter := (cell 1)}
    (map lambda (p) (make-subgoal p (inc counter))
         subgoals)
  
define (backward-tactic goal-stack tactic-name) :=
# This essentially ignores tactic-name for all cases except disjunctions. What if a tactic like 'and<- is applied to a conditional? 
   match goal-stack {
     (list-of goal-record rest) =>
       let {_ := (set! (goal-record 'tactic) [tactic-name []])}
         match (goal-record 'goal) {
           (and (some-list conjuncts)) => 
             let {make-new-goal-record := lambda (conjunct) (make-child goal-record [['goal conjunct]]);              
                  new-goal-records := (make-subgoals goal-record conjuncts);
                         new-stack := (join new-goal-records rest);
                         proof-chunks := check {(equal? (length new-goal-records) 2) => ["(!both " marker " " marker ")"]
                                              | else => (join ["(!conj-intro "] (separate (map (lambda (_) marker) conjuncts) " ") [")"])};
                         _ := (set! (goal-record 'proof) proof-chunks)}                                             
               new-stack
         | (if (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal q] ['assumptions  (add-all p (goal-record 'assumptions))]]);
                  proof-chunks := [(join "assume " (val->string p) "\n   ")
                                   marker];
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)
         | (iff (some-sentence p) (some-sentence q)) =>
             let {goal-record' := (make-child goal-record [['goal (and (if p q) (if q p))]]);
                  proof-chunks := ["let {biconditional := " marker "}\n  (!equiv (!left-and biconditional) (!right-and biconditional))"];
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)
         | (or (some-sentence p) (some-sentence q)) =>
             let {[new-goal new-assumption] := check {(tactic-name equals? 'lor<-) => [p (not q)] | else => [q (not p)]};
                  goal-record'   := (make-child goal-record [['goal new-goal] ['assumptions  (add-all new-assumption (goal-record 'assumptions))]]);
                  _ := (print "\nHERE WE ARE...New goal:\n" new-goal);
                  [p-str q-str] := [(val->string p) (val->string q)];
                  proof-chunks := check {(tactic-name equals? 'lor<-) =>
                                           ["(!two-cases \n  assume " q-str "\n    (!right-either " p-str " " q-str ")\n  "
                                            "\n  assume (~ " q-str ")\n let {_ := conclude " p-str "\n    "
                                            marker "}\n  (!left-either " p-str " " q-str "))"]
                                       | else =>
                                           ["(!two-cases \n  assume " p-str "\n    (!left-either " p-str " " q-str ")\n  "
                                            "\n  assume (~ " p-str ")\n let {_ := conclude " q-str "\n    "
                                            marker "}\n  (!right-either " p-str " " q-str "))"]};
                  _ := (set! (goal-record 'proof) proof-chunks)}
               (add goal-record' rest)                                    
         | _ => goal-stack
         }
   | _ => (error "Error: Attempt to apply the backward tactic to an empty goal stack.")         
   }
  
define (show-goal-record g i N) :=
  (print "\n\n****************************** Stack record" i "out of" N "\n--Goal: " (g 'goal)
         "\n--Goal id: " (g 'id) "\n--Path: " (g 'path)
         "\n--Assumptions:\n" (g 'assumptions) "\n--Eigenvariables: " (g 'eigenvariables) "\n--Witnesses: " (g 'witnesses))
   
define (show-stack) :=
 let {counter := (cell 1);
      N := (length (ref goal-stack))}
   (seq (print "\n[[[[[[[[[[[[[")
        (map-proc (lambda (r) (show-goal-record r (inc counter) N))
                  (ref goal-stack))
        (print "\n\n]]]]]]]]]]]]]\n"))

define set-goal :=
  lambda (goal-sentence)
    check {(holds? goal-sentence) => (print "\nThis sentence already holds.")
         | else => let {_         := (clear-state);
                        goal-node := |{'id             := (fresh-goal-id),
                                       'path           := [],
                                       'goal           := goal-sentence,
                                       'assumptions    := [],
                                       'eigenvariables := [],
                                       'witnesses      := [],
                                       'parent         := (),
                                       'tactic         := (cell []),
                                       'proof          := (cell ""),
                                       'children       := (cell [])}|;
                        _ := (set! root-goal goal-node);
                        _ := (set! goal-stack [goal-node]);
                        _ := (print "\nCreated a new goal stack:\n")}
                     (show-stack)
          }                     

define (proper-extraction-tactic goal premise parent parent-position-in-premise theta) :=
# This will produce a dictionary of the form
# |{
#   'tactic-info := [<extraction-tactic-name> args],
#   'subgoals := <list of subgoals>,
#   'proof := <list of proof chunks>
# }|
#
# where <extraction-tactic-name> is a meta-identifier representing a proper (fully specified) extraction 
# tactic name, and args is the list of all those values that are necessary for the tactic to work.
  let {aux-info := |{'premise := premise, 'goal-parent := parent, 'parent-position-in-premise := parent-position-in-premise, 'theta := theta}|;
       _ := (print "\nHERE'S THETA: " theta);
       instantiated-parent := (theta parent)}
       
    match instantiated-parent {
      
      (and (some-list props)) =>
        let {instantiated-conjuncts := (get-conjuncts instantiated-parent);
             _ := (print "\nGoal: " goal "\nParent: " parent "\ninstantiated-parent: " instantiated-parent "\nconjuncts: " instantiated-conjuncts)}
          check {(subset? (get-conjuncts goal) instantiated-conjuncts) => 
                  |{'tactic-info := ['and-> aux-info],
                    'subgoals := [instantiated-parent],
                    'proof := check {(equal? (length instantiated-conjuncts) 2) =>
                                      check {(equal? goal (first instantiated-conjuncts)) =>
                                               ["let {_ := " marker "\n    }\n  (!left-and " (val->string instantiated-parent) ")"]
                                           | else => ["let {_ := " marker "\n    }\n  (!right-and " (val->string instantiated-parent) ")"]
                                      }
                            | else => ["let {_ := " marker "\n    }\n  (!conj-elim " (val->string goal) " " (val->string instantiated-parent) ")"]}
                  }|
               | else => (error "Invalid application of conjunctive extraction tactic.")}
                
    | (or (some-list _))  =>
        let {disjuncts := (get-disjuncts instantiated-parent)}
          check {(member? goal disjuncts) =>
                  |{'tactic-info := ['or-> aux-info],
                    'subgoals := (add instantiated-parent
                                      (map-select-2 lambda (disjunct)
                                                      (if disjunct goal)
                                                    disjuncts
                                                    lambda (disjunct)
                                                      (unequal? disjunct goal))),
                    'proof := let {index := (cell 1);
                                   goal-str := (val->string goal);
                                   trivial-case := (join "assume h := " goal-str "\n  (!claim h)");
                                   process-disjunct := lambda (disjunct tail-end)
                                                         check {(equal? disjunct goal) => ["\ncase-" (val->string (inc index)) " := " trivial-case tail-end]
                                                              | else => ["\ncase-" (val->string (inc index)) " := " marker tail-end]};
                                   case-chunks := (flatten
                                                    (join (map lambda (d) (process-disjunct d ";\n")
                                                              (all-but-last disjuncts))
                                                          [(process-disjunct (last disjuncts) "\n")]));
                                   _ := (set! index 1)}
                                (join ["let {disjunction := " marker ";\n"]
                                      case-chunks
                                      ["}\n  (!cases disjunction "
                                      (separate (map lambda (_)
                                                       (join "case-" (val->string (inc index)))
                                                     disjuncts)
                                                " ")
                                      ")"])}|
               | else => (error "Invalid application of disjunctive extraction tactic.")}
               
    | (if antecedent (val-of goal)) =>
        |{'tactic-info := ['if-> aux-info],
          'proof := ["let {cond := " marker ";\n     ant := " marker "\n    }\n  (!mp cond ant)"],
          'subgoals := [instantiated-parent antecedent]}|
    
    | (iff left (val-of goal)) =>
        |{'tactic-info := ['iff-left->  aux-info],
          'proof := ["let {bicond := " marker ";\n     left := " marker "\n    }\n  (!mp (!left-iff bicond) left)"],    
          'subgoals := [instantiated-parent left]}|
    
    | (iff (val-of goal) right) =>
        |{'tactic-info := ['iff-right-> aux-info],
           'proof := ["let {bicond := " marker ";\n     right := " marker "\n    }\n  (!mp (!right-iff bicond) right)"],    
           'subgoals := [instantiated-parent right]}|
           
    | (forall (some-var v) (some-sentence _)) => 
        |{'tactic-info := ['forall3-> aux-info],
           'subgoals := let {_ := (print "\nINSTANTIATED PARENT: " instantiated-parent "\nAND PARENT: " parent)}
                         [instantiated-parent],        
           'proof := let {theta' := (make-sub [[v (first (quant-vars parent))]])}
                      ["let {ugen := " marker "}\n  (!uspec ugen " (val->string ((compose-subs theta theta') v)) ")"]
        }|
    
    }

define extraction-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the extraction tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
         # We need to extract goal from premise, but first we must verify that the goal is positively embedded in the premise: 
            [goal [premise]] => check {(negate (|| (member? premise (goal-record 'assumptions))
                                                   (holds? premise))) => (error "Invalid application of the extraction tactic: the given premise does not hold:\n" premise)
                                     | else => match (Polarities.find-universally-positive-parent goal premise) {
                                                 () => (error "Invalid application of the extraction tactic: the given premise does not have any universally positive occurrences of a goal parent")
                                               | [(some-sentence parent) parent-position-in-premise theta] =>
                                                        let {                     D := (proper-extraction-tactic goal premise parent parent-position-in-premise theta);
                                                             [tactic-info subgoals] := [(D 'tactic-info) (D 'subgoals)];
                                                                                  _ := (set! (goal-record 'tactic) tactic-info);
                                                                                  _ := (set! (goal-record 'proof) (D 'proof));
                                                                            counter := (cell 1);                                                                                  
                                                                  new-goal-records' := (map lambda (subgoal) (make-child goal-record [['goal subgoal] ['path (extend-path goal-record (inc counter))]])
                                                                                            subgoals)
                                                            }
                                                          (join new-goal-records' rest)
                                               }}
         }
     }
     
define case-analysis-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the case-analysis tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
         # We need to extract goal from premise, but first we must verify that the goal is positively embedded in the premise:
         [goal [(disjunction as (or (some-list _)))]] =>
               let {disjuncts := (get-disjuncts disjunction)}
               check {(Polarities.positive-in-ab? disjunction (join (ab) (goal-record 'assumptions))) =>
                       let {subgoals := (add disjunction (map lambda (disjunct) (if disjunct goal)
                                                              disjuncts));
                                   _ := (set! (goal-record 'tactic) ['case-analysis [disjunction]]);
                               index := (cell 1);
                                   _ := (set! (goal-record 'proof) (join ["let {disjunction := " marker "}\n  " "(!cases disjunction\n  "]                                                                          
                                                                         (map lambda (d) marker
                                                                              disjuncts)
                                                                         [")"]));
                             counter := (cell 1);
                             new-goal-records' := (map lambda (subgoal)
                                                         (make-child goal-record [['goal subgoal] ['path (extend-path goal-record (inc counter))]])
                                                       subgoals)}
                         (join new-goal-records' rest)
                    | else => (error "Invalid application of the case-analysis tactic: the given disjunction is not positively embedded in the current a.b.")
               }
         }
     }

define contradiction-tactic :=
  lambda (goal-stack _)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         let {goal := (goal-record 'goal);
              goal-complement := (complement goal);
              _ := (set! (goal-record 'tactic) ['contradiction []]);
              _ := (set! (goal-record 'proof) ["(!by-contradiction " (val->string goal) "\n  assume " (val->string goal-complement) "\n    " marker ")"]);
              new-goal-record := (make-child goal-record [['assumptions  (add-all goal-complement (goal-record 'assumptions))] ['goal false]])}
           (add new-goal-record rest)
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }           

define (holds-in p goal-record) :=
   (|| (holds? p) (member? p (goal-record 'assumptions)))

define (fails-in p goal-record) := (negate (holds-in p goal-record))

define (hold-in props goal-record) := (for-each props lambda (p) (holds-in p goal-record))
   
define from-complements-tactic := 
  lambda (goal-stack args)
  # We must return a new goal stack. 
     let {_ := (print "\nInside the from-complements tactic, here's args: " args "\nand here is the goal stack: " goal-stack)}
     match goal-stack {
       (list-of goal-record rest) =>
         match [(goal-record 'goal) args] {
           [goal [complement-1 complement-2]] =>
             check {(hold-in [complement-1 complement-2] goal-record) =>
                     let {_ := (mark `1);
                          _ := (set! (goal-record 'tactic) ['from-complements [complement-1 complement-2]]);
                          _ := (set! (goal-record 'proof) ["(!from-complements " (val->string goal) " " (val->string complement-1) " " (val->string complement-2) ")"]) 
                         }
                       rest
                   | else => (error "Incorrect application of 'from-complements, at least one of the given complements does not hold.")}
         | _ => (print "Invalid information given to the tactic from-complements: exactly two sentences are required, each a complement of the other.")
         }
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }

    
define (execute-thunk M assumptions) := 
  let {p := assume (and assumptions) (!M)}
    (consequent p)

define infer-tactic := 
  lambda (goal-stack args)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         match args {
           [M] =>
                  let {_ := (print "\nINSIDE INFER-TACTIC...");
                       lemma := (execute-thunk M (goal-record 'assumptions));
                       _ := (print "\nGOT THIS LEMMA: " lemma);
                       new-goal := (make-child goal-record [['assumptions  (add-all lemma (goal-record 'assumptions))]]);
                              _ := (set! (goal-record 'tactic) ['infer args]);
                              _ := (set! (goal-record 'proof) ["let {_ := " (unparse-body M) "}\n  " marker])
                      }
                    (add new-goal rest)
         | _ => (print "Invalid argument given to the infer tactic: A nullary method is expected.")
         }
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }

define (go-back-to goal-stack target-path) :=
  let {new-stack := (filter-out goal-stack
                                lambda (goal-record)
                                   (prefix? target-path (goal-record 'path)))}
    letrec {navigate-to := lambda (current-goal-record current-path)
                             match current-path {
                               [] => current-goal-record
                             | (list-of index more) => (navigate-to (nth index (current-goal-record 'children)) more)
                             }}
       try {let {target-goal := (navigate-to (ref root-goal) target-path);
                           _ := (set! (target-goal 'children) []);
                           _ := (set! (target-goal 'tactic) []);
                           _ := (set! (target-goal 'proof) "")}
              (add target-goal new-stack)
          | (error "Invalid path")}
         
define go-back-tactic :=
  lambda (goal-stack args)
  # We must return a new goal stack. 
     match goal-stack {
       (list-of goal-record rest) =>
         match args {
           ([path] where (for-each path numeral?)) => (go-back-to goal-stack path)
         | _ => (error "Invalid tactic application - the 'go-back tactic expects an argument of the form [<path>]")
         }
     | _ => (error "Invalid tactic application - there are no open goals currently.")
     }         
     
define tactic-dictionary :=
  |{
    'lor<- := lambda (goal-stack _) (backward-tactic goal-stack 'lor<-),
    'ror<- := lambda (goal-stack _) (backward-tactic goal-stack 'ror<-),
    'if<-  := lambda (goal-stack _) (backward-tactic goal-stack 'if<-),
    'iff<- := lambda (goal-stack _) (backward-tactic goal-stack 'iff<-),
    'and<- := lambda (goal-stack _) (backward-tactic goal-stack 'and<-),
    'extract  := extraction-tactic,
    'infer  := infer-tactic,
    'contradiction  := contradiction-tactic,
    'case-analysis  := case-analysis-tactic,
    'from-complements  := from-complements-tactic,    
    'back     := lambda (goal-stack _)
                   match goal-stack {
                     (list-of goal-record _) =>
                        match (goal-record 'goal) {
                          (and (some-list _)) => (backward-tactic goal-stack 'and<-)
                        | (or (some-list _)) => (backward-tactic goal-stack 'lor<-)
                        | (if _ _) => (backward-tactic goal-stack 'if<-)
                        | (iff _ _) => (backward-tactic goal-stack 'iff<-)
                        | _ => (error "Invalid application of 'back - no backward tactic is applicable to the this goal")
                        }
                   | _ => goal-stack                        
                   },
    'go-back := go-back-tactic,
    'claim := lambda (goal-stack _)  
                match goal-stack {
                  (list-of goal-record rest) =>
                    let {goal := (goal-record 'goal);
                         cond1 := (holds? goal);
                         cond2 := (member? goal (goal-record 'assumptions));
                            _ := (print "\nWe'll try to claim this goal:" goal ". Does it hold?: " cond1 ". Is it in the assumptions?: " cond2)
                        }
                      check {(|| cond1 cond2) =>
                          let {_ := (set! (goal-record 'proof) ["(!claim " (val->string goal) ")"]);
                               _ := (set! (goal-record 'tactic) ['claim []])}
                            rest
                           | else => let {_ := (print "\nNO DICE...\n")} (error "Incorrect application of 'claim tactic--the top goal does not hold.")}
                | _ => goal-stack
              }
  }|

define (spaces n) :=
  check {(n less? 1) => ""
       | else => (join " " (spaces (n minus 1)))}

define (stringify v) :=
  letrec {loop := lambda (chars so-far)
                    match chars {
                      [] => (rev so-far)
                    | (list-of c more) => check {(c equals? `\n) => (loop more so-far)
                                               | (&& (c equals? `\032) (negate (null? so-far)) (equals? (first so-far) `\032)) => (loop more so-far)
                                               | else => (loop more (add c so-far))}
                    }}
    (loop (val->string v) [])                   
   
     
define (tac->string tac) :=
  match tac {
    [tactic-name tactic-info] =>
      check {(tactic-name equals? 'claim) => "'claim " 
           | else => (stringify tac)}
  | _ => (stringify tac)
  }

define (show-tree) :=
  let {start := (ref root-goal);
       current-stack := (ref goal-stack);
       current-goal-id := check {(null? current-stack) => ()
                               | else => ((first current-stack) 'id)}}
    letrec {display-goal-record  := lambda (goal-record level)
                                      let {goal := (goal-record 'goal);
                                           goal-id := (goal-record 'id);
                                           leaf-suffix := check {(leaf? goal-record) => " ** LEAF **"
                                                               | else => ""};
                                           is-current := (equals? goal-id current-goal-id);
                                           goal-line := check {(equals? goal-id current-goal-id) => (join "---> Goal: " (stringify goal))
                                                             | else => (join "Goal: " (stringify goal))};
                                           _ := (print "\n" (spaces level) (stringify (goal-record 'path))
                                                       goal-line 
                                                       "Assumptions:" (stringify (goal-record 'assumptions))
                                                       "Tactic:" (join (tac->string (ref (goal-record 'tactic))) leaf-suffix))}
                                       (display-goal-records (ref (goal-record 'children)) (plus level 2));
            display-goal-records := lambda (goal-records level)
                                      match goal-records {
                                        [] => ()
                                      | (list-of goal-record more) => let {_ := (display-goal-record goal-record level)}
                                                                        (display-goal-records more level)
                                      }}
       (display-goal-record start 0)                                      
  
define done? := lambda () (null? (ref goal-stack))

define (apply-tactic tactic-name args) :=
  let {# Retrieve the tactic by name: 
       tactic := (tactic-dictionary tactic-name);
       _ := (print "\nGot the tactic, and here's the args: " args);
       # Apply the tactic to the goal-stack: 
       new-stack      := (try (tactic (ref goal-stack) args) 'error)}
    match new-stack {
      'error => 'error
    | _ => let {_ := (set! goal-stack new-stack);
                _ := (print "\nApplied tactic" (val->string tactic-name) "successfully.\n");
                _ := check {(done?) => (print "\nGoal completely proven!")
                          | else => (seq (print "\nHere's the new goal stack:\n") 
                                         (show-stack)
                                         (print "\nWill now try to apply the claim tactic...\n")
                                         (apply-tactic 'claim [])
                                         (print "\nAnd the new search tree:\n")
                                         (show-tree))
                           }
               }
             'success                                         
    }

define (apply-tactic* tactic-name args) :=
## As long as it can be successfully applied and we are not completely done, keep applying the given tactic. 
  match (apply-tactic tactic-name args) {
    'success => check {(done?) => ()
                     | else => (apply-tactic* tactic-name args)}
  | _ => ()                     
  }                                         



define (show-proof) :=
  letrec {join-proof-chunks := lambda (proof-chunks children-proofs res) 
                                 match proof-chunks {
                                   [] => (flatten (join (rev res)))
                                 | (list-of chunk more) => check {(&& (equal? chunk marker) (negate (null? children-proofs))) =>
                                                                    (join-proof-chunks more
                                                                                      (tail children-proofs)
                                                                                      (add (first children-proofs) res))
                                                                | else => (join-proof-chunks more children-proofs (add chunk res))}
                                 };
          compose-proof := lambda (goal-record)
                             check {(leaf? goal-record) => (flatten (join (ref (goal-record 'proof))))
                                  | else => let {children-proofs := (map compose-proof (ref (goal-record 'children)));
                                                 proof-chunks := (ref (goal-record 'proof))}
                                              (join-proof-chunks proof-chunks children-proofs [])}}
    (compose-proof (ref root-goal))

} # close module Tactics 

declare A, B, C, D, E: Boolean

declare zero:Int
declare succ: [Int] -> Int
declare P, Q, pos, T: [Int] -> Boolean
declare a, b, c: Int

open Tactics

EOF

load "lib/basic/tactics"

assert d := (A | B | C)
assert con := (and (if A D) (if B D) (if C D))
(set-goal D)

(apply-tactic 'case-analysis [d])

assert p1 := (A ==> B & C)
assert p2 := (~ B)
(set-goal (not A))
(apply-tactic 'contradiction [])
(apply-tactic 'infer [method () (!mp p1 A)])
(apply-tactic 'go-back [[]])

(apply-tactic 'from-complements [B p2])



(!by-contradiction (not A)
  let {_ := (!mp p1 A)}
  (!from-complements false B (not B)))

  

(set-goal (if (and A B) (and B A)))

define p := (and (not A) (not not A) (iff (A & B) (B & A)) (not not A));;

(find-positive-parent A p)

(apply-tactic 'back [])

(apply-tactic* 'back [])

(apply-tactic 'and<- [])


define [p1 p2] := [(A ==> B & C) (A & E)]
assert [p1 p2]
(set-goal C)
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p2])


(clear-state)
(clear-assumption-base)


assert p1 := (forall x . P x & Q x & T x)
(set-goal (Q a))
(apply-tactic 'extract [p1])


(clear-state)
(clear-assumption-base)

load "lib/basic/tactics"
assert p1 := (forall x . P x | T x ==> Q x)
assert p2 := (P a)
(set-goal (Q a))
(apply-tactic 'extract [p1])
(apply-tactic 'extract [p1])
(show-tree)
(apply-tactic 'lor<- [])
---> THIS NOW GIVES INFINITE LOOP: (apply-tactic 'back [])

(clear-state)
(clear-assumption-base)

assert p1 := (forall x . P x | Q x | T x)
assert p2 := (P a ==> Q a)
assert p3 := (T a ==> Q a)

(set-goal (Q a))

(apply-tactic 'extract [p1])


(apply-tactic 'extract [p1])



(Polarities.find-universally-positive-parent (Q a) p1)