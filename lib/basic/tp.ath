## An implementation of semantic tableaux for first-order logic
## using infinite streams rather than unification. The method
## uses weaving of infinite streams to get a fair and seemingly
## relatively efficient strategy for choosing terms with which 
## to instantiate the universal generalizations. 

(define (shuffle L k)
  (let (([x L'] (decompose-nth L (random-int k))))
    (add x L')))

(define (multiple-of? a k)
  (equal? (mod a k) 0))

(define (s L) (shuffle L (length L)))

(define (consistent? literals)
  (match literals   
    ((split _ (list-of A (split _ (list-of (not A) _)))) false)
    ((split _ (list-of (not A) (split _ (list-of A _)))) false)
    (_ true)))

(define (dual L)
  (match L
    ((some-atom A) (not A))
    ((not (some-atom A)) A)))

(define (make-var n) (string->var (join "a" (symbol->string n))))

(define (safe-uspec ugen t)
  (!uspec ugen t))

(define (safe-uspec ugen t)
    (dcheck ((less? (ref (second ugen)) 8) 
              (dlet ((_ (inc (second ugen))))
                (!uspec (first ugen) t)))))

(define (safe-uspec* p terms)
  (dletrec ((loop (method (p terms)
                    (dmatch terms 
                      ([] (!claim p))
                      ((list-of t more) (!loop (!uspec p t) more))))))
     (dtry (!loop p terms)
           (!claim p))))

(define (has-equants? p)
  (match p 
    ((exists (some-var _) _) true)
    (((some-prop-con _) (some-list props)) (for-some props has-equants?))
    ((forall (some-var _) body) (has-equants? body))
    (_ false)))

(define (sort L)
  (letrec ((loop (lambda (L cprops dprops)
                   (match L 
                     ((list-of (bind p (and (some-list _))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (iff _ _)) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (not (not _))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (not (or (some-list _)))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (not (if _ _))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (forall (some-var _) _)) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (not (forall (some-var _) _))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (not (exists (some-var _) _))) rest) (loop rest (add p cprops) dprops))
                     ((list-of (bind p (exists (some-var _) _)) rest) (loop rest (add p cprops) dprops))
		     ((list-of (bind p (if _ _)) rest) (loop rest cprops (add p dprops)))
                     ((list-of (bind p (or (some-list _))) rest) (loop rest cprops (add p dprops)))
                     ((list-of (bind p (not (iff _ _))) rest) (loop rest cprops (add p dprops)))
                     ((list-of (bind p (not (and (some-list _)))) rest) (loop rest cprops (add p dprops)))
                     ((list-of L rest) (loop rest (add L cprops) dprops))
                     ([] [(rd cprops) (rd dprops)])))))
    (loop L [] [])))


(define (refute props terms)
  (dlet ((i (cell 0))
         (limit 50000)
         (writeln-val1 (lambda (x y) ()))
         (writeln-val1 (lambda (x y) 
                         (match y
                           ((some-list _) (seq (print (join "\n" x)) (map write y)))
                           (_ (writeln-val x y)))))
         (print1 print)
         (print1 (lambda (x) ()))
         (continue1 (lambda () ()))
         (continue1 continue)
         (_ ()))
    (dletrec 
      ((M (method (props literals evars terms ugens)
            (dlet ((_ (print1 "\n======================================================================\n"))
                   (_ (writeln-val1 "props: " props))
                   (_ (writeln-val1 "literals: " literals))
                   (_ (writeln-val1 "ugens: " ugens))
                   (_ (writeln-val1 "evars: " evars))
                   (_ (writeln-val1 "terms: " terms))
                   (_ (continue1))
                   (_ (check ((greater? (inc i) limit) 
                                (let ((_ (print "\nAbout to call ATP...\n"))
                                      (_ (writeln-val1 "props: " props))
                                      (_ (writeln-val1 "ugens: " ugens))
                                      (_ (writeln-val1 "literals: " literals))
                                      (_ (continue1))
                                      (res (!spf false (join props literals ugens)))
                                      (_ (match res (false (mark `S)) (_ (mark `F)))))
                                  (halt)))
                             (else ())))
                   (_ (check ((null? props) (seq (print "\nEmpty prop list, can't close branch...")
                                                 (writeln-val "literals: " literals)
                                                 (writeln-val "ugens: " ugens)
                                                 (writeln-val "evars: " evars)
                                                 (writeln-val "terms: " terms)
                                                 (halt)))
                             (else ())))
                   (first (first props))
                   (rest  (tail props)))
              (dmatch first
                ((bind P (and P1 P2)) (!bin-conj-case (!left-and P) (!right-and P) rest literals evars terms ugens))
                ((not (not P)) (!unary-conj-case (!dn (not (not P))) rest literals evars terms ugens))
                ((bind P (not (or p1 p2))) (dlet ((q (!dm P))
                                                  (left (!left-and q))
                                                  (right (!right-and q)))
                                             (!bin-conj-case left right rest literals evars terms ugens)))
                ((bind P (not (if _ _))) 
                  (!bin-conj-case (!neg-cond1 P) (!neg-cond2 P) rest literals evars terms ugens))
                ((bind P (iff _ _)) 
                  (!bin-conj-case (!left-iff P) (!right-iff P) rest literals evars terms ugens))
                ((bind P (or _ _)) (!disj-case P rest literals evars terms ugens))
                ((bind P (not (and p1 p2))) (!disj-case (!dm P) rest literals evars terms ugens))
                ((bind P (if _ _)) (!disj-case (!cond-def P) rest literals evars terms ugens))
                ((bind P (not (iff _ _))) (!disj-case (!neg-bicond P) rest literals evars terms ugens))
                ((bind P (forall (list-of _ _) _))
                  (!map-method (method (t) (!safe-uspec P t))
                               (join evars terms)
                               (method (specialized_props)
                                  (!M (join (rd specialized_props) rest) literals evars terms (add P ugens)))))
                 ((bind P (exists x Q))
                   (pick-witness w P 
                     (!map-method (method (ugen) (!safe-uspec ugen w))
                                  ugens
                                  (method (specialized_props)
                                     (!M (join [(replace-var x w Q)] specialized_props rest)
                                         literals (add w evars) terms ugens)))))
                 ((bind P (not (forall (list-of _ _) _))) (!unary-conj-case (!qn P) rest literals evars terms ugens))
                 ((bind P  (not (exists (list-of _ _) _))) (!unary-conj-case (!qn P) rest literals evars terms ugens))
                 (L (dlet ((L' (dual L)))
                      (dcheck ((| (member? L' literals) (member? L' rest)) 
                                  (dlet ((_ (print1 "Closing a branch!!!!\n")))
                                    (!comm-absurd L L')))
                              (else (!M rest (add L literals) evars terms ugens)))))))))
       (bin-conj-case (method (P1 P2 props literals evars terms ugens)
                        (!M (join [P1 P2] props) literals evars terms ugens)))
       (unary-conj-case (method (P props literals evars terms ugens)
                          (!M (add P props) literals evars terms ugens)))
       (disj-case (method (P props literals evars terms ugens)
                    (dmatch P
                      ((or P1 P2) (!cases P (assume P1 (!M (add P1 props) literals evars terms ugens))
                                            (assume P2 (!M (add P2 props) literals evars terms ugens))))))))
      (!M props [] [] terms []))))




(define (taut p)
  (!by-contradiction' p
     (assume (not p)
       (dlet ((th (!refute [(not p)] (choice-prop-subterms p))))
         (!claim th)))))

(define (refute props terms)
  (dlet ((i (cell 0))
         (limit 50000)
         ([cprops dprops] (sort props))
         (writeln-val1 (lambda (x y) 
                         (match y
                           ((some-list _) (seq (print (join "\n" x)) (map write y)))
                           (_ (writeln-val x y)))))
         (writeln-val1 (lambda (x y) ()))
         (print1 print)
         (print1 (lambda (x) ()))
         (continue1 continue)
         (continue1 (lambda () ()))
         (_ ()))
    (dletrec 
      ((M (method (cprops dprops literals evars terms ugens)
            (dlet ((_ (print1 "\n======================================================================\n"))
                   (_ (writeln-val1 "cprops: " cprops))
                   (_ (writeln-val1 "dprops: " dprops))
                   (_ (writeln-val1 "literals: " literals))
                   (_ (writeln-val1 "ugens: " ugens))
                   (_ (writeln-val1 "evars: " evars))
                   (_ (writeln-val1 "terms: " terms))
                   (_ (continue1))
                   (_ (check ((greater? (inc i) limit) 
                                (let ((_ (print "\nAbout to call ATP...\n"))
                                      (_ (writeln-val1 "props: " props))
                                      (_ (writeln-val1 "ugens: " ugens))
                                      (_ (writeln-val1 "literals: " literals))
                                      (_ (continue1))
                                      (res (!spf false (join props literals ugens)))
                                      (_ (match res (false (mark `S)) (_ (mark `F)))))
                                  (halt)))
                             (else ())))
                   (_ (check ((null? props) (seq (print "\nEmpty prop list, can't close branch...")
                                                 (writeln-val "literals: " literals)
                                                 (writeln-val "ugens: " ugens)
                                                 (writeln-val "evars: " evars)
                                                 (writeln-val "terms: " terms)
                                                 (halt)))
                             (else ()))))
              (dmatch cprops
                ((list-of (bind P (and P1 P2)) crest)
                  (!bin-conj-case (!left-and P) (!right-and P) crest dprops literals evars terms ugens))
                ((list-of (not (not P)) crest) 
                  (!unary-conj-case (!dn (not (not P))) crest dprops literals evars terms ugens))
                ((list-of (bind P (not (or p1 p2))) crest) 
                   (dlet ((q (!dm P))
                         (left (!left-and q))
                         (right (!right-and q)))
                     (!bin-conj-case left right crest dprops literals evars terms ugens)))
                ((list-of (bind P (not (if _ _))) crest)
                  (!bin-conj-case (!neg-cond1 P) (!neg-cond2 P) crest dprops literals evars terms ugens))
                ((list-of (bind P (iff _ _)) crest)
                  (!bin-conj-case (!left-iff P) (!right-iff P) crest dprops literals evars terms ugens))
                ((list-of (bind P (forall (list-of _ _) _)) crest)
                  (!map-method (method (t) (!safe-uspec P t))
                               (join evars terms)
                               (method (specialized_props)
                                 (dlet (([cprops' dprops'] (sort specialized_props)))
                                   (!M (join (rd cprops') crest) (join (rd dprops') dprops) 
                                       literals evars terms (add P ugens))))))
                 ((list-of (bind P (exists x Q)) crest)
                   (pick-witness w P 
                     (!map-method (method (ugen) (!safe-uspec ugen w))
                                  ugens
                                  (method (specialized_props)
                                    (dlet (([cprops' dprops'] (sort (add (replace-var x w Q) specialized_props))))
                                      (!M (join (rd cprops') crest) (join (rd dprops') dprops)  
                                          literals (add w evars) terms ugens))))))
                 ((list-of (bind P (not (forall (list-of _ _) _))) crest)
                   (!unary-conj-case (!qn P) crest dprops literals evars terms ugens))
                 ((list-of (bind P  (not (exists (list-of _ _) _))) crest)
                   (!unary-conj-case (!qn P) crest dprops literals evars terms ugens))
                 ((list-of L crest) (dlet ((L' (dual L)))
                                      (dcheck ((member? L' literals)
                                               (dlet ((_ (print1 "Closing a branch!!!!\n")))
                                                 (!comm-absurd L L')))
                                              (else (!M crest dprops (add L literals) evars terms ugens)))))
                 ([] (dmatch dprops 
                      ((list-of (bind P (or _ _)) drest) 
                        (!disj-case P [] drest literals evars terms ugens))
                      ((list-of (bind P (not (and p1 p2))) drest)
                        (!disj-case (!dm P) [] drest literals evars terms ugens))
                      ((list-of (bind P (if _ _)) drest) 
                        (!disj-case (!cond-def P) [] drest literals evars terms ugens))
                      ((list-of (bind P (not (iff _ _))) drest)
                        (!disj-case (!neg-bicond P) [] drest literals evars terms ugens))
                      ([] (dlet ((fvar (fresh-var)))
                            (!map-method (method (ugen) (!safe-uspec ugen fvar))
                                         ugens
                                         (method (specialized_props)
                                           (dlet (([cprops' dprops'] (sort specialized_props)))
                                             (!M (rd cprops') (rd dprops') 
                                                 literals evars (add fvar terms) ugens))))))))))))
       (bin-conj-case (method (P1 P2 cprops dprops literals evars terms ugens)
                        (dlet (([cprops' dprops'] (sort [P1 P2])))
                          (!M (join cprops' cprops) (join dprops' dprops) literals evars terms ugens))))
       (unary-conj-case (method (P cprops dprops literals evars terms ugens)
                          (dlet (([cprops' dprops'] (sort [P])))
                            (!M (join cprops' cprops) (join dprops dprops') literals evars terms ugens))))
       (disj-case (method (P cprops dprops literals evars terms ugens)
                    (dmatch P
                      ((or P1 P2) (!cases P (assume P1 
                                              (dlet (([cprops' dprops'] (sort [P1])))
                                                (!M (join cprops' cprops) (join dprops' dprops) 
                                                    literals evars terms ugens)))
                                            (assume P2 
                                              (dlet (([cprops' dprops'] (sort [P2])))
                                                (!M (join cprops' cprops) (join dprops' dprops) 
                                                    literals evars terms ugens)))))))))
      (!M cprops dprops [] [] terms []))))



(define (show-inconsistent props)
  (dmatch props 
    ((split _ (list-of p (split _ (list-of (not p) rest)))) (!absurd p (not p)))
    ((split _ (list-of (not p) (split _ (list-of p rest)))) (!absurd p (not p)))))
 

(define (refute props terms retry)
  (dlet ((i (cell 0))
         (limit 5000)
         ([cprops dprops] (sort props))
         (writeln-val1 (lambda (x y) 
                         (match y
                           ((some-list _) (seq (print (join "\n" x)) (map write y)))
                           (_ (writeln-val x y)))))
         (writeln-val1 (lambda (x y) ()))
         (print1 print)
         (print2 print)
         (writeln-val2 writeln-val)
         (print1 (lambda (x) ()))
         (continue1 continue)
         (continue1 (lambda () ()))
         (_ ()))
    (dletrec 
      ((M (method (cprops dprops literals evars terms ugens)
            (dlet ((_ (print1 "\n======================================================================\n"))
                   (_ (print1 "\nKKKKKKKKKKKKKKKKKKK\n"))
                   (_ (writeln-val1 "cprops: " cprops))
                   (_ (writeln-val1 "dprops: " dprops))
                   (_ (writeln-val1 "literals: " literals))
                   (_ (writeln-val1 "ugens: " ugens))
                   (_ (writeln-val1 "evars: " evars))
                   (_ (writeln-val1 "terms: " terms))
                   (cprops' (check ((null? cprops) cprops)
                                   (else (shuffle cprops (length cprops)))))
                   (cprops  cprops')
                   (_ (continue1))
                   (_ ())
                   (_ (check ((null? props) (seq (print "\nEmpty prop list, can't close branch...")
                                                 (writeln-val "literals: " literals)
                                                 (writeln-val "ugens: " ugens)
                                                 (writeln-val "evars: " evars)
                                                 (writeln-val "terms: " terms)
                                                 (halt)))
                             (else ()))))
             (dcheck 
              ((greater? (inc i) limit) 
                (dtry (!show-inconsistent (join cprops dprops literals ugens))
                      (dlet ((_ (print1 "\nAbout to call ATP...\n"))
                             (_ (writeln-val1 "cprops: " cprops))
                             (_ (writeln-val1 "drops: " dprops))
                             (_ (writeln-val1 "literals: " literals))
                             (_ (writeln-val1 "ugens: " ugens))
                             (all-props (join cprops dprops literals ugens))
                             ([_ all-props'] (filter-and-complement all-props has-equants?))
                             (_ (writeln-val1 "all-props': " all-props'))
                             (_ (print2 "\nCalling external ATP...\n"))
                             (th (dtry (dlet ((th (!spf false all-props'))
                                              (_  (print2 "\nSUCCESS on NO EXISTENTIALS...\n")))
                                         (!claim th))
                                       (dlet ((_ (writeln-val2 "\nATP failed on: " all-props'))
                                              (th' (dmatch retry
                                                     (true (!refute all-props (choice-prop-subterms* all-props) false))
                                                     (_ (!true-intro))))
                                              (_ (check ((equal? th' true) (print2 "\nRefute failed as well..."))
                                                         (else (print2 "\nBut refute succeeded!")))))
                                          (dcheck ((equal? th' true) (!vpf false all-props))
                                                  (else (!claim th'))))))
                             (_ (check ((equal? th false) (print1 "\nSuccess!!\n")) 
                                       (else (print1 "\nFailure...\n"))))
                             (_ (continue1)))
                        (!claim th))))
             (else                     
              (dmatch cprops
                ((list-of (bind P (and P1 P2)) crest)
                  (!bin-conj-case (!left-and P) (!right-and P) crest dprops literals evars terms ugens))
                ((list-of (not (not (some-prop P))) crest) 
                  (!unary-conj-case (!dn (not (not P))) crest dprops literals evars terms ugens))
                ((list-of (bind P (not (or p1 p2))) crest) 
                   (dlet ((q (!dm P))
                         (left (!left-and q))
                         (right (!right-and q)))
                     (!bin-conj-case left right crest dprops literals evars terms ugens)))
                ((list-of (bind P (not (if _ _))) crest)
                  (!bin-conj-case (!neg-cond1 P) (!neg-cond2 P) crest dprops literals evars terms ugens))
                ((list-of (bind P (iff _ _)) crest)
                  (!bin-conj-case (!left-iff P) (!right-iff P) crest dprops literals evars terms ugens))
                ((list-of (bind P (forall (list-of _ _) _)) crest)
                  (!map-method (method (t) (!safe-uspec P t))
                               (join evars terms)
                               (method (specialized_props)
                                 (dlet (([cprops' dprops'] (sort specialized_props)))
                                   (!M (join (rd cprops') crest) (join (rd dprops') dprops) 
                                       literals evars terms (add P ugens))))))
                 ((list-of (bind P (exists (some-var x) (some-prop Q))) crest)
                   (pick-witness w P 
                     (!map-method (method (ugen) (!safe-uspec ugen w))
                                  ugens
                                  (method (specialized_props)
                                    (dlet ((_ ())
                                           ([cprops' dprops'] (sort (add (replace-var x w Q) specialized_props))))
                                      (!M (join crest (rd cprops')) (join dprops (rd dprops'))
                                          literals (add w evars) terms ugens))))))
                 ((list-of (bind P (not (forall (list-of _ _) _))) crest)
                   (!unary-conj-case (!qn P) crest dprops literals evars terms ugens))
                 ((list-of (bind P  (not (exists (list-of _ _) _))) crest)
                   (!unary-conj-case (!qn P) crest dprops literals evars terms ugens))
                 ((list-of L crest) (dlet ((L' (dual L)))
                                      (dcheck ((member? L' literals)
                                               (dlet ((_ (print1 "Closing a branch!!!!\n")))
                                                 (!comm-absurd L L')))
                                              (else (!M crest dprops (add L literals) evars terms ugens)))))
                 ([] (dmatch dprops 
                      ((list-of (bind P (or _ _)) drest) 
                        (!disj-case P [] drest literals evars terms ugens))
                      ((list-of (bind P (not (and p1 p2))) drest)
                        (!disj-case (!dm P) [] drest literals evars terms ugens))
                      ((list-of (bind P (if _ _)) drest) 
                        (!disj-case (!cond-def P) [] drest literals evars terms ugens))
                      ((list-of (bind P (not (iff _ _))) drest)
                        (!disj-case (!neg-bicond P) [] drest literals evars terms ugens))
                      ([] (dlet ((fvar (fresh-var)))
                            (!map-method (method (ugen) (!safe-uspec ugen fvar))
                                         ugens
                                         (method (specialized_props)
                                           (dlet (([cprops' dprops'] (sort specialized_props)))
                                             (!M (rd cprops') (rd dprops') 
                                                 literals evars (add fvar terms) ugens))))))))))))))
       (bin-conj-case (method (P1 P2 cprops dprops literals evars terms ugens)
                        (dlet (([cprops' dprops'] (sort [P1 P2])))
                          (!M (join cprops' cprops) (join dprops' dprops) literals evars terms ugens))))
       (unary-conj-case (method (P cprops dprops literals evars terms ugens)
                          (dlet (([cprops' dprops'] (sort [P])))
                            (!M (join cprops' cprops) (join dprops dprops') literals evars terms ugens))))
       (disj-case (method (P cprops dprops literals evars terms ugens)
                    (dmatch P
                      ((or P1 P2) (!cases P (assume P1 
                                              (dlet (([cprops' dprops'] (sort [P1])))
                                                (!M (join cprops' cprops) (join dprops' dprops) 
                                                    literals evars terms ugens)))
                                            (assume P2 
                                              (dlet (([cprops' dprops'] (sort [P2])))
                                                (!M (join cprops' cprops) (join dprops' dprops) 
                                                    literals evars terms ugens)))))))))
      (!M cprops dprops [] [] terms []))))


(define (taut p)
  (!by-contradiction' p
     (assume (not p)
       (dlet ((th (!refute [(not p)] (choice-prop-subterms p) true)))
         (!claim th)))))


(define (rp props) 
  (assume (and props) 
    (!refute props (fold join (map choice-prop-subterms props) []) true)))


(define (writeln-val1 x y)
  (match y
    ((some-list _) (seq (print (join "\n" x)) (map write y)))
    (_ (writeln-val x y))))


(define (show-state-cont cprops dprops literals evars terms ugens ccount dcount iteration)
             (let ((_ (print "\n======================================================================\n"))
                   (_ (writeln-val1 "Iteration: " iteration))
                   (_ (writeln-val1 "ccount: " ccount))
                   (_ (writeln-val1 "dcount: " dcount))
                   (_ (writeln-val1 "cprops: " cprops))
                   (_ (writeln-val1 "dprops: " dprops))
                   (_ (writeln-val1 "literals: " literals))
                   (_ (writeln-val1 "ugens: " ugens))
                   (_ (writeln-val1 "evars: " evars))
                   (_ (writeln-val1 "terms: " terms)))
               (continue)))

(define (show-state cprops dprops literals evars terms ugens ccount dcount iteration)
             (let ((_ (print "\n======================================================================\n"))
                   (_ (writeln-val1 "Iteration: " iteration))
                   (_ (writeln-val1 "ccount: " ccount))
                   (_ (writeln-val1 "dcount: " dcount))
                   (_ (writeln-val1 "cprops: " cprops))
                   (_ (writeln-val1 "dprops: " dprops))
                   (_ (writeln-val1 "literals: " literals))
                   (_ (writeln-val1 "ugens: " ugens))
                   (_ (writeln-val1 "evars: " evars))
                   (_ (writeln-val1 "terms: " terms)))
               ()))

(define (try-again cprops dprops literals ugens evars terms refute retry)
  (dlet ((ugens' (map first ugens)))
    (dtry (!show-inconsistent (join cprops dprops literals ugens'))
          (dlet ((_ (print "\nAbout to call ATP...\n"))
                (show-state1 (lambda (cprops dprops literals evars terms ugens a b c) ()))
                (_ (show-state1 cprops dprops literals evars terms ugens 0 0 0))
                (all-props (join cprops dprops literals ugens'))
                ([_ all-props'] (filter-and-complement all-props has-equants?))
                (_ (writeln-val1 "all-props': " all-props'))
                (_ (print "\nCalling external ATP...\n"))
                (th (dtry (dlet ((th (!spf false all-props'))
                                 (_  (print "\nSUCCESS on NO EXISTENTIALS...\n")))
                            (!claim th))
                          (!vpf false all-props)
                          (!true-intro)))
                (_ (check ((equal? th false) (print ""))
                          (else (print "\nATP failed on joined props...\n")))))
            (!claim th)))))


(define (refute1 props terms retry)
  (dlet ((psize (prop-size* props))
         (i (cell 0))
         (limit 10000)
         ([cprops dprops] (sort props))
         (print1 print)
         (show-state-cont (lambda (x1 x2 x3 x4 x5 x6 x7 x8 x9) ())))
    (dletrec 
      ((do-cprop (method (cprop crest dprops literals evars terms ugens ccount dcount iteration)
                   (dmatch cprop 
                     ((bind p (and _ _)) 
                       (!bin-conj-case (!left-and p) (!right-and p) crest dprops literals evars terms ugens 
                                       ccount dcount iteration))
                     ((not (not (some-prop p)))
                       (!unary-conj-case (!dn (not (not p))) crest dprops literals evars terms ugens
                                         ccount dcount iteration))
                     ((bind p (not (or _ _)))
                       (dlet ((q (!dm p))
                              (left (!left-and q))
                              (right (!right-and q)))
                         (!bin-conj-case left right crest dprops literals evars terms ugens
                                         ccount dcount iteration)))
                     ((bind p (not (if _ _))) 
                       (!bin-conj-case (!neg-cond1 p) (!neg-cond2 p) crest dprops literals evars terms ugens
                                       ccount dcount iteration))
                     ((bind p (iff _ _))
                       (!bin-conj-case (!left-iff p) (!right-iff p) crest dprops literals evars terms ugens
                                       ccount dcount iteration))
                     ((bind p (forall (bind uvars (list-of _ _)) _))
                       (!map-method-non-strictly 
                                    (method (term) (!uspec p term))
                                    (join evars terms)
                                    (method (specialized_props)
                                      (dlet (([cprops' dprops'] (sort specialized_props)))
                                        (!M (join cprops' crest) (join  dprops' dprops) 
                                            literals evars terms (add [p (cell 0)] ugens) 
                                                     (plus (minus ccount 1) (length cprops'))
                                                     (plus dcount (length dprops')) (plus iteration 1))))))
                     ((bind p (exists (some-var x) (some-prop q)))
                       (pick-witness w p
                         (!map-method-non-strictly (method (ugen) (!safe-uspec ugen w))
                                      ugens
                                      (method (specialized_props)
                                        (dlet (([cprops' dprops'] (sort (add (replace-var x w q) specialized_props))))
                                          (!M (join crest cprops') (join dprops (rd dprops'))
                                               literals (add w evars) terms ugens (plus (minus ccount 1) (length cprops'))
                                               (plus dcount (length dprops')) (plus iteration 1)))))))
                     ((bind p (not (forall (list-of _ _) _)))
                       (!unary-conj-case (!qn p) crest dprops literals evars terms ugens ccount dcount iteration))
                     ((bind p  (not (exists (list-of _ _) _)))
                       (!unary-conj-case (!qn p) crest dprops literals evars terms ugens ccount dcount iteration))
                     (L (dlet ((L' (dual L)))
                         (dcheck ((member? L' literals)
                                   (dlet ((_ (print1 "Closing a branch!!!!\n")))
                                     (!comm-absurd L L')))
                                 (else (!M crest dprops (add L literals) evars terms ugens (minus ccount 1) dcount 
                                           (plus iteration 1)))))))))
       (do-dprop (method (dprop drest cprops literals evars terms ugens ccount dcount iteration)
                   (dmatch dprop 
                     ((bind p (or _ _))
                       (!disj-case p cprops drest literals evars terms ugens ccount dcount iteration))
                      ((bind p (if _ _))
                        (!disj-case (!cond-def p) cprops drest literals evars terms ugens 
                                    ccount dcount iteration))
                      ((bind p (not (and _ _)))
                        (!disj-case (!dm p) cprops drest literals evars terms ugens ccount dcount iteration))
                      ((bind p (not (iff _ _)))
                        (!disj-case (!neg-bicond p) cprops drest literals evars terms ugens
                                    ccount dcount iteration)))))
       (bin-conj-case (method (p1 p2 cprops dprops literals evars terms ugens ccount dcount iteration)
                        (dlet (([cprops' dprops'] (sort [p1 p2]))
                               (ccount' (length cprops'))
                               (dcount' (length dprops')))
                          (!M (join cprops' cprops) (join dprops' dprops) literals evars terms ugens
                              (plus ccount' (minus ccount 1)) (plus dcount dcount') (plus iteration 1)))))
       (unary-conj-case (method (p cprops dprops literals evars terms ugens ccount dcount iteration)
                          (dlet (([cprops' dprops'] (sort [p]))
                                 (ccount' (length cprops'))
                                 (dcount' (length dprops')))                                
                            (!M (join cprops' cprops) (join dprops dprops') literals evars terms ugens
                                (plus ccount' (minus ccount 1)) (plus dcount dcount') (plus iteration 1)))))
       (disj-case (method (p cprops dprops literals evars terms ugens ccount dcount iteration)
                    (dmatch p
                      ((or p1 p2) (!cases p (assume p1
                                              (dlet (([cprops' dprops'] (sort [p1]))
                                                     (ccount' (length cprops'))
                                                     (dcount' (length dprops')))
                                                (!M (join cprops' cprops) (join dprops' dprops) 
                                                    literals evars terms ugens (plus ccount ccount') 
                                                    (plus dcount' (minus dcount 1)) (plus iteration 1))))
                                            (assume p2 
                                              (dlet (([cprops' dprops'] (sort [p2]))
                                                     (ccount' (length cprops'))
                                                     (dcount' (length dprops')))
                                                (!M (join cprops' cprops) (join dprops' dprops)
                                                    literals evars terms ugens (plus ccount ccount') 
                                                    (plus dcount' (minus dcount 1)) (plus iteration 1)))))))))      
       (do-dprops (method (dprops cprops literals evars terms ugens ccount dcount iteration)
                    (dcheck ((multiple-of? iteration 1) 
                              (dlet (((list-of dprop drest) (shuffle dprops dcount)))
                                (!do-dprop dprop drest cprops literals evars terms ugens ccount dcount iteration)))
                            (else (!do-dprop (head dprops) (tail dprops) cprops literals evars terms ugens 
                                             ccount dcount iteration)))))
       (do-cprops (method (cprops dprops literals evars terms ugens ccount dcount iteration)
                    (dcheck ((multiple-of? iteration 1) 
                              (dlet (((list-of cprop crest) (shuffle cprops ccount)))
                                (!do-cprop cprop crest dprops literals evars terms ugens ccount dcount iteration)))
                            (else (!do-cprop (head cprops) (tail cprops) dprops literals evars terms ugens 
                                             ccount dcount iteration)))))
       (M (method (cprops dprops literals evars terms ugens ccount dcount iteration)
            (dlet ((_ (show-state-cont cprops dprops literals evars terms ugens ccount dcount iteration))
                   (evar-count (length evars))
                   (stop-cond1 (& (less? psize 11) (greater? evar-count 5) (greater? iteration 50)))
                   (stop-cond2 (& (less? psize 25) (greater? evar-count 10)))
                   (stop-cond3 (& (greater? psize 30) (greater? evar-count 20))))
              (dcheck ((| (greater? (inc i) limit) stop-cond1 stop-cond2 stop-cond3 (greater? iteration 500))
                        (!try-again cprops dprops literals ugens evars terms refute1 retry))
                      (else                     
                        (dmatch [cprops dprops]
                          ([(list-of _ _) (list-of _ _)]
                             (dcheck ((multiple-of? iteration 5)
                                       (!do-dprops dprops cprops literals evars terms ugens ccount dcount iteration))
                                     (else (!do-cprops cprops dprops literals evars terms ugens ccount dcount iteration))))
                          ([_ (list-of dprop drest)] 
                            (dcheck ((multiple-of? iteration 1) 
                                      (dlet (((list-of dprop' drest') (shuffle dprops dcount)))
                                       (!do-dprop dprop' drest' [] literals evars terms ugens ccount dcount iteration)))
                                    (else (!do-dprop dprop drest [] literals evars terms ugens ccount dcount iteration))))
                          ([(list-of cprop crest) _] 
                            (dcheck ((multiple-of? iteration 1) 
                                      (dlet (((list-of cprop' crest') (shuffle cprops ccount)))
                                       (!do-cprop cprop' crest' [] literals evars terms ugens ccount dcount iteration)))
                                    (else (!do-cprop cprop crest [] literals evars terms ugens ccount dcount iteration))))
                          ([[] []] (dlet ((fvar (fresh-var)))
                                     (!map-method-non-strictly (method (ugen) (!safe-uspec ugen fvar))
                                                  ugens
                                                  (method (specialized_props)
                                                    (dlet (([cprops' dprops'] (sort specialized_props))
                                                           (ccount' (length cprops'))
                                                           (dcount' (length dprops')))
                                                      (!M cprops' dprops' literals evars (add fvar terms) ugens
                                                          ccount' dcount' (plus iteration 1))))))))))))))
      (!M cprops dprops [] [] terms [] (length cprops) (length dprops) 1))))


(define (taut1 p)
  (!by-contradiction' p
     (assume (not p)
       (dlet ((th (!refute1 [(not p)] (choice-prop-subterms p) true)))
         (!claim th)))))

(define taut taut1)

## (load-file "tableaux-tests.ath")


