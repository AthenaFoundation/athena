module Polarities {

define (flip pol) :=
    match pol {
      'p  => 'n
    | 'n  => 'p
    | 'pn => 'pn}

(define (positive-pol? pol)
  (equal? pol 'p))

(define (negative-pol? pol)
  (equal? pol 'n))

(define (subprop p pos)
  (match [p pos]
    ([_ []] p)
    ([((some-sent-con _) (some-list props)) (list-of i rest)] (subprop (ith props i) rest))
    ([((some-quant q) (some-var _) (some-sentence q)) (list-of 2 rest)] (subprop q rest))))

(define (polarities p q)
  (let ((prepend-and-process (lambda (i f)
                               (lambda (pos-pol-pair)
                                 (match pos-pol-pair
                                   ([pos pol] [(add i pos) (f pol)])))))
        (id (lambda (x) x))
        (make-pos-neg (lambda (_) 'pn)))
    (match q 
      ((val-of p) [[[] 'p]])
      ((not q1) (map (prepend-and-process 1 flip)
                     (polarities p q1)))
      ((if q1 q2) (join (map (prepend-and-process 1 flip) 
                             (polarities p q1))
                        (map (prepend-and-process 2 id)
                             (polarities p q2))))
      ((iff q1 q2) (join (map (prepend-and-process 1 make-pos-neg)
                              (polarities p q1))
                         (map (prepend-and-process 2 make-pos-neg)
                              (polarities p q2))))
      (((some-sent-con _) (some-list props))
        (let ((i (cell 1)))
          (flatten (map (lambda (q)
                          (map (prepend-and-process (inc i) id) 
                               (polarities p q)))
                        props))))
      (((some-quant _) (some-var _) (some-sentence body)) 
          (map (prepend-and-process 2 id)
               (polarities p body)))
      (_ []))))

define (extend-map M k v) := 
  let {res := try { (M k) | [] }}
    (Map.add M [[k (add v res)]])
      
# (sub-sentence-map p) returns a dictionary that maps every subsentence q of p
# to a list of pairs of the form [position polarity], where position is a Dewey path
# indicating the position of q in p (viewing p as a tree) and polarity indicates the polarity of q in p.
# A list of such pairs is returned because a single subsentence may have multiple occurrences in p. 

define (sub-sentence-map p) :=
  letrec {loop := lambda (p pos pol M) 
                    match p {
                      (~ q) => (loop q (join pos [1]) (flip pol) (extend-map M p [pos pol]))
                    | (and (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (or (some-list args)) =>
                        (loop* args
                               pos
                               pol
                               (extend-map M p [pos pol])
                               1)
                    | (if p1 p2) => (loop p2
                                          (join pos [2])
                                          pol 
                                          (loop p1
                                               (join pos [1])
                                               (flip pol)
                                               (extend-map M p [pos pol])))
                    | (iff p1 p2) => let {M1 := (loop p1 (join pos [1]) 'pn M);
                                          M2 := (loop p2 (join pos [2]) 'pn M1)}
                                      (extend-map M2 p [pos pol])
                    | _ => (extend-map M p [pos pol])
                    };
          loop* := lambda (props pos pol M i) 
                     match props {
                       [] => M
                     | (list-of p more) =>
                          (loop* more
                                 pos
                                 pol
                                 (loop p (join pos [i]) pol M)
                                 (plus i 1))
                     }}
   (loop p [] 'p |{}|)

define (polarities-and-positions p q) :=
    let {prepend-and-process := 
           lambda (i f)
             lambda (pos-pol-pair)
               match pos-pol-pair {
                 [pos pol] => [(add i pos) (f pol)]
               };
         id := lambda (x) x;
         make-pos-neg := lambda (_) 'pn}
      match q {
        (val-of p) => [[[] 'p]]
      | (~ q1) => (map (prepend-and-process 1 flip)
                       (polarities-and-positions p q1))
      | (q1 ==> q2) =>  (join (map (prepend-and-process 1 flip) 
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 id)
                                   (polarities-and-positions p q2)))
      | (q1 <==> q2) => (join (map (prepend-and-process 1 make-pos-neg)
                                   (polarities-and-positions p q1))
                              (map (prepend-and-process 2 make-pos-neg)
                                   (polarities-and-positions p q2)))
      | ((some-sent-con _) (some-list args)) =>
          let {i := (cell 1)}
            (flatten (map lambda (q)
                             (map (prepend-and-process (inc i) id)
                                  (polarities-and-positions p q))
                          args))
      | _ => []
      }


define (get-disjuncts-and-their-positions p) :=
  letrec {loop := lambda (p path)
                    match p {
                      (or (some-list args)) =>
                         let {index := (cell 1)}
                          (fold join
                                (map lambda (arg)
                                       (loop arg (add (inc index) path))
                                     args)
                                [])                                     
                    | _ => [[p path]]
                    }}
    (loop p [])

define (get-conjuncts-and-their-positions p) :=
  letrec {loop := lambda (p path)
                    match p {
                      (and (some-list args)) =>
                         let {index := (cell 1)}
                          (fold join
                                (map lambda (arg)
                                       (loop arg (add (inc index) path))
                                     args)
                                [])                                     
                    | _ => [[p path]]
                    }}
    (loop p [])
    
(define (fpm r q p q-parent q-parent-pos q-pos q-pol)
# Note: r and p (the target sentence and the sentence being searched) do not vary at all from call to call below - they're constant.
# Only q, and q-parent vary (along with their positions and polarities) from call to call. 
# A more efficient/cleaner implementation would implement the recursive search via an internal procedure that did not take r and p as arguments.
# The final output is a list of search results, each of this form: [q q-pos theta q-parent q-parent-pos p]
  (match (match-props r q)
    ((some-sub theta) (check ((negative-pol? q-pol) [])
                             (else [[q (rev q-pos) theta q-parent (rev q-parent-pos) p]])))
    (_ (match q 
         ((not q') (fpm r q' p q q-pos (add 1 q-pos) (flip q-pol)))
         ((if q1 q2) (join (fpm r q1 p q q-pos (add 1 q-pos) (flip q-pol))
                           (fpm r q2 p q q-pos (add 2 q-pos) q-pol)))
         ((iff q1 q2) (join (fpm r q1 p q q-pos (add 1 q-pos) 'pn)
                            (fpm r q2 p q q-pos (add 2 q-pos) 'pn)))

         ((or (some-list _))
           (let ((disjuncts-and-their-positions (get-disjuncts-and-their-positions q))
                 (i (cell 1)))
             (flatten (map (lambda (disjunct-and-its-position)
                             (let (([q_i q_i_pos] disjunct-and-its-position))
                               (fpm r q_i p q q-pos (join q_i_pos q-pos) q-pol)))
                           disjuncts-and-their-positions))))

         ((and (some-list _))
           (let ((conjuncts-and-their-positions (get-conjuncts-and-their-positions q))
                 (i (cell 1)))
             (flatten (map (lambda (conjunct-and-its-position)
                             (let (([q_i q_i_pos] conjunct-and-its-position))
                               (fpm r q_i p q q-pos (join q_i_pos q-pos) q-pol)))
                           conjuncts-and-their-positions))))
                            
         (((some-sent-con pc) (some-list props)) 
           (let ((i (cell 1)))
             (flatten (map (lambda (q_i)
                             (fpm r q_i p q q-pos (add (inc i) q-pos) q-pol))
                           props))))
                           
         ((forall (some-var _) (some-sentence body))
            (check ((negative-pol? q-pol) [])
                   (else (fpm r body p q q-pos (add 2 q-pos) q-pol))))
         ((exists (some-var _) (some-sentence body))
            (check ((positive-pol? q-pol) [])
                   (else (fpm r body p q q-pos (add 2 q-pos) q-pol))))
         ((exists-unique (some-var _) (some-sentence body))
            (check ((positive-pol? q-pol) [])
                   (else (fpm r body p q q-pos (add 2 q-pos) q-pol))))                   
         (_ [])))))

(define (show-result p r res)
  (match res
    ([q q-pos theta q-parent q-parent-pos _]
          (seq (println "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[")
               (print "Given target: ") (writeln-val r)
               (print "\nGiven base prop (p) to search: ") (writeln-val p)
               (print "\nThe target matched the following subsentence of p, call it q: ") (writeln-val q)
               (print "\nIn position: ") (writeln-val q-pos)
               (print "\nThe matching sub: ") (writeln-val theta)                
               (print "\nThe parent of q: ") (writeln-val q-parent)
               (print "\nAnd the parent's position: ") (writeln-val q-parent-pos)
               (print "]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")))))

define (all-universal-occurrences r p positive?) :=
# This will return a list of all *universal* occurrences of a generalized version of r, call it q, inside p.
# By a generalized version we mean that r must match q under some theta. The positive? boolean flag determines
# whether the returned occurrences are positive in p (or negative, respectively). Thus,
# (find-universal-occurrences (Q a) (forall x . P x & Q x) true) should return [2 2] under {?x -> a} as the
# sole match, but (find-universal-occurrences (Q a) (forall x . P x & Q x) false) would be asking for universally
# negative occurrences of (Q a) inside the base (forall x . P x & Q x), and there are no such occurrences, so
# in that case the empty list should be returned.
  let {prohibited-polarity? := lambda (pol)
                                 check {positive? => (negative-pol? pol)
                                      | else      => (positive-pol? pol)}}
    letrec {loop := lambda (q q-pos q-pol)
                      match (match-props r q) {     
                        (some-sub theta) => check {(prohibited-polarity? q-pol) => [] 
                                                 | else => [|{'matching-subsentence := q, 'matching-pos := (rev q-pos), 'theta := theta, 'base-sentence := p}|]}
                      | _ => match q {
                               (not q')            => (loop q' (add 1 q-pos) (flip q-pol))
                                 
                             | (if q1 q2)          => (join (loop q1 (add 1 q-pos) (flip q-pol))
                                                            (loop q2 (add 2 q-pos) q-pol))
                             | (iff q1 q2)         => (join (loop q1 (add 1 q-pos) 'pn)
                                                            (loop q2 (add 2 q-pos) 'pn))
                             | (and (some-list _)) => let {conjuncts-and-their-positions := (get-conjuncts-and-their-positions q)}
                                                        (flatten (map lambda (conjunct-and-its-position)
                                                                         let {[q_i q_i_pos] := conjunct-and-its-position}
                                                                           (loop q_i q_i_pos q-pol)
                                                                      conjuncts-and-their-positions))
                             | (or (some-list _))  => let {disjuncts-and-their-positions := (get-disjuncts-and-their-positions q)}
                                                        (flatten (map lambda (disjunct-and-its-position)
                                                                         let {[q_i q_i_pos] := disjunct-and-its-position}
                                                                           (loop q_i q_i_pos q-pol)
                                                                      disjuncts-and-their-positions))
                             | (forall (some-var _) (some-sentence body)) =>
                                  check {(negative-pol? q-pol) => []
                                       | else => (loop body (add 2 q-pos) q-pol)}
                             | ((|| exists exists-unique) (some-var _) (some-sentence body)) =>
                                  check {(positive-pol? q-pol) => []
                                       | else => (loop body (add 2 q-pos) q-pol)}
                             | _ => []                                     
                             }
                      }}
        (loop p [] 'p)

define (all-universally-positive-occurrences r p) := (all-universal-occurrences r p true)

define (all-universally-negative-occurrences r p) := (all-universal-occurrences r p false)

define (all-universally-positive-occurrences* r props) :=
  (flatten (map lambda (p)
                  (all-universally-positive-occurrences r p)
                props))                  

define (find-universally-positive-occurrence target base) :=
# If there are no universally positive occurrences of the given target in base, then this will return ().
   match (all-universally-positive-occurrences target base) {
     (list-of (some-map D) _) => D
   | _ => ()
   }

define (find-universally-negative-occurrence target base) :=
# If there are no universally negative occurrences of the given target in base, then this will return ().
   match (all-universally-negative-occurrences target base) {
     (list-of (some-map D) _) => D
   | _ => ()
   }

define (find-universally-positive-occurrence* target props) :=
# Find the *first* match among all props. If there are none, return (): 
    (find-element' 
       props
       lambda (D)
         (unequal? D ())
       lambda (p) (find-universally-positive-occurrence target p)         
       lambda (x) x
       lambda () ())

define (find-universally-negative-occurrence* target props) :=
# Find the *first* match among all props. If there are none, return (): 
    (find-element' 
       props
       lambda (D)
         (unequal? D ())
       lambda (p) (find-universally-negative-occurrence target p)         
       lambda (x) x
       lambda () ())
       
define (list->sub result) :=
  match result {
    [q q-pos theta q-parent q-parent-pos _] =>
      |{'matching-subsentence := q,
        'matching-subsentence-position := q-pos,
        'theta := theta,
        'match-parent := q-parent,
        'match-parent-position := q-parent-pos
      }|    
  }
  
define (find-proper-matches r p) := (map list->sub (fpm r p p p [] [] 'p))

define (top-level-match? D) := ((D 'matching-subsentence-position) equals? [])

define (find-proper-matches* r props) :=
  letrec {loop := lambda (props results)
                    match props {
                      [] => (rev results)
                    | (list-of p more) =>
                        match (find-proper-matches r p) {
                          [] => (loop more results)
                        | (results' as (list-of D _)) =>
                            check {(top-level-match? D) => [D]
                                 | else => (loop more (join results' results))}
                        }
                    }}
     (loop props [])

define (positive-in-ab? p props) :=
  match (find-proper-matches* p props) {
      [] => false
    | _ => true
  }
                 
define (ufv p subsentence-position) :=
# This computes UFV(q,p) where q is the unique subsentence of p at subsentence-position: 
  let {p-fvars := (fv p);
       q-fvars := (fv (subprop p subsentence-position))}
   (list-diff q-fvars p-fvars)

define (find-universally-positive-parent goal premise) :=
  let {compromise-result := (cell ());
       update-theta := lambda (D)
                         let {parent-ufvs := (ufv premise (D 'match-parent-position));
                              theta       := (D 'theta);
                              extra-fvs := (list-diff parent-ufvs (supp theta))}
                           (extend-sub theta (map lambda (extra-fv) [extra-fv (fresh-var (sort-of extra-fv))]
                                                  extra-fvs));
       update-compromise := lambda (D)
                              check {(equal? (ref compromise-result) ()) =>
                                       (set! compromise-result [(D 'match-parent) (D 'match-parent-position)  (update-theta D)])
                                   | else => ()}}
    (find-element 
       (find-proper-matches goal premise) 
       lambda (D)
          let {theta                 := (D 'theta);
               match-pos             := (D 'matching-subsentence-position);
               ufv-vars              := (ufv premise match-pos);
               match-parent          := (D 'match-parent);
               match-parent-position := (D 'match-parent-position);
               support               := (supp theta)}
            check {(subset? support ufv-vars) =>
                      let {_           := (update-compromise D);
                           parent-ufvs := (ufv premise match-parent-position)}
                        (subset? parent-ufvs support)
                 | else => false}                      
       lambda (D) [(D 'match-parent) (D 'match-parent-position) (D 'theta)]
       lambda () (ref compromise-result))

       
# Find a universally positive subsentence of the premise, call it q, that is a parent of the given goal.
# Return a pair of q and the position of q in the given premise. 
# If no such subsentence exists, return ().
# If more than one such subsentence exists, return the first one (in a DFS ordering of all subsentences of the premise).

  # let {subsentence-map := (sub-sentence-map premise);
  #      parent? := lambda (parent child)
  #                   (member? child (children parent));
  #      complex-non-negation := lambda (p)
  #                                (|| (conjunction? p) (disjunction? p) (conditional? p) (biconditional? p));
  #      positive?       := lambda (position-polarity-pair)
  #                           (member? (second position-polarity-pair)
  #                                    ['p 'pn])}
  #   (find-element' (Map.keys subsentence-map)
  #                  lambda (ss-pos-pair)
  #                    let {[ss pos] := ss-pos-pair}
  #                      (&& (parent? ss goal)
  #                          (complex-non-negation ss)
  #                          (for-some (subsentence-map ss) positive?))
  #                  lambda (ss) [ss (first (first (subsentence-map ss)))]
  #                  lambda (ss-pair) ss-pair
  #                  lambda () ())                      

   
}


EOF

declare zero:Int
declare succ: [Int] -> Int
declare pos: [Int] -> Boolean
declare a, b, c: Int

define goal := (zero < succ a)

define p1 := (forall x y . x < y ==> pos y)
define p2 := (forall x . zero < succ x) 


(Polarities.find-universally-positive-parent (zero < succ a) p2)

(Polarities.find-universally-positive-parent (pos succ a) p1)

Need to prove: (?vf < succ a)
{?vf:Int --> zero
?x:Int --> a}


(Polarities.find-universally-positive-parent (?vf < succ a) p2)