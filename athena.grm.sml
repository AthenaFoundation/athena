functor AthenaLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : Athena_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
(*==================================================

Athena's Yacc grammar.

===================================================*)

structure A = AbstractSyntax
structure N = Names
structure S = Symbol
structure MS = ModSymbol

type pos = int * int

fun getPos((l,p)) = {line=l,pos=p,file=(!Paths.current_file)}


end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\001\000\059\006\002\000\059\006\003\000\059\006\004\000\059\006\
\\005\000\059\006\006\000\059\006\012\000\059\006\013\000\059\006\
\\014\000\059\006\015\000\059\006\016\000\059\006\024\000\059\006\
\\025\000\059\006\028\000\059\006\033\000\059\006\034\000\059\006\
\\035\000\059\006\039\000\048\001\040\000\059\006\041\000\059\006\
\\042\000\059\006\043\000\059\006\044\000\059\006\047\000\059\006\
\\050\000\059\006\051\000\059\006\052\000\059\006\053\000\059\006\
\\055\000\059\006\056\000\059\006\059\000\059\006\060\000\059\006\
\\061\000\059\006\062\000\059\006\064\000\059\006\065\000\059\006\
\\066\000\059\006\068\000\059\006\070\000\059\006\071\000\059\006\
\\074\000\059\006\075\000\059\006\076\000\059\006\077\000\059\006\
\\079\000\059\006\080\000\059\006\087\000\059\006\090\000\059\006\
\\091\000\059\006\092\000\059\006\094\000\059\006\098\000\059\006\
\\107\000\079\007\108\000\059\006\118\000\059\006\119\000\059\006\
\\120\000\059\006\126\000\059\006\128\000\059\006\130\000\059\006\
\\133\000\059\006\137\000\059\006\138\000\059\006\139\000\059\006\
\\141\000\059\006\142\000\059\006\150\000\059\006\152\000\059\006\
\\156\000\059\006\157\000\059\006\160\000\059\006\161\000\059\006\
\\163\000\059\006\165\000\059\006\166\000\059\006\171\000\059\006\
\\173\000\059\006\175\000\059\006\176\000\059\006\177\000\059\006\
\\178\000\059\006\179\000\059\006\182\000\059\006\183\000\059\006\
\\184\000\059\006\185\000\059\006\187\000\059\006\000\000\
\\001\000\002\000\059\006\003\000\059\006\004\000\059\006\005\000\059\006\
\\006\000\059\006\039\000\048\001\052\000\059\006\055\000\059\006\
\\056\000\059\006\061\000\059\006\064\000\059\006\076\000\059\006\
\\077\000\059\006\079\000\059\006\080\000\059\006\092\000\059\006\
\\094\000\059\006\098\000\059\006\107\000\080\007\108\000\059\006\
\\137\000\059\006\156\000\059\006\157\000\059\006\161\000\059\006\
\\173\000\059\006\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\007\000\055\002\013\000\102\000\024\000\098\000\
\\025\000\097\000\034\000\094\000\047\000\087\000\050\000\086\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\061\000\080\000\
\\062\000\079\000\064\000\115\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\073\000\077\000\072\000\
\\079\000\071\000\080\000\070\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\137\000\055\000\
\\138\000\054\000\156\000\048\000\157\000\047\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\173\000\040\000\
\\177\000\037\000\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\012\000\103\000\013\000\102\000\014\000\101\000\
\\015\000\100\000\016\000\099\000\024\000\098\000\025\000\097\000\
\\028\000\096\000\033\000\095\000\034\000\094\000\035\000\093\000\
\\040\000\092\000\041\000\091\000\042\000\090\000\043\000\089\000\
\\044\000\088\000\047\000\087\000\050\000\086\000\051\000\085\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\059\000\081\000\
\\061\000\080\000\062\000\079\000\064\000\078\000\068\000\077\000\
\\070\000\076\000\074\000\075\000\075\000\074\000\076\000\073\000\
\\077\000\072\000\079\000\071\000\080\000\070\000\087\000\069\000\
\\090\000\068\000\091\000\067\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\118\000\062\000\119\000\061\000\
\\120\000\060\000\126\000\059\000\128\000\058\000\130\000\057\000\
\\133\000\056\000\137\000\055\000\138\000\054\000\139\000\053\000\
\\141\000\052\000\142\000\051\000\150\000\050\000\152\000\049\000\
\\156\000\048\000\157\000\047\000\160\000\046\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\171\000\041\000\
\\173\000\040\000\175\000\039\000\176\000\038\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\183\000\033\000\
\\184\000\032\000\185\000\031\000\187\000\030\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\030\000\062\002\034\000\094\000\047\000\087\000\050\000\086\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\061\000\080\000\
\\062\000\079\000\064\000\115\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\073\000\077\000\072\000\
\\079\000\071\000\080\000\070\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\137\000\055\000\
\\138\000\054\000\156\000\048\000\157\000\047\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\173\000\040\000\
\\177\000\037\000\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\065\000\061\004\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\073\000\077\000\072\000\
\\079\000\071\000\080\000\070\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\137\000\055\000\
\\138\000\054\000\156\000\048\000\157\000\047\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\173\000\040\000\
\\177\000\037\000\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\107\000\000\005\108\000\063\000\137\000\055\000\
\\138\000\054\000\156\000\048\000\157\000\047\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\173\000\040\000\
\\177\000\037\000\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\045\001\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\116\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\114\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\173\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\178\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\177\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\228\001\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\177\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\137\003\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\022\001\
\\006\000\104\000\009\000\020\001\010\000\019\001\011\000\018\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\005\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\115\000\
\\065\000\001\001\068\000\077\000\070\000\000\001\074\000\255\000\
\\075\000\254\000\076\000\253\000\077\000\252\000\079\000\071\000\
\\080\000\250\000\084\000\247\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\110\000\238\000\
\\116\000\237\000\137\000\055\000\138\000\228\000\140\000\251\003\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\217\000\
\\165\000\215\000\166\000\214\000\173\000\040\000\177\000\207\000\
\\178\000\206\000\179\000\205\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\022\001\
\\006\000\104\000\009\000\020\001\010\000\019\001\011\000\018\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\005\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\115\000\
\\065\000\001\001\068\000\077\000\070\000\000\001\074\000\255\000\
\\075\000\254\000\076\000\253\000\077\000\252\000\079\000\071\000\
\\080\000\250\000\084\000\247\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\110\000\238\000\
\\116\000\237\000\137\000\055\000\138\000\228\000\140\000\036\005\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\217\000\
\\165\000\215\000\166\000\214\000\173\000\040\000\177\000\207\000\
\\178\000\206\000\179\000\205\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\022\001\
\\006\000\104\000\009\000\020\001\010\000\019\001\011\000\018\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\005\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\115\000\
\\065\000\001\001\068\000\077\000\070\000\000\001\074\000\255\000\
\\075\000\254\000\076\000\253\000\077\000\252\000\079\000\071\000\
\\080\000\250\000\084\000\247\000\087\000\069\000\092\000\066\000\
\\094\000\065\000\098\000\064\000\108\000\063\000\110\000\238\000\
\\116\000\237\000\137\000\055\000\138\000\228\000\156\000\048\000\
\\157\000\047\000\161\000\045\000\163\000\217\000\165\000\215\000\
\\166\000\214\000\173\000\040\000\177\000\207\000\178\000\206\000\
\\179\000\205\000\182\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\103\001\
\\006\000\104\000\052\000\084\000\055\000\102\001\056\000\082\000\
\\061\000\080\000\064\000\101\001\076\000\100\001\077\000\099\001\
\\079\000\071\000\080\000\098\001\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\156\000\048\000\
\\157\000\047\000\161\000\045\000\173\000\040\000\000\000\
\\001\000\002\000\025\001\003\000\024\001\004\000\023\001\005\000\022\001\
\\006\000\021\001\009\000\020\001\010\000\019\001\011\000\018\001\
\\012\000\017\001\013\000\102\000\014\000\016\001\015\000\015\001\
\\016\000\014\001\024\000\098\000\025\000\097\000\028\000\013\001\
\\033\000\012\001\034\000\094\000\035\000\011\001\040\000\010\001\
\\041\000\009\001\042\000\008\001\047\000\087\000\048\000\007\001\
\\050\000\086\000\051\000\006\001\052\000\084\000\055\000\005\001\
\\056\000\004\001\059\000\003\001\061\000\002\001\062\000\079\000\
\\064\000\115\000\065\000\001\001\068\000\077\000\070\000\000\001\
\\074\000\255\000\075\000\254\000\076\000\253\000\077\000\252\000\
\\079\000\251\000\080\000\250\000\081\000\249\000\082\000\248\000\
\\084\000\247\000\085\000\246\000\087\000\069\000\090\000\245\000\
\\091\000\244\000\092\000\243\000\093\000\242\000\094\000\241\000\
\\095\000\240\000\098\000\239\000\108\000\063\000\110\000\238\000\
\\116\000\237\000\118\000\236\000\119\000\235\000\120\000\234\000\
\\126\000\233\000\128\000\232\000\129\000\231\000\130\000\230\000\
\\133\000\229\000\137\000\055\000\138\000\228\000\139\000\227\000\
\\141\000\226\000\142\000\225\000\150\000\224\000\152\000\223\000\
\\153\000\222\000\156\000\221\000\157\000\220\000\160\000\219\000\
\\161\000\218\000\163\000\217\000\164\000\216\000\165\000\215\000\
\\166\000\214\000\167\000\213\000\168\000\212\000\171\000\211\000\
\\173\000\210\000\175\000\209\000\176\000\208\000\177\000\207\000\
\\178\000\206\000\179\000\205\000\182\000\034\000\183\000\204\000\
\\184\000\203\000\185\000\202\000\187\000\201\000\000\000\
\\001\000\002\000\025\001\003\000\024\001\004\000\023\001\005\000\022\001\
\\006\000\021\001\009\000\020\001\010\000\019\001\011\000\018\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\048\000\007\001\050\000\086\000\052\000\084\000\
\\055\000\005\001\056\000\004\001\061\000\002\001\062\000\079\000\
\\064\000\115\000\065\000\001\001\068\000\077\000\070\000\000\001\
\\074\000\255\000\075\000\254\000\076\000\253\000\077\000\252\000\
\\079\000\251\000\080\000\250\000\081\000\249\000\082\000\248\000\
\\084\000\247\000\085\000\246\000\087\000\069\000\092\000\243\000\
\\093\000\242\000\094\000\241\000\095\000\240\000\098\000\239\000\
\\108\000\063\000\110\000\238\000\116\000\237\000\137\000\055\000\
\\138\000\228\000\156\000\221\000\157\000\220\000\161\000\218\000\
\\163\000\217\000\164\000\216\000\165\000\215\000\166\000\214\000\
\\173\000\210\000\177\000\207\000\178\000\206\000\179\000\205\000\
\\182\000\034\000\000\000\
\\001\000\002\000\111\002\003\000\110\002\004\000\109\002\005\000\125\000\
\\006\000\108\002\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\048\000\007\001\050\000\086\000\
\\055\000\124\000\056\000\107\002\061\000\106\002\062\000\079\000\
\\064\000\123\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\122\000\077\000\121\000\079\000\105\002\
\\080\000\120\000\081\000\249\000\082\000\248\000\085\000\246\000\
\\087\000\069\000\092\000\104\002\093\000\242\000\094\000\103\002\
\\095\000\240\000\098\000\102\002\138\000\054\000\156\000\101\002\
\\157\000\100\002\161\000\099\002\163\000\044\000\164\000\216\000\
\\165\000\043\000\166\000\042\000\173\000\098\002\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\124\000\062\000\079\000\064\000\123\000\068\000\077\000\
\\070\000\076\000\074\000\075\000\075\000\074\000\076\000\122\000\
\\077\000\121\000\080\000\120\000\087\000\069\000\137\000\189\000\
\\138\000\054\000\163\000\044\000\165\000\043\000\166\000\042\000\
\\177\000\037\000\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\123\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\107\000\111\005\138\000\054\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\123\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\252\002\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\246\004\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\182\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\123\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\001\000\005\000\125\000\013\000\102\000\024\000\030\001\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\123\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\001\000\010\000\168\002\018\000\167\002\019\000\166\002\020\000\165\002\
\\021\000\164\002\022\000\163\002\023\000\162\002\024\000\161\002\
\\025\000\128\001\026\000\160\002\027\000\159\002\034\000\127\001\
\\037\000\158\002\038\000\157\002\045\000\156\002\046\000\155\002\
\\047\000\126\001\048\000\125\001\050\000\124\001\057\000\154\002\
\\064\000\123\001\065\000\153\002\068\000\122\001\073\000\152\002\
\\083\000\151\002\086\000\150\002\110\000\149\002\111\000\148\002\
\\115\000\147\002\116\000\146\002\121\000\145\002\122\000\144\002\
\\123\000\143\002\124\000\142\002\125\000\141\002\147\000\140\002\
\\154\000\139\002\158\000\138\002\159\000\137\002\182\000\121\001\000\000\
\\001\000\011\000\112\003\024\000\091\003\000\000\
\\001\000\011\000\076\004\024\000\091\003\000\000\
\\001\000\011\000\199\004\000\000\
\\001\000\011\000\001\005\000\000\
\\001\000\013\000\102\000\024\000\129\000\000\000\
\\001\000\013\000\102\000\024\000\129\000\064\000\132\000\000\000\
\\001\000\013\000\102\000\024\000\129\000\064\000\177\001\000\000\
\\001\000\013\000\102\000\024\000\129\000\065\000\063\003\000\000\
\\001\000\024\000\191\005\025\000\191\005\034\000\191\005\039\000\065\002\
\\047\000\191\005\048\000\191\005\050\000\191\005\064\000\191\005\
\\068\000\191\005\071\000\087\007\182\000\191\005\000\000\
\\001\000\024\000\066\007\039\000\079\007\064\000\066\007\065\000\066\007\000\000\
\\001\000\024\000\138\000\000\000\
\\001\000\024\000\138\000\064\000\190\001\000\000\
\\001\000\024\000\138\000\064\000\204\001\000\000\
\\001\000\024\000\153\000\000\000\
\\001\000\024\000\158\000\064\000\157\000\000\000\
\\001\000\024\000\162\000\064\000\161\000\000\000\
\\001\000\024\000\165\000\064\000\164\000\068\000\163\000\000\000\
\\001\000\024\000\166\000\000\000\
\\001\000\024\000\034\001\025\000\033\001\000\000\
\\001\000\024\000\035\001\000\000\
\\001\000\024\000\061\001\000\000\
\\001\000\024\000\061\001\064\000\019\002\000\000\
\\001\000\024\000\062\001\000\000\
\\001\000\024\000\066\001\000\000\
\\001\000\024\000\066\001\025\000\128\001\034\000\127\001\047\000\126\001\
\\048\000\125\001\050\000\124\001\064\000\123\001\068\000\122\001\
\\131\000\161\003\182\000\121\001\000\000\
\\001\000\024\000\066\001\025\000\128\001\034\000\127\001\047\000\126\001\
\\048\000\125\001\050\000\124\001\064\000\123\001\068\000\122\001\
\\182\000\121\001\000\000\
\\001\000\024\000\066\001\182\000\117\002\000\000\
\\001\000\024\000\104\001\000\000\
\\001\000\024\000\114\001\000\000\
\\001\000\024\000\116\001\000\000\
\\001\000\024\000\129\001\000\000\
\\001\000\024\000\200\001\064\000\199\001\000\000\
\\001\000\024\000\206\001\064\000\205\001\000\000\
\\001\000\024\000\216\001\064\000\215\001\068\000\214\001\000\000\
\\001\000\024\000\217\001\000\000\
\\001\000\024\000\220\001\000\000\
\\001\000\024\000\221\001\000\000\
\\001\000\024\000\020\002\000\000\
\\001\000\024\000\029\002\000\000\
\\001\000\024\000\031\002\000\000\
\\001\000\024\000\042\002\050\000\041\002\064\000\040\002\000\000\
\\001\000\024\000\042\002\050\000\041\002\064\000\074\002\000\000\
\\001\000\024\000\042\002\050\000\041\002\064\000\110\003\000\000\
\\001\000\024\000\047\002\064\000\046\002\068\000\045\002\000\000\
\\001\000\024\000\089\002\025\000\128\001\034\000\127\001\047\000\126\001\
\\048\000\125\001\050\000\124\001\064\000\123\001\068\000\122\001\
\\182\000\121\001\000\000\
\\001\000\024\000\126\002\064\000\255\002\000\000\
\\001\000\024\000\126\002\064\000\097\004\000\000\
\\001\000\024\000\126\002\064\000\170\004\000\000\
\\001\000\024\000\131\002\064\000\130\002\000\000\
\\001\000\024\000\169\002\000\000\
\\001\000\024\000\171\002\000\000\
\\001\000\024\000\187\002\182\000\186\002\000\000\
\\001\000\024\000\243\002\000\000\
\\001\000\024\000\250\002\000\000\
\\001\000\024\000\001\003\000\000\
\\001\000\024\000\014\003\000\000\
\\001\000\024\000\066\003\064\000\065\003\068\000\064\003\000\000\
\\001\000\024\000\091\003\000\000\
\\001\000\024\000\092\003\000\000\
\\001\000\024\000\096\003\000\000\
\\001\000\024\000\140\003\000\000\
\\001\000\024\000\152\003\109\000\151\003\000\000\
\\001\000\024\000\155\003\000\000\
\\001\000\024\000\171\003\000\000\
\\001\000\024\000\172\003\000\000\
\\001\000\024\000\174\003\000\000\
\\001\000\024\000\183\003\000\000\
\\001\000\024\000\000\004\109\000\151\003\000\000\
\\001\000\024\000\003\004\000\000\
\\001\000\024\000\006\004\000\000\
\\001\000\024\000\043\004\000\000\
\\001\000\024\000\078\004\000\000\
\\001\000\024\000\138\004\000\000\
\\001\000\024\000\165\004\000\000\
\\001\000\024\000\206\004\000\000\
\\001\000\024\000\208\004\065\000\207\004\000\000\
\\001\000\024\000\020\005\000\000\
\\001\000\024\000\024\005\065\000\023\005\000\000\
\\001\000\024\000\041\005\000\000\
\\001\000\024\000\047\005\065\000\046\005\000\000\
\\001\000\024\000\060\005\065\000\059\005\000\000\
\\001\000\024\000\086\005\068\000\085\005\184\000\084\005\185\000\083\005\000\000\
\\001\000\024\000\099\005\068\000\085\005\069\000\098\005\000\000\
\\001\000\024\000\105\005\068\000\085\005\069\000\104\005\184\000\084\005\
\\185\000\083\005\000\000\
\\001\000\024\000\119\005\068\000\085\005\069\000\118\005\000\000\
\\001\000\024\000\123\005\068\000\085\005\069\000\122\005\000\000\
\\001\000\024\000\128\005\068\000\085\005\069\000\127\005\184\000\084\005\
\\185\000\083\005\000\000\
\\001\000\024\000\132\005\068\000\085\005\184\000\084\005\185\000\083\005\000\000\
\\001\000\024\000\150\005\065\000\149\005\068\000\085\005\000\000\
\\001\000\024\000\155\005\065\000\154\005\068\000\085\005\184\000\084\005\
\\185\000\083\005\000\000\
\\001\000\024\000\164\005\065\000\163\005\068\000\085\005\000\000\
\\001\000\024\000\167\005\065\000\166\005\068\000\085\005\000\000\
\\001\000\024\000\172\005\065\000\171\005\068\000\085\005\184\000\084\005\
\\185\000\083\005\000\000\
\\001\000\025\000\094\001\000\000\
\\001\000\025\000\234\002\000\000\
\\001\000\029\000\072\001\058\000\071\001\096\000\070\001\000\000\
\\001\000\029\000\095\001\000\000\
\\001\000\029\000\135\001\052\000\084\000\137\000\134\001\000\000\
\\001\000\030\000\060\002\000\000\
\\001\000\030\000\062\002\000\000\
\\001\000\037\000\066\004\000\000\
\\001\000\037\000\190\004\000\000\
\\001\000\039\000\113\001\000\000\
\\001\000\039\000\020\003\065\000\019\003\000\000\
\\001\000\039\000\221\004\000\000\
\\001\000\047\000\249\003\064\000\248\003\000\000\
\\001\000\052\000\084\000\000\000\
\\001\000\052\000\084\000\064\000\240\001\000\000\
\\001\000\052\000\084\000\064\000\241\001\000\000\
\\001\000\052\000\084\000\064\000\249\001\000\000\
\\001\000\052\000\084\000\064\000\250\001\000\000\
\\001\000\052\000\084\000\096\000\093\001\137\000\092\001\000\000\
\\001\000\052\000\084\000\137\000\189\000\000\000\
\\001\000\052\000\084\000\137\000\106\001\000\000\
\\001\000\052\000\084\000\137\000\108\001\000\000\
\\001\000\052\000\084\000\137\000\159\001\000\000\
\\001\000\052\000\084\000\137\000\203\003\000\000\
\\001\000\053\000\068\001\000\000\
\\001\000\058\000\172\001\000\000\
\\001\000\063\000\022\002\000\000\
\\001\000\064\000\136\000\000\000\
\\001\000\064\000\146\000\000\000\
\\001\000\064\000\193\000\000\000\
\\001\000\064\000\194\000\000\000\
\\001\000\064\000\036\001\000\000\
\\001\000\064\000\039\001\000\000\
\\001\000\064\000\053\001\126\000\052\001\000\000\
\\001\000\064\000\181\001\000\000\
\\001\000\064\000\192\001\000\000\
\\001\000\064\000\209\001\000\000\
\\001\000\064\000\224\001\000\000\
\\001\000\064\000\240\001\000\000\
\\001\000\064\000\243\001\000\000\
\\001\000\064\000\244\001\000\000\
\\001\000\064\000\249\001\000\000\
\\001\000\064\000\009\002\000\000\
\\001\000\064\000\019\002\000\000\
\\001\000\064\000\012\003\000\000\
\\001\000\064\000\058\004\000\000\
\\001\000\064\000\175\004\000\000\
\\001\000\064\000\248\004\000\000\
\\001\000\064\000\058\005\000\000\
\\001\000\065\000\201\001\000\000\
\\001\000\065\000\248\001\000\000\
\\001\000\065\000\251\001\000\000\
\\001\000\065\000\004\002\000\000\
\\001\000\065\000\079\002\000\000\
\\001\000\065\000\081\002\000\000\
\\001\000\065\000\212\002\000\000\
\\001\000\065\000\214\002\000\000\
\\001\000\065\000\216\002\000\000\
\\001\000\065\000\220\002\000\000\
\\001\000\065\000\221\002\000\000\
\\001\000\065\000\222\002\000\000\
\\001\000\065\000\235\002\000\000\
\\001\000\065\000\236\002\000\000\
\\001\000\065\000\246\002\000\000\
\\001\000\065\000\247\002\000\000\
\\001\000\065\000\248\002\000\000\
\\001\000\065\000\249\002\000\000\
\\001\000\065\000\003\003\162\000\002\003\000\000\
\\001\000\065\000\004\003\000\000\
\\001\000\065\000\009\003\000\000\
\\001\000\065\000\010\003\000\000\
\\001\000\065\000\017\003\000\000\
\\001\000\065\000\018\003\000\000\
\\001\000\065\000\021\003\000\000\
\\001\000\065\000\029\003\000\000\
\\001\000\065\000\030\003\000\000\
\\001\000\065\000\031\003\000\000\
\\001\000\065\000\033\003\000\000\
\\001\000\065\000\036\003\000\000\
\\001\000\065\000\038\003\000\000\
\\001\000\065\000\039\003\000\000\
\\001\000\065\000\055\003\000\000\
\\001\000\065\000\057\003\000\000\
\\001\000\065\000\059\003\000\000\
\\001\000\065\000\062\003\000\000\
\\001\000\065\000\068\003\000\000\
\\001\000\065\000\069\003\000\000\
\\001\000\065\000\070\003\000\000\
\\001\000\065\000\071\003\000\000\
\\001\000\065\000\074\003\000\000\
\\001\000\065\000\143\003\000\000\
\\001\000\065\000\153\003\000\000\
\\001\000\065\000\156\003\000\000\
\\001\000\065\000\195\003\000\000\
\\001\000\065\000\224\003\000\000\
\\001\000\065\000\225\003\000\000\
\\001\000\065\000\226\003\000\000\
\\001\000\065\000\227\003\000\000\
\\001\000\065\000\228\003\000\000\
\\001\000\065\000\232\003\000\000\
\\001\000\065\000\233\003\000\000\
\\001\000\065\000\234\003\000\000\
\\001\000\065\000\238\003\000\000\
\\001\000\065\000\240\003\000\000\
\\001\000\065\000\242\003\000\000\
\\001\000\065\000\244\003\000\000\
\\001\000\065\000\245\003\000\000\
\\001\000\065\000\250\003\000\000\
\\001\000\065\000\253\003\000\000\
\\001\000\065\000\001\004\000\000\
\\001\000\065\000\004\004\000\000\
\\001\000\065\000\011\004\000\000\
\\001\000\065\000\012\004\000\000\
\\001\000\065\000\014\004\000\000\
\\001\000\065\000\015\004\000\000\
\\001\000\065\000\017\004\000\000\
\\001\000\065\000\018\004\000\000\
\\001\000\065\000\019\004\000\000\
\\001\000\065\000\022\004\000\000\
\\001\000\065\000\023\004\000\000\
\\001\000\065\000\025\004\000\000\
\\001\000\065\000\026\004\000\000\
\\001\000\065\000\029\004\000\000\
\\001\000\065\000\030\004\000\000\
\\001\000\065\000\032\004\000\000\
\\001\000\065\000\034\004\000\000\
\\001\000\065\000\035\004\000\000\
\\001\000\065\000\036\004\000\000\
\\001\000\065\000\037\004\000\000\
\\001\000\065\000\038\004\000\000\
\\001\000\065\000\039\004\000\000\
\\001\000\065\000\040\004\000\000\
\\001\000\065\000\041\004\000\000\
\\001\000\065\000\045\004\000\000\
\\001\000\065\000\048\004\000\000\
\\001\000\065\000\051\004\000\000\
\\001\000\065\000\056\004\000\000\
\\001\000\065\000\057\004\000\000\
\\001\000\065\000\061\004\000\000\
\\001\000\065\000\068\004\000\000\
\\001\000\065\000\098\004\000\000\
\\001\000\065\000\109\004\000\000\
\\001\000\065\000\112\004\000\000\
\\001\000\065\000\114\004\000\000\
\\001\000\065\000\115\004\000\000\
\\001\000\065\000\116\004\000\000\
\\001\000\065\000\117\004\000\000\
\\001\000\065\000\118\004\000\000\
\\001\000\065\000\119\004\000\000\
\\001\000\065\000\120\004\000\000\
\\001\000\065\000\121\004\000\000\
\\001\000\065\000\122\004\000\000\
\\001\000\065\000\123\004\000\000\
\\001\000\065\000\124\004\000\000\
\\001\000\065\000\125\004\000\000\
\\001\000\065\000\126\004\000\000\
\\001\000\065\000\127\004\000\000\
\\001\000\065\000\128\004\000\000\
\\001\000\065\000\130\004\000\000\
\\001\000\065\000\131\004\000\000\
\\001\000\065\000\132\004\000\000\
\\001\000\065\000\134\004\000\000\
\\001\000\065\000\135\004\000\000\
\\001\000\065\000\139\004\000\000\
\\001\000\065\000\140\004\000\000\
\\001\000\065\000\141\004\000\000\
\\001\000\065\000\142\004\000\000\
\\001\000\065\000\143\004\000\000\
\\001\000\065\000\160\004\000\000\
\\001\000\065\000\162\004\000\000\
\\001\000\065\000\163\004\000\000\
\\001\000\065\000\171\004\000\000\
\\001\000\065\000\172\004\000\000\
\\001\000\065\000\174\004\000\000\
\\001\000\065\000\177\004\000\000\
\\001\000\065\000\178\004\000\000\
\\001\000\065\000\180\004\000\000\
\\001\000\065\000\191\004\000\000\
\\001\000\065\000\193\004\000\000\
\\001\000\065\000\194\004\000\000\
\\001\000\065\000\200\004\000\000\
\\001\000\065\000\218\004\000\000\
\\001\000\065\000\220\004\000\000\
\\001\000\065\000\222\004\000\000\
\\001\000\065\000\224\004\000\000\
\\001\000\065\000\225\004\000\000\
\\001\000\065\000\226\004\000\000\
\\001\000\065\000\227\004\000\000\
\\001\000\065\000\228\004\000\000\
\\001\000\065\000\229\004\000\000\
\\001\000\065\000\239\004\000\000\
\\001\000\065\000\240\004\000\000\
\\001\000\065\000\241\004\000\000\
\\001\000\065\000\242\004\000\000\
\\001\000\065\000\249\004\000\000\
\\001\000\065\000\250\004\000\000\
\\001\000\065\000\252\004\000\000\
\\001\000\065\000\253\004\000\000\
\\001\000\065\000\003\005\000\000\
\\001\000\065\000\004\005\000\000\
\\001\000\065\000\005\005\000\000\
\\001\000\065\000\006\005\000\000\
\\001\000\065\000\009\005\000\000\
\\001\000\065\000\010\005\000\000\
\\001\000\065\000\011\005\000\000\
\\001\000\065\000\014\005\000\000\
\\001\000\065\000\016\005\000\000\
\\001\000\065\000\026\005\000\000\
\\001\000\065\000\030\005\000\000\
\\001\000\065\000\033\005\000\000\
\\001\000\065\000\034\005\000\000\
\\001\000\065\000\035\005\000\000\
\\001\000\065\000\037\005\000\000\
\\001\000\065\000\043\005\000\000\
\\001\000\065\000\049\005\000\000\
\\001\000\065\000\056\005\000\000\
\\001\000\065\000\057\005\000\000\
\\001\000\065\000\061\005\000\000\
\\001\000\065\000\063\005\000\000\
\\001\000\065\000\065\005\000\000\
\\001\000\065\000\066\005\000\000\
\\001\000\065\000\075\005\000\000\
\\001\000\065\000\077\005\000\000\
\\001\000\065\000\078\005\000\000\
\\001\000\065\000\087\005\000\000\
\\001\000\065\000\088\005\000\000\
\\001\000\065\000\089\005\000\000\
\\001\000\065\000\090\005\000\000\
\\001\000\065\000\092\005\000\000\
\\001\000\065\000\095\005\000\000\
\\001\000\065\000\106\005\000\000\
\\001\000\065\000\112\005\000\000\
\\001\000\065\000\113\005\000\000\
\\001\000\065\000\129\005\000\000\
\\001\000\065\000\133\005\000\000\
\\001\000\065\000\151\005\000\000\
\\001\000\065\000\161\005\000\000\
\\001\000\065\000\168\005\000\000\
\\001\000\065\000\173\005\000\000\
\\001\000\065\000\174\005\000\000\
\\001\000\065\000\176\005\068\000\085\005\000\000\
\\001\000\065\000\177\005\000\000\
\\001\000\065\000\179\005\068\000\085\005\000\000\
\\001\000\065\000\181\005\068\000\085\005\000\000\
\\001\000\065\000\182\005\000\000\
\\001\000\065\000\184\005\068\000\085\005\000\000\
\\001\000\065\000\185\005\000\000\
\\001\000\065\000\186\005\000\000\
\\001\000\065\000\187\005\000\000\
\\001\000\065\000\188\005\000\000\
\\001\000\068\000\149\003\000\000\
\\001\000\068\000\196\003\000\000\
\\001\000\068\000\176\004\000\000\
\\001\000\068\000\203\004\000\000\
\\001\000\068\000\013\005\000\000\
\\001\000\068\000\085\005\069\000\139\005\000\000\
\\001\000\068\000\085\005\069\000\142\005\000\000\
\\001\000\068\000\085\005\069\000\144\005\000\000\
\\001\000\068\000\085\005\069\000\147\005\000\000\
\\001\000\069\000\166\001\000\000\
\\001\000\069\000\133\002\000\000\
\\001\000\069\000\158\003\000\000\
\\001\000\069\000\007\004\000\000\
\\001\000\069\000\065\004\000\000\
\\001\000\069\000\189\004\000\000\
\\001\000\069\000\216\004\000\000\
\\001\000\069\000\232\004\000\000\
\\001\000\069\000\238\004\132\000\237\004\000\000\
\\001\000\069\000\042\005\000\000\
\\001\000\069\000\048\005\000\000\
\\001\000\069\000\054\005\000\000\
\\001\000\069\000\062\005\000\000\
\\001\000\069\000\100\005\000\000\
\\001\000\069\000\116\005\000\000\
\\001\000\069\000\120\005\000\000\
\\001\000\069\000\124\005\000\000\
\\001\000\069\000\137\005\000\000\
\\001\000\069\000\140\005\000\000\
\\001\000\069\000\145\005\000\000\
\\001\000\069\000\157\005\000\000\
\\001\000\069\000\158\005\000\000\
\\001\000\069\000\159\005\000\000\
\\001\000\069\000\160\005\000\000\
\\001\000\071\000\100\003\000\000\
\\001\000\071\000\103\003\000\000\
\\001\000\071\000\117\003\000\000\
\\001\000\071\000\124\003\000\000\
\\001\000\071\000\199\003\000\000\
\\001\000\071\000\219\003\000\000\
\\001\000\071\000\080\004\000\000\
\\001\000\071\000\081\004\000\000\
\\001\000\071\000\152\004\000\000\
\\001\000\071\000\209\004\000\000\
\\001\000\071\000\233\004\000\000\
\\001\000\088\000\147\001\000\000\
\\001\000\096\000\111\003\000\000\
\\001\000\107\000\115\001\000\000\
\\001\000\107\000\130\001\000\000\
\\001\000\107\000\131\001\000\000\
\\001\000\107\000\142\001\000\000\
\\001\000\107\000\143\001\000\000\
\\001\000\107\000\144\001\000\000\
\\001\000\107\000\145\001\000\000\
\\001\000\107\000\146\001\000\000\
\\001\000\107\000\025\002\000\000\
\\001\000\107\000\202\002\000\000\
\\001\000\107\000\032\003\000\000\
\\001\000\107\000\050\003\000\000\
\\001\000\107\000\097\003\000\000\
\\001\000\107\000\157\003\000\000\
\\001\000\107\000\200\003\000\000\
\\001\000\107\000\091\004\000\000\
\\001\000\107\000\094\004\000\000\
\\001\000\107\000\145\004\000\000\
\\001\000\107\000\197\004\000\000\
\\001\000\107\000\198\004\000\000\
\\001\000\107\000\202\004\000\000\
\\001\000\107\000\025\005\000\000\
\\001\000\107\000\051\005\000\000\
\\001\000\107\000\053\005\000\000\
\\001\000\107\000\080\005\000\000\
\\001\000\107\000\094\005\000\000\
\\001\000\107\000\115\005\000\000\
\\001\000\116\000\146\002\000\000\
\\001\000\117\000\167\004\000\000\
\\001\000\117\000\028\005\000\000\
\\001\000\117\000\039\005\000\000\
\\001\000\126\000\008\002\000\000\
\\001\000\126\000\048\002\000\000\
\\001\000\143\000\223\003\000\000\
\\001\000\169\000\112\001\000\000\
\\001\000\169\000\199\002\000\000\
\\001\000\169\000\125\003\000\000\
\\001\000\169\000\146\003\000\000\
\\001\000\169\000\148\003\000\000\
\\001\000\169\000\201\003\000\000\
\\001\000\169\000\220\003\000\000\
\\001\000\169\000\235\004\000\000\
\\190\005\000\000\
\\191\005\000\000\
\\192\005\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\012\000\103\000\013\000\102\000\014\000\101\000\
\\015\000\100\000\016\000\099\000\024\000\098\000\025\000\097\000\
\\028\000\096\000\033\000\095\000\034\000\094\000\035\000\093\000\
\\040\000\092\000\041\000\091\000\042\000\090\000\043\000\089\000\
\\044\000\088\000\047\000\087\000\050\000\086\000\051\000\085\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\059\000\081\000\
\\061\000\080\000\062\000\079\000\064\000\078\000\068\000\077\000\
\\070\000\076\000\074\000\075\000\075\000\074\000\076\000\073\000\
\\077\000\072\000\079\000\071\000\080\000\070\000\087\000\069\000\
\\090\000\068\000\091\000\067\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\118\000\062\000\119\000\061\000\
\\120\000\060\000\126\000\059\000\128\000\058\000\130\000\057\000\
\\133\000\056\000\137\000\055\000\138\000\054\000\139\000\053\000\
\\141\000\052\000\142\000\051\000\150\000\050\000\152\000\049\000\
\\156\000\048\000\157\000\047\000\160\000\046\000\161\000\045\000\
\\163\000\044\000\165\000\043\000\166\000\042\000\171\000\041\000\
\\173\000\040\000\175\000\039\000\176\000\038\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\183\000\033\000\
\\184\000\032\000\185\000\031\000\187\000\030\000\000\000\
\\193\005\000\000\
\\194\005\060\000\117\000\000\000\
\\195\005\000\000\
\\196\005\000\000\
\\197\005\000\000\
\\198\005\000\000\
\\199\005\000\000\
\\200\005\000\000\
\\201\005\000\000\
\\202\005\000\000\
\\203\005\000\000\
\\204\005\000\000\
\\205\005\000\000\
\\206\005\000\000\
\\207\005\000\000\
\\208\005\000\000\
\\209\005\000\000\
\\210\005\000\000\
\\211\005\000\000\
\\212\005\000\000\
\\213\005\000\000\
\\214\005\000\000\
\\215\005\000\000\
\\216\005\000\000\
\\217\005\000\000\
\\218\005\000\000\
\\219\005\000\000\
\\220\005\000\000\
\\221\005\000\000\
\\222\005\000\000\
\\223\005\000\000\
\\224\005\000\000\
\\225\005\000\000\
\\226\005\000\000\
\\227\005\000\000\
\\228\005\000\000\
\\229\005\000\000\
\\230\005\000\000\
\\231\005\000\000\
\\232\005\000\000\
\\233\005\000\000\
\\234\005\000\000\
\\235\005\000\000\
\\236\005\000\000\
\\237\005\000\000\
\\238\005\000\000\
\\239\005\000\000\
\\240\005\000\000\
\\241\005\000\000\
\\242\005\000\000\
\\243\005\000\000\
\\244\005\000\000\
\\245\005\000\000\
\\246\005\000\000\
\\247\005\000\000\
\\248\005\000\000\
\\249\005\000\000\
\\250\005\000\000\
\\251\005\000\000\
\\252\005\000\000\
\\253\005\000\000\
\\254\005\000\000\
\\255\005\000\000\
\\000\006\000\000\
\\001\006\000\000\
\\002\006\000\000\
\\003\006\000\000\
\\004\006\000\000\
\\005\006\000\000\
\\006\006\000\000\
\\007\006\000\000\
\\008\006\000\000\
\\009\006\000\000\
\\010\006\000\000\
\\011\006\000\000\
\\012\006\000\000\
\\013\006\000\000\
\\014\006\000\000\
\\015\006\000\000\
\\016\006\000\000\
\\017\006\000\000\
\\018\006\000\000\
\\019\006\000\000\
\\020\006\000\000\
\\021\006\000\000\
\\022\006\000\000\
\\023\006\000\000\
\\024\006\000\000\
\\025\006\000\000\
\\026\006\000\000\
\\027\006\000\000\
\\028\006\000\000\
\\029\006\000\000\
\\030\006\024\000\138\000\000\000\
\\031\006\000\000\
\\032\006\000\000\
\\033\006\013\000\102\000\024\000\129\000\000\000\
\\034\006\000\000\
\\035\006\066\000\044\002\000\000\
\\036\006\000\000\
\\037\006\000\000\
\\038\006\000\000\
\\039\006\000\000\
\\040\006\000\000\
\\041\006\000\000\
\\042\006\000\000\
\\043\006\000\000\
\\044\006\000\000\
\\045\006\000\000\
\\046\006\000\000\
\\047\006\000\000\
\\048\006\000\000\
\\049\006\000\000\
\\050\006\000\000\
\\051\006\000\000\
\\052\006\000\000\
\\053\006\064\000\012\003\000\000\
\\054\006\000\000\
\\055\006\009\000\030\002\000\000\
\\056\006\000\000\
\\057\006\047\000\249\003\064\000\248\003\000\000\
\\058\006\000\000\
\\059\006\000\000\
\\059\006\039\000\048\001\000\000\
\\059\006\039\000\048\001\107\000\138\001\000\000\
\\059\006\039\000\048\001\107\000\143\001\000\000\
\\059\006\039\000\048\001\107\000\028\003\000\000\
\\059\006\039\000\048\001\107\000\089\004\000\000\
\\059\006\039\000\075\001\107\000\074\001\000\000\
\\060\006\000\000\
\\061\006\000\000\
\\062\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\063\006\066\000\148\001\000\000\
\\064\006\000\000\
\\065\006\000\000\
\\066\006\000\000\
\\067\006\000\000\
\\068\006\000\000\
\\069\006\000\000\
\\070\006\000\000\
\\071\006\000\000\
\\072\006\000\000\
\\073\006\000\000\
\\074\006\000\000\
\\075\006\000\000\
\\076\006\000\000\
\\077\006\000\000\
\\078\006\000\000\
\\079\006\000\000\
\\079\006\065\000\238\002\000\000\
\\080\006\000\000\
\\081\006\000\000\
\\081\006\065\000\237\002\000\000\
\\082\006\000\000\
\\083\006\000\000\
\\083\006\065\000\031\004\000\000\
\\084\006\000\000\
\\085\006\000\000\
\\085\006\065\000\231\003\000\000\
\\086\006\000\000\
\\087\006\000\000\
\\087\006\065\000\156\004\000\000\
\\088\006\000\000\
\\089\006\000\000\
\\089\006\065\000\230\003\000\000\
\\090\006\000\000\
\\090\006\065\000\008\005\000\000\
\\091\006\000\000\
\\092\006\000\000\
\\093\006\000\000\
\\094\006\000\000\
\\095\006\000\000\
\\096\006\000\000\
\\097\006\000\000\
\\098\006\000\000\
\\099\006\000\000\
\\100\006\000\000\
\\100\006\065\000\007\005\000\000\
\\101\006\000\000\
\\102\006\000\000\
\\103\006\000\000\
\\104\006\000\000\
\\105\006\000\000\
\\106\006\000\000\
\\107\006\000\000\
\\108\006\000\000\
\\109\006\000\000\
\\110\006\000\000\
\\111\006\000\000\
\\112\006\000\000\
\\113\006\000\000\
\\113\006\065\000\252\003\000\000\
\\114\006\000\000\
\\115\006\000\000\
\\116\006\000\000\
\\116\006\065\000\032\004\000\000\
\\117\006\000\000\
\\118\006\000\000\
\\118\006\065\000\009\005\000\000\
\\119\006\000\000\
\\120\006\000\000\
\\120\006\065\000\019\004\000\000\
\\121\006\000\000\
\\121\006\065\000\017\004\000\000\
\\122\006\000\000\
\\123\006\000\000\
\\124\006\000\000\
\\125\006\000\000\
\\126\006\000\000\
\\127\006\000\000\
\\128\006\000\000\
\\128\006\065\000\051\004\000\000\
\\129\006\000\000\
\\130\006\000\000\
\\131\006\000\000\
\\132\006\000\000\
\\133\006\000\000\
\\134\006\000\000\
\\135\006\000\000\
\\136\006\000\000\
\\137\006\000\000\
\\138\006\000\000\
\\139\006\000\000\
\\140\006\000\000\
\\141\006\000\000\
\\142\006\000\000\
\\143\006\000\000\
\\144\006\000\000\
\\145\006\000\000\
\\146\006\000\000\
\\147\006\000\000\
\\148\006\000\000\
\\149\006\000\000\
\\150\006\000\000\
\\151\006\000\000\
\\152\006\000\000\
\\153\006\000\000\
\\154\006\000\000\
\\155\006\000\000\
\\156\006\000\000\
\\157\006\000\000\
\\158\006\000\000\
\\159\006\000\000\
\\160\006\000\000\
\\161\006\000\000\
\\162\006\000\000\
\\163\006\000\000\
\\163\006\065\000\242\003\000\000\
\\164\006\000\000\
\\165\006\000\000\
\\166\006\000\000\
\\167\006\000\000\
\\168\006\000\000\
\\169\006\000\000\
\\170\006\000\000\
\\171\006\000\000\
\\172\006\000\000\
\\173\006\064\000\035\002\000\000\
\\174\006\000\000\
\\175\006\066\000\109\001\000\000\
\\176\006\000\000\
\\177\006\066\000\049\002\000\000\
\\178\006\000\000\
\\182\006\000\000\
\\183\006\000\000\
\\184\006\000\000\
\\185\006\000\000\
\\186\006\000\000\
\\187\006\000\000\
\\188\006\000\000\
\\189\006\029\000\072\001\058\000\071\001\096\000\070\001\000\000\
\\190\006\000\000\
\\191\006\000\000\
\\192\006\029\000\072\001\058\000\071\001\096\000\070\001\000\000\
\\193\006\060\000\069\001\000\000\
\\194\006\000\000\
\\195\006\000\000\
\\196\006\000\000\
\\197\006\024\000\197\002\000\000\
\\198\006\000\000\
\\199\006\000\000\
\\200\006\000\000\
\\203\006\000\000\
\\203\006\030\000\168\001\000\000\
\\203\006\058\000\172\001\000\000\
\\204\006\000\000\
\\205\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\009\000\171\001\010\000\170\001\013\000\102\000\
\\024\000\098\000\025\000\097\000\034\000\094\000\047\000\087\000\
\\050\000\086\000\052\000\084\000\055\000\083\000\056\000\082\000\
\\061\000\080\000\062\000\079\000\064\000\115\000\068\000\077\000\
\\070\000\076\000\074\000\075\000\075\000\074\000\076\000\073\000\
\\077\000\072\000\079\000\071\000\080\000\070\000\087\000\069\000\
\\092\000\066\000\094\000\065\000\098\000\064\000\108\000\063\000\
\\137\000\055\000\138\000\054\000\156\000\048\000\157\000\047\000\
\\161\000\045\000\163\000\044\000\165\000\043\000\166\000\042\000\
\\173\000\040\000\177\000\037\000\178\000\036\000\179\000\035\000\
\\182\000\034\000\000\000\
\\205\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\206\006\000\000\
\\207\006\005\000\125\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\124\000\
\\062\000\079\000\064\000\123\000\068\000\077\000\070\000\076\000\
\\074\000\075\000\075\000\074\000\076\000\122\000\077\000\121\000\
\\080\000\120\000\087\000\069\000\138\000\054\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\177\000\037\000\178\000\036\000\
\\179\000\035\000\182\000\034\000\000\000\
\\208\006\000\000\
\\209\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\115\000\068\000\077\000\070\000\076\000\074\000\075\000\
\\075\000\074\000\076\000\073\000\077\000\072\000\079\000\071\000\
\\080\000\070\000\087\000\069\000\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\138\000\054\000\
\\156\000\048\000\157\000\047\000\161\000\045\000\163\000\044\000\
\\165\000\043\000\166\000\042\000\173\000\040\000\177\000\037\000\
\\178\000\036\000\179\000\035\000\182\000\034\000\000\000\
\\210\006\000\000\
\\211\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\103\001\
\\006\000\104\000\052\000\084\000\055\000\102\001\056\000\082\000\
\\061\000\080\000\064\000\101\001\076\000\100\001\077\000\099\001\
\\079\000\071\000\080\000\098\001\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\156\000\048\000\
\\157\000\047\000\161\000\045\000\173\000\040\000\000\000\
\\212\006\000\000\
\\213\006\024\000\197\002\000\000\
\\214\006\000\000\
\\215\006\024\000\197\002\000\000\
\\216\006\000\000\
\\217\006\000\000\
\\218\006\000\000\
\\219\006\000\000\
\\220\006\000\000\
\\221\006\000\000\
\\221\006\039\000\194\003\000\000\
\\222\006\000\000\
\\223\006\000\000\
\\224\006\039\000\028\002\000\000\
\\225\006\000\000\
\\226\006\000\000\
\\226\006\107\000\073\001\000\000\
\\226\006\107\000\142\001\000\000\
\\227\006\000\000\
\\228\006\000\000\
\\229\006\000\000\
\\230\006\024\000\042\002\050\000\041\002\064\000\040\002\000\000\
\\231\006\000\000\
\\234\006\000\000\
\\235\006\000\000\
\\236\006\000\000\
\\237\006\000\000\
\\238\006\000\000\
\\239\006\000\000\
\\240\006\000\000\
\\241\006\000\000\
\\242\006\000\000\
\\243\006\000\000\
\\244\006\000\000\
\\245\006\000\000\
\\246\006\000\000\
\\247\006\000\000\
\\248\006\064\000\108\005\000\000\
\\249\006\000\000\
\\250\006\000\000\
\\251\006\000\000\
\\252\006\000\000\
\\253\006\000\000\
\\254\006\000\000\
\\255\006\000\000\
\\000\007\000\000\
\\001\007\000\000\
\\002\007\000\000\
\\003\007\000\000\
\\004\007\000\000\
\\005\007\000\000\
\\006\007\000\000\
\\007\007\000\000\
\\008\007\000\000\
\\009\007\000\000\
\\010\007\000\000\
\\011\007\000\000\
\\012\007\068\000\069\005\000\000\
\\013\007\000\000\
\\014\007\000\000\
\\015\007\000\000\
\\016\007\000\000\
\\017\007\000\000\
\\018\007\000\000\
\\019\007\000\000\
\\020\007\000\000\
\\021\007\000\000\
\\022\007\000\000\
\\023\007\000\000\
\\024\007\000\000\
\\025\007\000\000\
\\026\007\000\000\
\\027\007\000\000\
\\028\007\000\000\
\\029\007\000\000\
\\030\007\000\000\
\\031\007\000\000\
\\032\007\000\000\
\\033\007\000\000\
\\034\007\000\000\
\\035\007\000\000\
\\036\007\000\000\
\\037\007\000\000\
\\038\007\024\000\000\004\064\000\255\003\109\000\151\003\000\000\
\\039\007\000\000\
\\040\007\024\000\126\002\064\000\125\002\000\000\
\\041\007\000\000\
\\044\007\000\000\
\\045\007\000\000\
\\046\007\000\000\
\\047\007\000\000\
\\048\007\024\000\131\002\064\000\130\002\000\000\
\\049\007\000\000\
\\050\007\024\000\197\002\000\000\
\\051\007\000\000\
\\052\007\000\000\
\\053\007\000\000\
\\054\007\000\000\
\\055\007\000\000\
\\056\007\000\000\
\\057\007\000\000\
\\058\007\000\000\
\\059\007\064\000\209\001\000\000\
\\060\007\000\000\
\\061\007\009\000\132\001\000\000\
\\062\007\000\000\
\\063\007\000\000\
\\064\007\000\000\
\\065\007\000\000\
\\066\007\000\000\
\\067\007\000\000\
\\068\007\000\000\
\\069\007\000\000\
\\070\007\000\000\
\\071\007\024\000\126\002\064\000\097\004\000\000\
\\072\007\000\000\
\\073\007\024\000\107\004\064\000\097\004\000\000\
\\074\007\000\000\
\\075\007\024\000\126\002\064\000\097\004\000\000\
\\076\007\000\000\
\\079\007\000\000\
\\079\007\024\000\126\002\064\000\097\004\000\000\
\\080\007\000\000\
\\081\007\024\000\138\000\000\000\
\\082\007\000\000\
\\083\007\024\000\061\001\000\000\
\\084\007\000\000\
\\085\007\024\000\138\000\000\000\
\\086\007\000\000\
\\087\007\037\000\186\003\039\000\065\002\000\000\
\\087\007\039\000\065\002\000\000\
\\088\007\000\000\
\\089\007\000\000\
\\090\007\000\000\
\\091\007\000\000\
\\094\007\024\000\066\001\000\000\
\\095\007\000\000\
\\096\007\000\000\
\\097\007\000\000\
\\098\007\000\000\
\\099\007\000\000\
\\100\007\024\000\066\001\037\000\173\002\182\000\117\002\000\000\
\\100\007\024\000\066\001\037\000\010\004\039\000\009\004\182\000\117\002\000\000\
\\100\007\024\000\066\001\039\000\087\003\182\000\117\002\000\000\
\\100\007\024\000\066\001\039\000\009\004\182\000\117\002\000\000\
\\100\007\024\000\066\001\182\000\117\002\000\000\
\\101\007\000\000\
\\102\007\024\000\066\001\182\000\163\001\000\000\
\\103\007\000\000\
\\104\007\066\000\096\001\000\000\
\\105\007\000\000\
\\106\007\024\000\138\000\000\000\
\\107\007\000\000\
\\108\007\024\000\061\001\000\000\
\\109\007\000\000\
\\110\007\000\000\
\\111\007\000\000\
\\118\007\000\000\
\\119\007\000\000\
\\120\007\000\000\
\\121\007\000\000\
\\122\007\000\000\
\\123\007\000\000\
\\124\007\000\000\
\\125\007\000\000\
\\126\007\000\000\
\\127\007\000\000\
\\128\007\000\000\
\\129\007\000\000\
\\130\007\000\000\
\\131\007\000\000\
\\132\007\000\000\
\\133\007\000\000\
\\134\007\000\000\
\\135\007\000\000\
\\136\007\000\000\
\\137\007\000\000\
\\138\007\000\000\
\\139\007\000\000\
\\140\007\000\000\
\\141\007\000\000\
\\142\007\000\000\
\\143\007\000\000\
\\144\007\000\000\
\\145\007\000\000\
\\146\007\000\000\
\\147\007\000\000\
\\148\007\000\000\
\\149\007\000\000\
\\150\007\000\000\
\\151\007\000\000\
\\152\007\000\000\
\\153\007\000\000\
\\154\007\000\000\
\\155\007\000\000\
\\156\007\000\000\
\\157\007\000\000\
\\158\007\000\000\
\\159\007\000\000\
\\160\007\024\000\066\001\025\000\128\001\034\000\127\001\047\000\126\001\
\\048\000\125\001\050\000\124\001\064\000\123\001\068\000\122\001\
\\182\000\121\001\000\000\
\\161\007\000\000\
\\162\007\000\000\
\\163\007\024\000\066\001\025\000\128\001\034\000\127\001\047\000\126\001\
\\048\000\125\001\050\000\124\001\064\000\123\001\068\000\122\001\
\\182\000\121\001\000\000\
\\164\007\000\000\
\\165\007\000\000\
\\166\007\000\000\
\\167\007\000\000\
\\168\007\000\000\
\\169\007\024\000\197\002\000\000\
\\170\007\000\000\
\\171\007\052\000\084\000\064\000\018\002\000\000\
\\171\007\064\000\018\002\000\000\
\\172\007\000\000\
\\173\007\000\000\
\\174\007\000\000\
\\175\007\024\000\197\002\000\000\
\\176\007\000\000\
\\177\007\052\000\084\000\064\000\015\002\000\000\
\\177\007\064\000\015\002\000\000\
\\178\007\000\000\
\\179\007\000\000\
\\180\007\000\000\
\\181\007\000\000\
\\182\007\000\000\
\\183\007\000\000\
\\184\007\000\000\
\\185\007\052\000\084\000\064\000\045\003\137\000\159\001\000\000\
\\185\007\064\000\045\003\000\000\
\\186\007\000\000\
\\187\007\052\000\084\000\064\000\233\002\000\000\
\\187\007\052\000\084\000\064\000\233\002\096\000\232\002\137\000\092\001\000\000\
\\187\007\052\000\084\000\064\000\233\002\137\000\106\001\000\000\
\\187\007\052\000\084\000\064\000\233\002\137\000\108\001\000\000\
\\187\007\064\000\233\002\000\000\
\\187\007\064\000\233\002\096\000\085\004\000\000\
\\188\007\000\000\
\\189\007\024\000\197\002\000\000\
\\190\007\000\000\
\\191\007\024\000\197\002\000\000\
\\192\007\000\000\
\\193\007\024\000\197\002\000\000\
\\194\007\000\000\
\\195\007\000\000\
\\196\007\024\000\197\002\000\000\
\\197\007\000\000\
\\198\007\000\000\
\\199\007\000\000\
\\200\007\000\000\
\\201\007\000\000\
\\201\007\002\000\108\000\003\000\107\000\004\000\106\000\005\000\103\001\
\\006\000\104\000\052\000\084\000\055\000\102\001\056\000\082\000\
\\061\000\080\000\064\000\101\001\076\000\100\001\077\000\099\001\
\\079\000\071\000\080\000\098\001\092\000\066\000\094\000\065\000\
\\098\000\064\000\108\000\063\000\137\000\055\000\156\000\048\000\
\\157\000\047\000\161\000\045\000\173\000\040\000\000\000\
\\202\007\000\000\
\\203\007\060\000\140\001\000\000\
\\204\007\000\000\
\\205\007\064\000\224\001\000\000\
\\206\007\000\000\
\\207\007\060\000\201\002\000\000\
\\208\007\000\000\
\\215\007\000\000\
\\216\007\000\000\
\\217\007\000\000\
\\218\007\000\000\
\\219\007\000\000\
\"
val actionRowNumbers =
"\004\000\010\000\094\002\093\002\
\\226\001\225\001\151\002\237\002\
\\086\002\234\002\223\001\224\001\
\\222\001\221\001\220\001\219\001\
\\215\001\214\001\216\001\213\001\
\\212\001\211\001\227\001\209\001\
\\207\001\218\001\217\001\205\001\
\\024\000\034\000\034\000\035\000\
\\005\003\024\000\024\000\024\000\
\\150\000\040\000\008\000\040\000\
\\024\000\008\000\040\000\024\000\
\\151\000\008\000\008\000\024\000\
\\024\000\040\000\043\000\038\002\
\\008\000\010\000\040\000\044\000\
\\045\000\046\000\047\000\045\000\
\\045\000\008\000\008\000\011\000\
\\012\000\027\000\027\000\083\002\
\\142\000\136\000\136\000\008\000\
\\152\000\153\000\024\000\239\002\
\\019\000\024\000\028\000\007\002\
\\136\000\136\000\062\002\251\001\
\\048\000\049\000\154\000\155\000\
\\040\000\008\000\009\000\024\000\
\\091\002\008\000\253\001\092\002\
\\075\002\040\000\034\000\156\000\
\\081\002\008\000\136\000\136\000\
\\050\000\052\000\053\000\147\000\
\\226\002\219\002\218\002\125\000\
\\006\003\020\000\080\002\210\001\
\\208\001\247\001\136\000\136\000\
\\008\000\017\000\136\000\136\000\
\\006\002\048\002\047\002\074\002\
\\004\002\024\000\034\000\024\000\
\\024\000\008\000\040\000\040\000\
\\110\003\141\000\123\000\103\002\
\\100\002\126\000\139\003\018\000\
\\057\000\143\000\144\000\243\001\
\\020\002\211\002\019\003\024\000\
\\008\000\197\001\132\000\058\000\
\\014\003\163\001\091\003\059\000\
\\077\003\192\003\060\000\164\001\
\\165\001\098\003\094\003\090\003\
\\127\000\136\000\018\000\076\002\
\\018\000\241\003\018\000\007\003\
\\077\002\016\002\018\002\168\001\
\\001\000\017\002\169\001\170\001\
\\161\001\084\002\008\000\018\000\
\\055\000\055\000\145\000\137\003\
\\137\003\008\000\126\001\239\002\
\\235\002\238\002\236\002\024\000\
\\034\000\034\000\036\000\024\000\
\\024\000\024\000\157\000\040\000\
\\008\000\040\000\040\000\040\000\
\\024\000\008\000\024\000\041\000\
\\024\000\158\000\008\000\008\000\
\\024\000\024\000\024\000\040\000\
\\061\000\172\000\008\000\042\000\
\\062\000\159\000\045\000\063\000\
\\064\000\159\000\045\000\065\000\
\\066\000\008\000\160\000\011\000\
\\160\000\013\000\027\000\027\000\
\\018\000\008\000\024\000\018\000\
\\022\000\137\000\138\000\008\000\
\\162\000\163\000\024\000\090\002\
\\028\000\173\000\139\000\140\000\
\\174\000\024\000\040\000\009\000\
\\009\000\024\000\008\000\175\000\
\\040\000\034\000\194\001\165\000\
\\024\000\008\000\008\000\207\003\
\\200\003\051\000\067\000\053\000\
\\149\000\241\002\018\000\171\001\
\\002\000\055\000\055\000\253\002\
\\252\002\003\003\068\000\041\002\
\\070\002\069\000\136\000\008\000\
\\240\001\209\002\008\000\020\000\
\\246\001\008\000\070\000\136\000\
\\010\002\050\002\073\000\195\001\
\\213\002\008\000\003\000\003\000\
\\128\000\146\003\143\003\112\003\
\\129\000\018\000\125\003\124\003\
\\120\003\233\002\063\002\010\000\
\\008\000\024\000\008\000\008\000\
\\008\000\071\000\024\000\055\000\
\\136\000\055\000\003\000\049\002\
\\001\002\176\000\008\000\115\002\
\\109\002\177\000\145\003\141\003\
\\021\003\074\000\074\000\024\000\
\\245\001\024\000\040\000\198\002\
\\142\000\136\000\008\000\021\000\
\\136\000\136\000\135\003\074\000\
\\074\000\074\000\074\000\024\000\
\\248\003\142\002\232\002\075\003\
\\040\000\078\000\040\000\153\003\
\\127\001\192\003\150\003\147\003\
\\192\003\029\000\079\000\024\000\
\\080\000\157\003\151\003\131\003\
\\008\000\008\000\045\000\027\000\
\\027\000\024\000\074\000\154\002\
\\008\000\156\002\081\000\152\002\
\\008\000\008\000\024\000\024\000\
\\008\000\126\002\083\002\147\000\
\\147\000\247\002\249\002\198\001\
\\147\000\245\003\172\001\147\000\
\\074\000\074\000\129\003\178\000\
\\137\003\130\003\179\000\106\002\
\\123\002\240\002\055\000\180\000\
\\008\000\008\000\018\000\181\000\
\\182\000\183\000\024\000\034\000\
\\024\000\024\000\008\000\040\000\
\\040\000\220\003\124\000\184\000\
\\185\000\104\002\101\002\008\000\
\\117\003\018\000\082\000\221\003\
\\222\003\186\000\187\000\188\000\
\\189\000\083\000\025\000\039\002\
\\008\000\075\000\040\000\084\000\
\\190\000\191\000\092\003\045\000\
\\078\000\192\000\193\000\068\002\
\\192\003\085\000\008\000\008\000\
\\194\000\195\000\133\000\196\000\
\\219\003\018\000\055\000\018\000\
\\018\000\018\000\078\002\197\000\
\\198\000\199\000\173\001\200\000\
\\245\002\243\002\201\000\239\002\
\\202\000\203\000\243\003\243\003\
\\216\003\137\003\137\003\008\000\
\\018\000\174\001\254\001\243\003\
\\243\003\250\001\239\002\004\000\
\\204\000\008\000\205\000\008\000\
\\206\000\008\000\252\001\004\000\
\\207\000\037\000\086\000\008\000\
\\208\000\209\000\210\000\211\000\
\\208\003\003\000\212\000\201\003\
\\003\000\050\000\005\000\018\000\
\\087\002\242\002\146\002\024\000\
\\147\000\147\000\070\000\135\003\
\\155\000\133\003\004\000\237\001\
\\210\002\008\000\236\001\238\002\
\\233\001\089\002\087\000\088\000\
\\009\003\004\000\034\000\192\003\
\\089\000\175\001\167\000\008\000\
\\231\001\150\001\147\000\205\003\
\\194\003\195\003\151\001\147\000\
\\147\000\198\003\008\000\144\003\
\\008\000\162\002\126\003\072\000\
\\227\002\217\002\162\001\215\002\
\\221\002\225\002\220\002\222\002\
\\030\000\147\000\074\000\147\000\
\\152\001\024\000\112\002\040\000\
\\142\003\055\000\147\000\234\003\
\\228\003\233\003\153\001\038\000\
\\199\001\136\000\024\000\140\003\
\\018\000\055\000\145\000\148\000\
\\008\000\024\000\008\000\008\000\
\\008\000\008\000\014\000\161\000\
\\028\000\164\000\208\003\166\000\
\\090\000\053\000\055\000\003\000\
\\127\003\213\000\135\003\128\003\
\\147\000\200\001\147\000\201\001\
\\212\002\117\001\068\003\091\000\
\\099\003\214\000\086\003\083\003\
\\092\000\079\003\215\000\176\001\
\\193\003\128\001\054\000\055\000\
\\055\000\056\000\056\000\056\000\
\\056\000\056\000\056\000\056\000\
\\093\000\094\000\056\000\095\000\
\\056\000\056\000\056\000\149\003\
\\055\000\056\000\056\000\056\000\
\\096\000\056\000\056\000\119\003\
\\055\000\055\000\055\000\055\000\
\\055\000\055\000\055\000\156\003\
\\148\003\000\003\216\000\118\001\
\\032\002\022\002\095\003\147\000\
\\230\002\154\001\177\001\202\001\
\\146\000\147\000\018\000\242\003\
\\166\001\167\001\240\003\238\003\
\\045\002\015\002\082\002\085\002\
\\131\002\188\002\018\000\206\001\
\\024\000\195\002\018\000\055\000\
\\008\000\008\000\055\000\147\000\
\\147\000\231\003\226\003\230\003\
\\155\001\203\001\018\000\138\003\
\\024\000\196\001\122\002\217\000\
\\218\000\219\000\229\001\005\002\
\\003\002\220\000\221\000\008\000\
\\116\002\110\002\222\000\223\000\
\\224\000\223\003\024\000\055\000\
\\225\000\249\001\248\001\102\002\
\\099\002\018\000\226\000\117\003\
\\199\002\135\003\228\000\229\000\
\\242\001\241\001\019\002\018\003\
\\135\000\230\000\015\000\143\002\
\\231\000\073\003\232\000\040\000\
\\098\000\013\003\096\003\093\003\
\\233\000\085\003\081\003\088\003\
\\040\002\069\002\099\000\129\001\
\\132\003\234\000\235\000\097\003\
\\089\003\001\003\070\000\251\002\
\\236\000\237\000\008\000\155\002\
\\239\000\153\002\008\000\013\002\
\\012\002\011\002\024\000\196\002\
\\246\002\244\002\140\002\241\000\
\\194\002\130\002\242\000\243\003\
\\243\000\244\000\217\003\055\000\
\\245\000\246\000\107\002\147\002\
\\024\000\248\000\249\000\250\000\
\\251\000\239\001\252\000\238\001\
\\253\000\228\001\254\000\255\000\
\\009\002\008\002\192\003\100\000\
\\008\000\000\001\088\002\097\002\
\\096\002\178\002\209\003\018\000\
\\132\002\202\003\024\000\001\001\
\\115\003\163\002\018\000\018\000\
\\008\000\004\003\003\001\071\002\
\\004\001\168\000\147\000\008\000\
\\006\000\070\000\008\003\147\000\
\\051\002\130\001\130\000\008\000\
\\006\001\214\002\018\000\193\002\
\\003\000\008\000\192\002\133\002\
\\003\000\115\003\113\003\121\003\
\\031\000\008\000\101\000\024\000\
\\055\000\156\001\024\000\024\000\
\\002\002\023\003\157\001\171\002\
\\229\003\235\003\018\000\170\002\
\\074\000\121\002\147\000\074\000\
\\224\003\018\000\223\003\223\003\
\\223\003\018\000\018\000\079\002\
\\018\000\178\001\008\000\018\000\
\\147\000\179\001\136\003\169\002\
\\168\002\167\002\166\002\104\003\
\\007\001\076\000\111\003\017\003\
\\078\000\106\003\078\003\008\000\
\\152\003\008\001\189\003\024\000\
\\009\001\055\000\010\001\011\001\
\\012\001\013\001\014\001\015\001\
\\016\001\017\001\018\001\019\001\
\\020\001\021\001\022\001\023\001\
\\024\001\055\000\025\001\026\001\
\\027\001\055\000\028\001\029\001\
\\055\000\055\000\102\000\030\001\
\\031\001\032\001\033\001\034\001\
\\070\000\180\001\192\003\159\002\
\\027\000\018\000\024\000\158\002\
\\027\000\027\000\191\002\157\002\
\\046\002\248\002\250\002\185\002\
\\246\003\237\003\184\002\136\002\
\\158\001\190\002\134\002\227\003\
\\232\003\008\000\189\002\128\002\
\\117\002\024\000\098\002\095\002\
\\144\002\255\001\024\000\113\002\
\\114\002\108\002\040\000\020\003\
\\206\002\225\003\219\003\018\000\
\\244\001\035\001\024\000\118\003\
\\197\002\036\001\205\002\204\002\
\\037\001\072\002\190\001\103\000\
\\247\003\135\000\141\002\069\003\
\\191\001\040\000\076\000\077\000\
\\038\001\039\001\087\003\082\003\
\\134\003\008\000\040\001\169\000\
\\119\001\023\002\021\002\041\001\
\\181\002\177\002\042\001\176\002\
\\175\002\174\002\239\003\043\001\
\\180\002\018\000\244\003\024\000\
\\135\002\218\003\024\000\018\000\
\\024\000\105\002\145\002\018\000\
\\018\000\024\000\179\002\064\002\
\\235\001\234\001\232\001\066\002\
\\131\001\131\000\044\001\008\000\
\\045\001\046\001\008\000\018\000\
\\116\003\200\002\149\002\187\002\
\\186\002\137\002\181\001\182\001\
\\032\000\065\002\005\001\208\002\
\\047\001\011\003\067\002\183\001\
\\120\001\033\002\042\002\204\003\
\\206\003\197\003\199\003\018\000\
\\018\000\114\003\104\000\216\002\
\\105\000\159\001\024\000\018\000\
\\212\003\147\000\018\000\024\000\
\\227\000\238\000\240\000\008\000\
\\247\000\024\000\002\001\018\000\
\\024\000\132\001\104\003\097\000\
\\076\003\048\001\108\003\049\001\
\\084\003\134\000\050\001\106\003\
\\102\003\039\000\034\002\186\003\
\\190\003\051\001\174\003\052\001\
\\163\003\162\003\172\003\171\003\
\\170\003\183\003\182\003\254\002\
\\158\003\169\003\155\003\160\003\
\\159\003\161\003\175\003\191\003\
\\166\003\165\003\164\003\053\001\
\\168\003\167\003\054\001\055\001\
\\056\001\179\003\177\003\178\003\
\\176\003\185\003\154\003\008\000\
\\133\001\231\002\228\002\160\001\
\\147\000\204\001\008\000\213\003\
\\134\001\057\001\111\002\058\001\
\\059\001\060\001\201\002\024\000\
\\024\000\026\000\073\002\255\002\
\\024\000\170\000\061\001\062\001\
\\073\003\063\001\015\003\064\001\
\\007\000\033\000\192\003\002\003\
\\236\003\065\001\014\002\066\001\
\\067\001\068\001\129\002\118\002\
\\150\002\070\001\071\001\008\000\
\\121\001\024\002\072\001\203\003\
\\196\003\115\003\073\001\024\000\
\\008\000\106\000\010\003\012\003\
\\008\000\192\003\165\002\164\002\
\\107\000\184\001\074\001\024\000\
\\215\003\172\002\223\003\018\000\
\\018\000\044\002\192\001\105\003\
\\100\003\109\003\101\003\076\000\
\\080\003\107\003\184\003\173\003\
\\187\003\188\003\180\003\181\003\
\\026\002\025\002\075\001\018\000\
\\161\002\160\002\214\003\024\000\
\\124\002\000\002\022\003\207\002\
\\211\003\076\001\077\001\078\001\
\\016\000\079\001\104\003\074\003\
\\067\003\193\001\016\003\028\002\
\\057\002\052\002\024\000\108\000\
\\135\001\173\002\182\002\138\002\
\\210\003\127\002\119\002\148\002\
\\183\002\139\002\080\001\192\003\
\\230\001\018\000\202\002\027\002\
\\061\002\058\002\109\000\036\002\
\\136\001\122\003\081\001\024\000\
\\185\001\069\001\076\000\103\003\
\\186\001\229\002\137\001\120\002\
\\043\002\251\003\135\000\082\001\
\\083\001\171\000\053\002\110\000\
\\084\001\030\002\138\001\085\001\
\\135\003\086\001\087\001\123\003\
\\223\002\024\000\047\003\008\000\
\\125\002\024\000\249\003\076\000\
\\104\003\135\003\088\001\008\000\
\\089\001\203\002\090\001\135\003\
\\187\001\224\002\071\003\111\000\
\\035\002\091\001\092\001\093\001\
\\094\001\135\003\095\001\008\000\
\\188\001\096\001\008\000\112\000\
\\139\001\025\003\024\003\024\000\
\\113\000\097\001\027\003\076\000\
\\023\000\098\001\029\002\099\001\
\\024\000\189\001\037\002\140\001\
\\051\003\114\000\048\003\141\001\
\\115\000\142\001\049\003\116\000\
\\250\003\100\001\117\000\101\001\
\\054\002\024\000\024\000\031\002\
\\059\002\024\000\052\003\143\001\
\\057\003\122\001\026\003\144\001\
\\055\003\123\001\050\003\124\001\
\\145\001\053\003\125\001\072\003\
\\118\000\102\001\119\000\027\003\
\\055\002\056\002\060\002\058\003\
\\146\001\061\003\056\003\147\001\
\\063\003\148\001\065\003\054\003\
\\149\001\059\003\103\001\031\003\
\\120\000\028\003\121\000\104\001\
\\029\003\122\000\105\001\062\003\
\\064\003\066\003\060\003\032\003\
\\106\001\037\003\107\001\108\001\
\\035\003\109\001\030\003\110\001\
\\111\001\033\003\112\001\070\003\
\\038\003\113\001\041\003\036\003\
\\114\001\043\003\115\001\045\003\
\\034\003\116\001\040\003\042\003\
\\044\003\046\003\039\003\000\000"
val gotoT =
"\
\\001\000\187\005\002\000\027\000\003\000\026\000\004\000\025\000\
\\005\000\024\000\006\000\023\000\007\000\022\000\008\000\021\000\
\\009\000\020\000\010\000\019\000\012\000\018\000\013\000\017\000\
\\014\000\016\000\021\000\015\000\022\000\014\000\023\000\013\000\
\\024\000\012\000\025\000\011\000\026\000\010\000\064\000\009\000\
\\065\000\008\000\071\000\007\000\075\000\006\000\082\000\005\000\
\\125\000\004\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\107\000\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\116\000\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\117\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\126\000\133\000\125\000\134\000\124\000\000\000\
\\065\000\126\000\133\000\125\000\134\000\128\000\000\000\
\\065\000\126\000\133\000\129\000\000\000\
\\000\000\
\\064\000\131\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\132\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\133\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\135\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\137\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\138\000\000\000\
\\064\000\139\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\140\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\142\000\059\000\141\000\000\000\
\\064\000\143\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\145\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\146\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\147\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\149\000\065\000\008\000\067\000\148\000\127\000\003\000\
\\128\000\002\000\000\000\
\\039\000\142\000\059\000\150\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\152\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\153\000\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\142\000\059\000\154\000\000\000\
\\000\000\
\\016\000\158\000\020\000\157\000\000\000\
\\000\000\
\\000\000\
\\016\000\166\000\019\000\165\000\020\000\157\000\000\000\
\\016\000\167\000\020\000\157\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\168\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\169\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\170\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\174\000\123\000\173\000\124\000\172\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\179\000\064\000\149\000\065\000\008\000\067\000\178\000\
\\127\000\003\000\128\000\002\000\141\000\177\000\000\000\
\\039\000\182\000\064\000\149\000\065\000\008\000\067\000\181\000\
\\127\000\003\000\128\000\002\000\000\000\
\\041\000\185\000\042\000\184\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\183\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\139\000\186\000\000\000\
\\139\000\188\000\000\000\
\\139\000\189\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\190\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\193\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\196\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\194\000\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\198\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\025\001\065\000\008\000\066\000\024\001\127\000\003\000\
\\128\000\002\000\000\000\
\\040\000\027\001\064\000\026\001\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\139\000\029\001\000\000\
\\139\000\030\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\084\000\036\001\085\000\035\001\000\000\
\\039\000\038\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\039\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\042\001\127\000\003\000\128\000\002\000\137\000\041\001\
\\138\000\040\001\139\000\001\000\000\000\
\\064\000\044\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\045\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\047\001\000\000\
\\065\000\126\000\133\000\049\001\135\000\048\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\068\000\053\001\071\000\007\000\
\\075\000\006\000\082\000\052\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\139\000\054\001\000\000\
\\139\000\055\001\000\000\
\\040\000\058\001\056\000\057\001\058\000\056\001\000\000\
\\000\000\
\\048\000\063\001\049\000\062\001\051\000\061\001\000\000\
\\140\000\065\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\198\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\074\001\000\000\
\\139\000\075\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\076\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\139\000\077\001\000\000\
\\139\000\078\001\000\000\
\\000\000\
\\065\000\126\000\133\000\125\000\134\000\079\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\080\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\126\000\133\000\125\000\134\000\081\001\000\000\
\\064\000\082\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\083\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\084\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\087\001\055\000\086\001\057\000\085\001\000\000\
\\039\000\088\001\000\000\
\\000\000\
\\139\000\089\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\095\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\139\000\103\001\000\000\
\\139\000\105\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\108\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\109\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\116\001\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\131\001\000\000\
\\139\000\134\001\000\000\
\\071\000\135\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\137\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\139\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\150\001\065\000\008\000\071\000\149\001\075\000\006\000\
\\079\000\148\001\080\000\147\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\071\000\149\001\075\000\006\000\079\000\151\001\139\000\001\000\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\152\001\
\\126\000\115\001\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\155\001\
\\126\000\115\001\000\000\
\\139\000\156\001\000\000\
\\045\000\160\001\047\000\159\001\048\000\063\001\049\000\158\001\000\000\
\\045\000\160\001\047\000\162\001\048\000\063\001\049\000\158\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\163\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\165\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\167\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\171\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\126\000\133\000\125\000\134\000\172\001\000\000\
\\065\000\126\000\133\000\125\000\134\000\173\001\000\000\
\\065\000\126\000\133\000\174\001\000\000\
\\064\000\176\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\177\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\178\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\180\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\181\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\182\001\000\000\
\\039\000\183\001\000\000\
\\039\000\184\001\000\000\
\\064\000\185\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\186\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\187\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\142\000\059\000\141\000\000\000\
\\064\000\189\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\191\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\192\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\025\001\065\000\008\000\066\000\193\001\127\000\003\000\
\\128\000\002\000\000\000\
\\064\000\194\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\025\001\065\000\008\000\066\000\195\001\127\000\003\000\
\\128\000\002\000\000\000\
\\039\000\087\001\055\000\086\001\057\000\196\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\200\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\201\001\000\000\
\\000\000\
\\017\000\206\001\018\000\205\001\000\000\
\\015\000\209\001\020\000\208\001\000\000\
\\086\000\211\001\087\000\210\001\000\000\
\\000\000\
\\017\000\206\001\018\000\216\001\000\000\
\\015\000\217\001\020\000\208\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\220\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\116\000\221\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\223\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\116\000\224\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\225\001\123\000\173\000\124\000\172\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\179\000\064\000\025\001\065\000\008\000\066\000\228\001\
\\127\000\003\000\128\000\002\000\141\000\227\001\000\000\
\\039\000\230\001\064\000\025\001\065\000\008\000\066\000\229\001\
\\127\000\003\000\128\000\002\000\000\000\
\\071\000\232\001\075\000\006\000\081\000\231\001\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\234\001\071\000\007\000\
\\075\000\006\000\082\000\233\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\235\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\232\001\075\000\006\000\081\000\236\001\139\000\001\000\000\000\
\\064\000\025\001\065\000\008\000\066\000\237\001\127\000\003\000\
\\128\000\002\000\139\000\186\000\000\000\
\\139\000\188\000\000\000\
\\139\000\189\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\240\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\243\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\040\000\245\001\064\000\244\001\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\139\000\029\001\000\000\
\\139\000\030\001\000\000\
\\000\000\
\\064\000\250\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\251\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\253\001\127\000\003\000\128\000\002\000\137\000\041\001\
\\138\000\252\001\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\255\001\127\000\003\000\128\000\002\000\137\000\041\001\
\\138\000\254\001\139\000\001\000\000\000\
\\064\000\000\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\001\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\039\000\003\002\000\000\
\\065\000\126\000\133\000\005\002\134\000\004\002\000\000\
\\000\000\
\\000\000\
\\064\000\008\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\009\002\071\000\007\000\
\\075\000\006\000\082\000\233\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\010\002\071\000\007\000\
\\075\000\006\000\082\000\233\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\097\000\012\002\100\000\011\002\139\000\054\001\000\000\
\\093\000\015\002\096\000\014\002\139\000\055\001\000\000\
\\040\000\058\001\056\000\057\001\058\000\056\001\000\000\
\\000\000\
\\048\000\063\001\049\000\062\001\051\000\019\002\000\000\
\\000\000\
\\064\000\025\001\065\000\008\000\066\000\021\002\127\000\003\000\
\\128\000\002\000\000\000\
\\071\000\022\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\024\002\
\\126\000\115\001\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\025\002\
\\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\030\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\031\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\137\000\041\001\138\000\032\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\034\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\198\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\035\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\036\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\032\000\037\002\000\000\
\\139\000\041\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\048\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\098\000\051\002\099\000\050\002\101\000\049\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\094\000\057\002\095\000\056\002\098\000\051\002\
\\099\000\055\002\101\000\054\002\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\040\000\058\001\056\000\059\002\000\000\
\\000\000\
\\000\000\
\\071\000\061\002\075\000\006\000\139\000\001\000\000\000\
\\048\000\063\001\049\000\062\001\051\000\062\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\064\002\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\068\000\065\002\071\000\007\000\
\\075\000\006\000\082\000\052\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\066\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\068\000\067\002\071\000\007\000\
\\075\000\006\000\082\000\052\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\069\002\065\000\008\000\071\000\110\000\072\000\068\002\
\\075\000\006\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\071\002\065\000\008\000\071\000\110\000\072\000\070\002\
\\075\000\006\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\032\000\037\002\000\000\
\\064\000\150\001\065\000\008\000\080\000\147\001\127\000\003\000\
\\128\000\002\000\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\073\002\
\\126\000\115\001\000\000\
\\139\000\074\002\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\075\002\
\\126\000\115\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\094\000\057\002\095\000\056\002\101\000\076\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\078\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\087\001\055\000\080\002\000\000\
\\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\082\002\126\000\115\001\136\000\081\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\088\002\126\000\115\001\136\000\081\002\000\000\
\\064\000\089\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\090\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\142\000\059\000\091\002\000\000\
\\000\000\
\\139\000\092\002\000\000\
\\139\000\093\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\094\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\095\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\139\000\110\002\000\000\
\\139\000\111\002\000\000\
\\044\000\114\002\046\000\113\002\048\000\112\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\116\002\126\000\115\001\136\000\081\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\117\002\126\000\115\001\136\000\081\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\118\002\126\000\115\001\136\000\081\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\119\002\126\000\115\001\136\000\081\002\000\000\
\\064\000\149\000\065\000\008\000\067\000\120\002\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\122\002\060\000\121\002\000\000\
\\039\000\087\001\055\000\086\001\057\000\125\002\000\000\
\\027\000\127\002\029\000\126\002\000\000\
\\039\000\087\001\055\000\086\001\057\000\130\002\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\132\002\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\133\002\126\000\115\001\000\000\
\\048\000\118\001\089\000\134\002\126\000\115\001\000\000\
\\000\000\
\\064\000\168\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\170\002\048\000\112\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\172\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\173\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\016\000\166\000\019\000\174\002\020\000\157\000\000\000\
\\039\000\178\002\064\000\177\002\065\000\008\000\076\000\176\002\
\\077\000\175\002\127\000\003\000\128\000\002\000\000\000\
\\039\000\178\002\064\000\177\002\065\000\008\000\076\000\176\002\
\\077\000\179\002\127\000\003\000\128\000\002\000\000\000\
\\064\000\149\000\065\000\008\000\067\000\180\002\127\000\003\000\
\\128\000\002\000\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\181\002\126\000\115\001\136\000\081\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\182\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\123\000\173\000\124\000\183\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\186\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\187\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\188\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\189\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\190\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\041\000\185\000\042\000\191\002\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\183\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\140\000\192\002\000\000\
\\140\000\193\002\000\000\
\\136\000\194\002\000\000\
\\136\000\196\002\000\000\
\\000\000\
\\140\000\198\002\000\000\
\\000\000\
\\000\000\
\\140\000\201\002\000\000\
\\048\000\118\001\089\000\208\002\107\000\085\002\108\000\207\002\
\\109\000\206\002\110\000\084\002\111\000\205\002\112\000\083\002\
\\113\000\204\002\115\000\203\002\126\000\115\001\136\000\202\002\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\209\002\126\000\115\001\136\000\081\002\000\000\
\\000\000\
\\000\000\
\\045\000\160\001\047\000\211\002\048\000\063\001\049\000\158\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\213\002\126\000\115\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\215\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\216\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\217\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\221\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\126\000\133\000\125\000\134\000\222\002\000\000\
\\064\000\223\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\224\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\225\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\087\001\055\000\086\001\057\000\226\002\000\000\
\\039\000\227\002\000\000\
\\106\000\229\002\114\000\228\002\139\000\089\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\237\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\239\002\054\000\238\002\000\000\
\\071\000\240\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\106\000\229\002\114\000\242\002\139\000\103\001\000\000\
\\106\000\229\002\114\000\243\002\139\000\105\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\249\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\251\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\031\000\252\002\000\000\
\\039\000\087\001\055\000\086\001\057\000\254\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\017\000\206\001\018\000\003\003\000\000\
\\015\000\004\003\020\000\208\001\000\000\
\\027\000\006\003\028\000\005\003\000\000\
\\000\000\
\\000\000\
\\086\000\211\001\087\000\009\003\000\000\
\\048\000\118\001\089\000\117\001\091\000\011\003\126\000\115\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\013\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\014\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\229\002\114\000\020\003\139\000\134\001\000\000\
\\071\000\021\003\075\000\006\000\139\000\001\000\000\000\
\\048\000\118\001\089\000\022\003\126\000\115\001\000\000\
\\071\000\023\003\075\000\006\000\139\000\001\000\000\000\
\\071\000\024\003\075\000\006\000\139\000\001\000\000\000\
\\071\000\025\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\232\001\075\000\006\000\081\000\032\003\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\033\003\071\000\007\000\
\\075\000\006\000\082\000\233\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\035\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\116\000\039\003\118\000\038\003\000\000\
\\116\000\039\003\118\000\040\003\000\000\
\\104\000\042\003\105\000\041\003\139\000\156\001\000\000\
\\045\000\160\001\047\000\044\003\048\000\063\001\049\000\158\001\000\000\
\\045\000\160\001\047\000\045\003\048\000\063\001\049\000\158\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\046\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\047\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\116\000\039\003\118\000\049\003\000\000\
\\116\000\039\003\118\000\050\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\051\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\002\000\052\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\054\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\058\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\002\000\059\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\065\000\126\000\133\000\125\000\134\000\079\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\070\000\065\003\071\000\007\000\
\\075\000\006\000\082\000\233\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\012\002\100\000\070\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\101\000\071\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\093\000\015\002\096\000\073\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\101\000\074\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\040\000\058\001\056\000\057\001\058\000\075\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\076\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\077\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\078\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\140\000\079\003\000\000\
\\140\000\080\003\000\000\
\\032\000\081\003\000\000\
\\044\000\114\002\046\000\082\003\048\000\112\002\000\000\
\\084\000\036\001\085\000\083\003\000\000\
\\044\000\114\002\046\000\084\003\048\000\112\002\000\000\
\\002\000\086\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\087\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\088\003\083\000\167\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\091\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\065\000\126\000\133\000\049\001\135\000\092\003\000\000\
\\048\000\118\001\089\000\117\001\091\000\093\003\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\086\000\211\001\087\000\096\003\000\000\
\\064\000\009\000\065\000\008\000\068\000\097\003\071\000\007\000\
\\075\000\006\000\082\000\052\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\140\000\099\003\000\000\
\\136\000\100\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\102\003\000\000\
\\140\000\103\003\000\000\
\\136\000\104\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\105\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\106\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\032\000\107\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\111\003\000\000\
\\048\000\118\001\089\000\113\003\108\000\207\002\109\000\206\002\
\\111\000\205\002\113\000\204\002\126\000\115\001\136\000\112\003\000\000\
\\140\000\114\003\000\000\
\\000\000\
\\064\000\116\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\117\003\000\000\
\\000\000\
\\048\000\118\001\089\000\118\003\126\000\115\001\000\000\
\\140\000\119\003\000\000\
\\000\000\
\\110\000\084\002\112\000\120\003\136\000\081\002\000\000\
\\110\000\084\002\112\000\121\003\136\000\081\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\124\003\000\000\
\\064\000\125\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\071\000\149\001\075\000\006\000\079\000\148\001\139\000\001\000\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\126\003\
\\126\000\115\001\000\000\
\\139\000\127\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\128\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\129\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\130\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\131\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\132\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\133\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\134\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\040\000\137\003\064\000\136\003\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\097\000\012\002\100\000\011\002\000\000\
\\000\000\
\\000\000\
\\048\000\063\001\049\000\062\001\051\000\139\003\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\140\003\
\\126\000\115\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\098\000\051\002\099\000\055\002\101\000\049\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\142\003\048\000\112\002\000\000\
\\000\000\
\\140\000\143\003\000\000\
\\000\000\
\\140\000\145\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\142\000\059\000\148\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\136\000\152\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\158\003\102\000\157\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\160\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\161\003\126\000\115\001\000\000\
\\044\000\162\003\048\000\112\002\000\000\
\\044\000\163\003\048\000\112\002\000\000\
\\044\000\164\003\048\000\112\002\000\000\
\\044\000\165\003\048\000\112\002\000\000\
\\044\000\166\003\048\000\112\002\000\000\
\\044\000\167\003\048\000\112\002\000\000\
\\044\000\168\003\048\000\112\002\000\000\
\\000\000\
\\000\000\
\\044\000\171\003\048\000\112\002\000\000\
\\000\000\
\\044\000\173\003\048\000\112\002\000\000\
\\044\000\174\003\048\000\112\002\000\000\
\\044\000\175\003\048\000\112\002\000\000\
\\000\000\
\\048\000\118\001\089\000\177\003\103\000\176\003\126\000\115\001\000\000\
\\044\000\178\003\048\000\112\002\000\000\
\\044\000\179\003\048\000\112\002\000\000\
\\044\000\180\003\048\000\112\002\000\000\
\\000\000\
\\044\000\182\003\048\000\112\002\000\000\
\\044\000\183\003\048\000\112\002\000\000\
\\000\000\
\\048\000\118\001\089\000\185\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\186\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\187\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\188\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\189\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\190\003\126\000\115\001\000\000\
\\048\000\118\001\089\000\158\003\102\000\191\003\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\195\003\000\000\
\\136\000\196\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\200\003\000\000\
\\140\000\202\003\000\000\
\\071\000\203\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\179\000\141\000\204\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\149\001\075\000\006\000\079\000\205\003\139\000\001\000\000\000\
\\000\000\
\\064\000\150\001\065\000\008\000\080\000\206\003\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\071\000\207\003\075\000\006\000\139\000\001\000\000\000\
\\048\000\118\001\089\000\154\001\117\000\153\001\119\000\208\003\
\\126\000\115\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\209\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\211\003\065\000\008\000\071\000\210\003\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\048\000\118\001\089\000\212\003\126\000\115\001\000\000\
\\140\000\213\003\000\000\
\\140\000\214\003\000\000\
\\000\000\
\\109\000\206\002\111\000\215\003\136\000\112\003\000\000\
\\109\000\206\002\111\000\216\003\136\000\112\003\000\000\
\\000\000\
\\000\000\
\\071\000\219\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\220\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\227\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\229\002\114\000\233\003\000\000\
\\064\000\234\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\048\000\118\001\089\000\235\003\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\237\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\039\000\239\002\054\000\239\003\000\000\
\\000\000\
\\044\000\114\002\046\000\241\003\048\000\112\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\245\003\129\000\244\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\061\000\252\003\000\000\
\\000\000\
\\039\000\087\001\055\000\086\001\057\000\000\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\027\000\006\003\028\000\003\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\006\004\048\000\112\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\011\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\014\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\018\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\019\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\116\000\039\003\118\000\022\004\000\000\
\\000\000\
\\000\000\
\\104\000\042\003\105\000\025\004\000\000\
\\048\000\118\001\089\000\026\004\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\031\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\040\004\126\000\115\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\042\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\044\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\045\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\040\000\048\004\053\000\047\004\000\000\
\\000\000\
\\071\000\050\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\051\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\053\004\065\000\008\000\071\000\052\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\057\004\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\058\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\000\083\000\165\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\032\000\061\004\033\000\060\004\000\000\
\\000\000\
\\140\000\062\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\065\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\071\000\067\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\098\000\051\002\099\000\068\004\101\000\049\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\069\004\065\000\008\000\071\000\067\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\094\000\057\002\095\000\070\004\101\000\076\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\040\000\048\004\053\000\071\004\000\000\
\\039\000\073\004\052\000\072\004\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\068\000\075\004\071\000\007\000\
\\075\000\006\000\082\000\052\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\211\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\048\000\118\001\089\000\077\004\126\000\115\001\000\000\
\\000\000\
\\064\000\053\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\069\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\080\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\081\004\126\000\115\001\136\000\081\002\000\000\
\\000\000\
\\140\000\082\004\000\000\
\\048\000\118\001\089\000\086\002\107\000\085\002\110\000\084\002\
\\112\000\083\002\115\000\203\002\126\000\115\001\136\000\081\002\000\000\
\\106\000\229\002\114\000\228\002\000\000\
\\071\000\084\004\075\000\006\000\139\000\001\000\000\000\
\\106\000\229\002\114\000\242\002\000\000\
\\106\000\229\002\114\000\243\002\000\000\
\\106\000\229\002\114\000\020\003\000\000\
\\071\000\085\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\086\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\088\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\076\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\090\004\075\000\006\000\139\000\001\000\000\000\
\\140\000\091\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\094\004\037\000\093\004\000\000\
\\000\000\
\\031\000\098\004\035\000\097\004\000\000\
\\031\000\098\004\035\000\099\004\000\000\
\\000\000\
\\027\000\127\002\029\000\100\004\000\000\
\\031\000\104\004\034\000\103\004\038\000\102\004\039\000\101\004\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\106\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\158\003\102\000\108\004\126\000\115\001\000\000\
\\064\000\109\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\048\000\118\001\089\000\111\004\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\158\003\102\000\127\004\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\131\004\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\134\004\126\000\115\001\000\000\
\\048\000\118\001\089\000\135\004\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\142\004\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\144\004\126\000\115\001\000\000\
\\000\000\
\\039\000\178\002\064\000\177\002\065\000\008\000\076\000\176\002\
\\077\000\145\004\127\000\003\000\128\000\002\000\000\000\
\\071\000\146\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\147\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\178\002\064\000\177\002\065\000\008\000\076\000\176\002\
\\077\000\148\004\127\000\003\000\128\000\002\000\000\000\
\\039\000\178\002\064\000\177\002\065\000\008\000\076\000\176\002\
\\077\000\149\004\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\151\004\065\000\008\000\071\000\080\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\152\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\153\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\155\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\229\002\114\000\156\004\139\000\124\003\000\000\
\\071\000\157\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\159\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\245\003\129\000\162\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\164\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\087\001\055\000\086\001\057\000\166\004\000\000\
\\031\000\098\004\035\000\099\004\000\000\
\\031\000\167\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\006\004\048\000\112\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\171\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\177\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\071\000\179\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\180\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\181\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\182\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\183\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\071\000\184\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\185\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\186\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\190\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\193\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\194\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\061\004\033\000\199\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\202\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\203\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\151\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\208\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\140\000\209\004\000\000\
\\071\000\210\003\075\000\006\000\139\000\001\000\000\000\
\\064\000\210\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\211\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\212\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\071\000\052\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\213\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\031\000\094\004\037\000\215\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\098\004\035\000\217\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\104\004\034\000\103\004\038\000\221\004\039\000\101\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\229\004\065\000\008\000\071\000\228\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\232\004\000\000\
\\000\000\
\\064\000\234\004\065\000\008\000\071\000\208\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\241\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\242\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\243\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\245\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\061\000\249\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\253\004\065\000\008\000\071\000\252\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\000\005\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\010\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\040\000\048\004\053\000\013\005\000\000\
\\000\000\
\\064\000\015\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\017\005\065\000\008\000\071\000\016\005\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\019\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\048\000\118\001\089\000\117\001\091\000\020\005\126\000\115\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\234\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\106\000\229\002\114\000\156\004\000\000\
\\071\000\177\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\025\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\027\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\029\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\030\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\031\000\094\004\037\000\036\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\038\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\118\001\089\000\117\001\091\000\042\005\126\000\115\001\000\000\
\\000\000\
\\071\000\043\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\048\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\031\000\050\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\053\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\062\005\048\000\112\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\065\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\131\000\066\005\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\068\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\069\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\031\000\070\005\000\000\
\\031\000\094\004\037\000\071\005\000\000\
\\044\000\114\002\046\000\072\005\048\000\112\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\074\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\077\005\048\000\112\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\080\005\132\000\079\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\114\002\046\000\089\005\048\000\112\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\091\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\094\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\043\000\095\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\025\001\065\000\008\000\066\000\099\005\127\000\003\000\
\\128\000\002\000\000\000\
\\043\000\101\005\132\000\100\005\000\000\
\\000\000\
\\130\000\105\005\000\000\
\\031\000\107\005\000\000\
\\064\000\108\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\112\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\115\005\000\000\
\\000\000\
\\000\000\
\\043\000\119\005\000\000\
\\000\000\
\\000\000\
\\043\000\124\005\132\000\123\005\000\000\
\\000\000\
\\000\000\
\\043\000\129\005\132\000\128\005\000\000\
\\000\000\
\\000\000\
\\064\000\132\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\133\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\134\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\136\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\139\005\000\000\
\\000\000\
\\043\000\141\005\000\000\
\\000\000\
\\000\000\
\\043\000\144\005\000\000\
\\000\000\
\\043\000\146\005\000\000\
\\000\000\
\\043\000\151\005\132\000\150\005\000\000\
\\130\000\154\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\160\005\000\000\
\\000\000\
\\043\000\163\005\000\000\
\\000\000\
\\000\000\
\\043\000\168\005\132\000\167\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\173\005\000\000\
\\000\000\
\\000\000\
\\043\000\176\005\000\000\
\\000\000\
\\043\000\178\005\000\000\
\\000\000\
\\000\000\
\\043\000\181\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 1468
val numrules = 542
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle General.Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(List.map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int*int
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | CHARACTER of unit ->  (int) | STRING of unit ->  (int list)
 | ID of unit ->  (string) | ANY_ID of unit ->  (string)
 | PRIVATE_ID of unit ->  (string)
 | param_asgn_exp_list of unit ->  ( ( A.param * A.expression )  list)
 | rcb of unit ->  (unit) | lcb of unit ->  (unit)
 | phrase_pair_list of unit ->  ( ( A.phrase * A.phrase * A.pos * A.pos * A.pos )  list)
 | phrase_pair of unit ->  ( ( A.phrase * A.phrase * A.pos * A.pos * A.pos ) )
 | single_logical_or of unit ->  (unit)
 | one_or_more_mod_symbols_infix of unit ->  ( ( A.mod_symbol * A.pos )  list)
 | one_or_more_mod_symbols of unit ->  ( ( A.mod_symbol * A.pos )  list)
 | one_mod_symbol of unit ->  (A.mod_symbol*A.pos)
 | associativity of unit ->  (bool)
 | sb_declaration_prec_assoc of unit ->  ({ overload_sym:A.param option,precedence:int option,assoc:bool option,input_transformer:A.expression list option } )
 | declaration_prec_assoc of unit ->  ({ overload_sym:A.param option,precedence:int option,assoc:bool option,input_transformer:A.expression list option } )
 | one_or_more_athena_vars of unit ->  (AthTermVar.ath_term_var list)
 | athena_meta_id of unit ->  (A.expression)
 | ath_var of unit ->  (A.expression)
 | athena_var of unit ->  (AthTermVar.ath_term_var)
 | symbol_definition of unit ->  (A.absyn_symbol_definition)
 | assignments of unit ->  (A.binding list)
 | assignment of unit ->  (A.binding)
 | semicolon_separated_expressions of unit ->  (A.expression list)
 | semicolon_separated_deductions of unit ->  (A.deduction list)
 | semicolon_separated_phrases of unit ->  (A.phrase list)
 | semicolon_separated_bindings of unit ->  (A.binding list)
 | bindings of unit ->  (A.binding list)
 | binding_assignment of unit ->  (A.binding)
 | binding of unit ->  (A.binding)
 | infix_dmatch_clauses of unit ->  (A.dmatch_clause list)
 | dmatch_clauses of unit ->  (A.dmatch_clause list)
 | infix_match_clauses of unit ->  (A.match_clause list)
 | sep_infix_dmatch_clauses of unit ->  (A.dmatch_clause list)
 | sep_infix_match_clauses of unit ->  (A.match_clause list)
 | sep_infix_dmatch_clause of unit ->  (A.dmatch_clause)
 | sep_infix_match_clause of unit ->  (A.match_clause)
 | infix_match_clause of unit ->  (A.match_clause)
 | infix_dmatch_clause of unit ->  (A.dmatch_clause)
 | dmatch_clause of unit ->  (A.dmatch_clause)
 | match_clauses of unit ->  (A.match_clause list)
 | match_clause of unit ->  (A.match_clause)
 | two_or_more_patterns of unit ->  (A.pattern list)
 | one_or_more_patterns of unit ->  (A.pattern list)
 | condition of unit ->  (A.condition)
 | dcheck_clauses of unit ->  (A.dcheck_clause list)
 | infix_dcheck_clauses of unit ->  (A.dcheck_clause list)
 | infix_dcheck_clause of unit ->  (A.dcheck_clause)
 | dcheck_clause of unit ->  (A.dcheck_clause)
 | check_clauses of unit ->  (A.check_clause list)
 | infix_check_clauses of unit ->  (A.check_clause list)
 | infix_check_clause of unit ->  (A.check_clause)
 | check_clause of unit ->  (A.check_clause)
 | struc_patterns of unit ->  (A.pattern list)
 | patterns of unit ->  (A.pattern list)
 | struc_pattern of unit ->  (A.pattern)
 | pattern of unit ->  (A.pattern)
 | definitions of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | def_blocks of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | def_block of unit ->  (A.possibly_typed_param*A.expression)
 | infix_def_blocks of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | infix_def_block of unit ->  (A.possibly_typed_param*A.expression)
 | phrases of unit ->  (A.phrase list) | phrase of unit ->  (A.phrase)
 | one_or_more_deductions of unit ->  (A.deduction list)
 | one_or_more_separated_expressions of unit ->  (A.expression list)
 | one_or_more_separated_deductions of unit ->  (A.deduction list)
 | deductions of unit ->  (A.deduction list)
 | case_clauses of unit ->  (A.case_clause list)
 | case_clause of unit ->  (A.case_clause)
 | inference_block of unit ->  (A.deduction)
 | inference_list of unit ->  (A.optBinding list)
 | possibly_named_inference of unit ->  (A.optBinding)
 | inference of unit ->  (A.deduction)
 | deduction of unit ->  (A.deduction)
 | one_or_more_phrases of unit ->  (A.phrase list)
 | opt_comma_separated_phrase_list of unit ->  (A.phrase list)
 | comma_separated_phrase_list of unit ->  (A.phrase list)
 | comma_separated_expression_list of unit ->  (A.expression list)
 | one_or_more_expressions of unit ->  (A.expression list)
 | any_id of unit ->  (string) | expression of unit ->  (A.expression)
 | one_or_more_ids of unit ->  (string list)
 | bracket_enclosed_possible_obtype_params of unit ->  (A.param list)
 | possible_obtype_params of unit ->  (A.param list)
 | comma_separated_possible_obtype_params of unit ->  (A.param list)
 | one_or_more_comma_separated_params of unit ->  (A.param list)
 | one_or_more_params_no_dots of unit ->  (A.param list)
 | one_or_more_params of unit ->  (A.param list)
 | one_or_more_params_maybe_with_reps_no_dots of unit ->  (A.param list)
 | one_or_more_params_maybe_with_reps of unit ->  (A.param list)
 | params of unit ->  (A.param list)
 | param_option_no_dots of unit ->  (S.symbol option)
 | param_option of unit ->  (S.symbol option)
 | possibly_typed_params_no_dots of unit ->  (A.possibly_typed_param list)
 | possibly_typed_params of unit ->  (A.possibly_typed_param list)
 | possibly_typed_param_no_dots of unit ->  (A.possibly_typed_param)
 | possibly_typed_param of unit ->  (A.possibly_typed_param)
 | possibly_wildcard_param_list_no_dots of unit ->  (A.possibly_wildcard_param list)
 | possibly_wildcard_param_list of unit ->  (A.possibly_wildcard_param list)
 | possibly_wildcard_param_no_dots of unit ->  (A.possibly_wildcard_param)
 | possibly_wildcard_param of unit ->  (A.possibly_wildcard_param)
 | input_transformer_declaration of unit ->  (A.expression list)
 | map_bindings of unit ->  (A.phrase list)
 | map_binding of unit ->  (A.phrase)
 | param_no_dots of unit ->  (A.param) | param of unit ->  (A.param)
 | selector_tagged_athena_object_type_list of unit ->  ( ( A.param option * A.absyn_term )  list)
 | athena_object_type_list of unit ->  (A.absyn_term list)
 | one_or_more_selector_tagged_athena_object_types of unit ->  ( ( A.param option * A.absyn_term )  list)
 | one_or_more_athena_object_types of unit ->  (A.absyn_term list)
 | selector_tagged_athena_object_type of unit ->  ( ( A.param option * A.absyn_term ) )
 | one_or_more_user_sorts of unit ->  (A.absyn_term list)
 | user_sort of unit ->  (A.absyn_term)
 | athena_object_type of unit ->  (A.absyn_term)
 | one_or_more_type_vars of unit ->  (A.param list)
 | infix_one_or_more_ath_structure_constructors of unit ->  (A.absyn_structure_constructor list)
 | one_or_more_ath_structure_constructors of unit ->  (A.absyn_structure_constructor list)
 | ath_structure_constructor of unit ->  (A.absyn_structure_constructor)
 | ath_fsym of unit ->  (A.absyn_fsym list)
 | ath_constant_sym of unit ->  (A.absyn_fsym list)
 | subsorts of unit ->  ( ( A.mod_symbol * A.pos )  list* ( A.mod_symbol * A.pos ) )
 | subsort of unit ->  (A.mod_symbol*A.pos*A.mod_symbol*A.pos)
 | ath_domains of unit ->  (A.absyn_domain list)
 | ath_domain of unit ->  (A.absyn_domain)
 | ath_structure_profile of unit ->  (A.absyn_structure_profile)
 | one_or_more_rec_ath_datatype_clauses of unit ->  (A.absyn_structure list)
 | one_or_more_rec_ath_struc_clauses of unit ->  (A.absyn_structure list)
 | rec_ath_struc_clause of unit ->  (A.absyn_structure)
 | infix_ath_struc_clause of unit ->  (A.absyn_structure)
 | ath_struc_clause of unit ->  (A.absyn_structure)
 | infix_ath_datatypes of unit ->  (A.absyn_structure list)
 | ath_datatypes of unit ->  (A.absyn_structure list)
 | ath_structures of unit ->  (A.absyn_structure list)
 | infix_ath_structure of unit ->  (A.absyn_structure)
 | infix_ath_datatype of unit ->  (A.absyn_structure)
 | ath_datatype of unit ->  (A.absyn_structure)
 | ath_structure of unit ->  (A.absyn_structure)
 | directive of unit ->  (A.directive)
 | core_user_input of unit ->  (A.user_input)
 | user_input of unit ->  (A.user_input)
 | moduleExtension of unit ->  (A.module_entry)
 | module of unit ->  (A.module_entry)
 | input_list of unit ->  (A.user_input list)
 | input_stream of unit ->  (A.user_input list)
end
type svalue = MlyValue.svalue
type result = A.user_input list
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn (T 91) => true | (T 93) => true | (T 75) => true | (T 97) => true
 | (T 98) => true | (T 73) => true | (T 74) => true | _ => false
val preferred_change : (term list * term list) list = 
(nil
,nil
 $$ (T 63))::
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "PICK_ANY"
  | (T 2) => "PICK_WITNESS"
  | (T 3) => "PICK_WITNESSES"
  | (T 4) => "CHECK"
  | (T 5) => "DCHECK"
  | (T 6) => "ELSE"
  | (T 7) => "THEN"
  | (T 8) => "LOGICAL_AND"
  | (T 9) => "LOGICAL_OR"
  | (T 10) => "OP"
  | (T 11) => "EXPAND_INPUT"
  | (T 12) => "PRIVATE_ID"
  | (T 13) => "PRIVATE"
  | (T 14) => "OPEN_MODULE"
  | (T 15) => "EXTEND_MODULE"
  | (T 16) => "ANY_ID"
  | (T 17) => "RE_STAR"
  | (T 18) => "RE_PLUS"
  | (T 19) => "RE_OPTIONAL"
  | (T 20) => "RE_LIT"
  | (T 21) => "RE_REP"
  | (T 22) => "RE_RANGE"
  | (T 23) => "ID"
  | (T 24) => "STRING"
  | (T 25) => "SOME_FUNCTION"
  | (T 26) => "SOME_METHOD"
  | (T 27) => "EXIT_ATHENA"
  | (T 28) => "FROM"
  | (T 29) => "FOR"
  | (T 30) => "START_LOAD"
  | (T 31) => "END_LOAD"
  | (T 32) => "TRANSFORM_OUTPUT"
  | (T 33) => "CHARACTER"
  | (T 34) => "LOAD_FILE"
  | (T 35) => "DIF_ELSE"
  | (T 36) => "NAME"
  | (T 37) => "SOME_TERM"
  | (T 38) => "COLON"
  | (T 39) => "OVERLOAD"
  | (T 40) => "OVERLOAD_INV"
  | (T 41) => "MODULE"
  | (T 42) => "DEFINE_STAR"
  | (T 43) => "DEFINE_MEMOIZED"
  | (T 44) => "SOME_ATOM"
  | (T 45) => "SOME_PROP"
  | (T 46) => "QMARK"
  | (T 47) => "EXCL_MARK"
  | (T 48) => "QUOTE_WORD"
  | (T 49) => "QUOTE_SYMBOL"
  | (T 50) => "EXPAND_NEXT_PROOF"
  | (T 51) => "LEFT_CURLY_BRACE"
  | (T 52) => "RIGHT_CURLY_BRACE"
  | (T 53) => "BACK_QUOTE_SYMBOL"
  | (T 54) => "LETREC"
  | (T 55) => "DLETREC"
  | (T 56) => "SPLIT_PAT"
  | (T 57) => "BY"
  | (T 58) => "PRINT_STACK_TRACE"
  | (T 59) => "SEMI_COLON"
  | (T 60) => "CONCLUDE"
  | (T 61) => "DOUBLE_LEFT_CURLY_BRACE"
  | (T 62) => "DOUBLE_RIGHT_CURLY_BRACE"
  | (T 63) => "LPAREN"
  | (T 64) => "RPAREN"
  | (T 65) => "COMMA"
  | (T 66) => "CLAIM"
  | (T 67) => "LEFT_BRACKET"
  | (T 68) => "RIGHT_BRACKET"
  | (T 69) => "SET"
  | (T 70) => "ARROW"
  | (T 71) => "WILDCARD"
  | (T 72) => "SOME_CHAR"
  | (T 73) => "FUNCTION"
  | (T 74) => "METHOD"
  | (T 75) => "MATCH"
  | (T 76) => "LET"
  | (T 77) => "LET_UPPER"
  | (T 78) => "DLET"
  | (T 79) => "TRY"
  | (T 80) => "DTRY"
  | (T 81) => "APPLY_METHOD"
  | (T 82) => "SOME_VAR"
  | (T 83) => "SEQ"
  | (T 84) => "DSEQ"
  | (T 85) => "SOME_VECTOR"
  | (T 86) => "MAP_BEGIN"
  | (T 87) => "MAP_END"
  | (T 88) => "EQUAL_SIGN"
  | (T 89) => "ASSERT"
  | (T 90) => "ASSERT_CLOSE"
  | (T 91) => "ASSUME"
  | (T 92) => "ASSUME_LET"
  | (T 93) => "SUPPOSE_ABSURD"
  | (T 94) => "SUPPOSE_ABSURD_LET"
  | (T 95) => "ON"
  | (T 96) => "PROVE"
  | (T 97) => "DMATCH"
  | (T 98) => "EITHER"
  | (T 99) => "ABSURD"
  | (T 100) => "MP"
  | (T 101) => "DN"
  | (T 102) => "EQUIV"
  | (T 103) => "LEFT_IFF"
  | (T 104) => "RIGHT_IFF"
  | (T 105) => "BOTH"
  | (T 106) => "ASGN"
  | (T 107) => "BY_CASES"
  | (T 108) => "FUN"
  | (T 109) => "META_ID"
  | (T 110) => "SOME_SYMBOL"
  | (T 111) => "LEFT_AND"
  | (T 112) => "RIGHT_AND"
  | (T 113) => "CD"
  | (T 114) => "VAL_OF"
  | (T 115) => "VAR"
  | (T 116) => "FUN_ARROW"
  | (T 117) => "DATATYPE"
  | (T 118) => "DATATYPES"
  | (T 119) => "DEFINE_SORT"
  | (T 120) => "SOME_LIST"
  | (T 121) => "SOME_CELL"
  | (T 122) => "SOME_SUB"
  | (T 123) => "SOME_TABLE"
  | (T 124) => "SOME_MAP"
  | (T 125) => "DEFINE"
  | (T 126) => "POUND"
  | (T 127) => "STRUCTURE"
  | (T 128) => "STRUCTURES"
  | (T 129) => "DOMAIN"
  | (T 130) => "WHERE"
  | (T 131) => "PROVIDED"
  | (T 132) => "DECLARE"
  | (T 133) => "DDECLARE"
  | (T 134) => "DIRECTIVE_PREFIX"
  | (T 135) => "EGEN"
  | (T 136) => "BEGIN"
  | (T 137) => "WHILE"
  | (T 138) => "CLEAR"
  | (T 139) => "THE"
  | (T 140) => "DEFINE_SYMBOL"
  | (T 141) => "DOMAINS"
  | (T 142) => "OVER"
  | (T 143) => "EGEN_UNIQUE"
  | (T 144) => "LEIBNIZ"
  | (T 145) => "EQ_REFLEX"
  | (T 146) => "SOME_QUANT"
  | (T 147) => "USPEC"
  | (T 148) => "FETCH"
  | (T 149) => "RETRACT"
  | (T 150) => "DEFINE_FUN"
  | (T 151) => "ADD_DEMON"
  | (T 152) => "ADD_DEMONS"
  | (T 153) => "SOME_PROP_CON"
  | (T 154) => "UNEQUAL_TERMS"
  | (T 155) => "INDUCTION"
  | (T 156) => "STRUCTURE_CASES"
  | (T 157) => "LIST"
  | (T 158) => "CELL"
  | (T 159) => "RULE"
  | (T 160) => "GEN_OVER"
  | (T 161) => "WITH_PREDICATE"
  | (T 162) => "WITH_KEYS"
  | (T 163) => "WITH_WITNESS"
  | (T 164) => "MAKE_CELL"
  | (T 165) => "REF"
  | (T 166) => "USE_TERM_PARSER"
  | (T 167) => "USE_PROP_PARSER"
  | (T 168) => "END"
  | (T 169) => "SPECIALIZE"
  | (T 170) => "SET_FLAG"
  | (T 171) => "EX_GENERALIZE"
  | (T 172) => "DATATYPE_CASES"
  | (T 173) => "DATATYPE_CASES_ON_TERM"
  | (T 174) => "SUBSORT"
  | (T 175) => "SUBSORTS"
  | (T 176) => "VECTOR_INIT"
  | (T 177) => "VECTOR_SUB"
  | (T 178) => "VECTOR_SET"
  | (T 179) => "SET_CNF_CONVERTER"
  | (T 180) => "GET_CNF_CONVERTER"
  | (T 181) => "ANY_PAT"
  | (T 182) => "SET_PRECEDENCE"
  | (T 183) => "LEFT_ASSOC"
  | (T 184) => "RIGHT_ASSOC"
  | (T 185) => "BIN_OP"
  | (T 186) => "ADD_PATH"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn (T 23) => MlyValue.ID(fn () => ("bogus")) | 
_ => MlyValue.VOID
end
val terms : term list = nil
 $$ (T 186) $$ (T 185) $$ (T 184) $$ (T 183) $$ (T 182) $$ (T 181) $$ 
(T 180) $$ (T 179) $$ (T 178) $$ (T 177) $$ (T 176) $$ (T 175) $$ (T 
174) $$ (T 173) $$ (T 172) $$ (T 171) $$ (T 170) $$ (T 169) $$ (T 168)
 $$ (T 167) $$ (T 166) $$ (T 165) $$ (T 164) $$ (T 163) $$ (T 162) $$ 
(T 161) $$ (T 160) $$ (T 159) $$ (T 158) $$ (T 157) $$ (T 156) $$ (T 
155) $$ (T 154) $$ (T 153) $$ (T 152) $$ (T 151) $$ (T 150) $$ (T 149)
 $$ (T 148) $$ (T 147) $$ (T 146) $$ (T 145) $$ (T 144) $$ (T 143) $$ 
(T 142) $$ (T 141) $$ (T 140) $$ (T 139) $$ (T 138) $$ (T 137) $$ (T 
136) $$ (T 135) $$ (T 134) $$ (T 133) $$ (T 132) $$ (T 131) $$ (T 130)
 $$ (T 129) $$ (T 128) $$ (T 127) $$ (T 126) $$ (T 125) $$ (T 124) $$ 
(T 123) $$ (T 122) $$ (T 121) $$ (T 120) $$ (T 119) $$ (T 118) $$ (T 
117) $$ (T 116) $$ (T 115) $$ (T 114) $$ (T 113) $$ (T 112) $$ (T 111)
 $$ (T 110) $$ (T 109) $$ (T 108) $$ (T 107) $$ (T 106) $$ (T 105) $$ 
(T 104) $$ (T 103) $$ (T 102) $$ (T 101) $$ (T 100) $$ (T 99) $$ (T 98
) $$ (T 97) $$ (T 96) $$ (T 95) $$ (T 94) $$ (T 93) $$ (T 92) $$ (T 91
) $$ (T 90) $$ (T 89) $$ (T 88) $$ (T 87) $$ (T 86) $$ (T 85) $$ (T 84
) $$ (T 83) $$ (T 82) $$ (T 81) $$ (T 80) $$ (T 79) $$ (T 78) $$ (T 77
) $$ (T 76) $$ (T 75) $$ (T 74) $$ (T 73) $$ (T 72) $$ (T 71) $$ (T 70
) $$ (T 69) $$ (T 68) $$ (T 67) $$ (T 66) $$ (T 65) $$ (T 64) $$ (T 63
) $$ (T 62) $$ (T 61) $$ (T 60) $$ (T 59) $$ (T 58) $$ (T 57) $$ (T 56
) $$ (T 55) $$ (T 54) $$ (T 53) $$ (T 52) $$ (T 51) $$ (T 50) $$ (T 49
) $$ (T 48) $$ (T 47) $$ (T 46) $$ (T 45) $$ (T 44) $$ (T 43) $$ (T 42
) $$ (T 41) $$ (T 40) $$ (T 39) $$ (T 38) $$ (T 37) $$ (T 36) $$ (T 35
) $$ (T 34) $$ (T 32) $$ (T 31) $$ (T 30) $$ (T 29) $$ (T 28) $$ (T 27
) $$ (T 26) $$ (T 25) $$ (T 22) $$ (T 21) $$ (T 20) $$ (T 19) $$ (T 18
) $$ (T 17) $$ (T 15) $$ (T 14) $$ (T 13) $$ (T 11) $$ (T 10) $$ (T 9)
 $$ (T 8) $$ (T 7) $$ (T 6) $$ (T 5) $$ (T 4) $$ (T 3) $$ (T 2) $$ (T 
1) $$ (T 0)end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.input_list input_list1, input_list1left, 
input_list1right)) :: rest671)) => let val  result = 
MlyValue.input_stream (fn _ => let val  (input_list as input_list1) = 
input_list1 ()
 in (input_list)
end)
 in ( LrTable.NT 0, ( result, input_list1left, input_list1right), 
rest671)
end
|  ( 1, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) :: 
rest671)) => let val  result = MlyValue.single_logical_or (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
let val res = if ID = "|" then () else raise  
                                     A.SyntaxError("the character | was expected here",SOME(getPos IDleft))
                       in res end
)
end)
 in ( LrTable.NT 135, ( result, ID1left, ID1right), rest671)
end
|  ( 2, ( ( _, ( MlyValue.user_input user_input1, user_input1left, 
user_input1right)) :: rest671)) => let val  result = 
MlyValue.input_list (fn _ => let val  (user_input as user_input1) = 
user_input1 ()
 in ([user_input])
end)
 in ( LrTable.NT 1, ( result, user_input1left, user_input1right), 
rest671)
end
|  ( 3, ( ( _, ( MlyValue.input_list input_list1, _, input_list1right)
) :: ( _, ( MlyValue.user_input user_input1, user_input1left, _)) :: 
rest671)) => let val  result = MlyValue.input_list (fn _ => let val  (
user_input as user_input1) = user_input1 ()
 val  (input_list as input_list1) = input_list1 ()
 in (user_input::input_list)
end)
 in ( LrTable.NT 1, ( result, user_input1left, input_list1right), 
rest671)
end
|  ( 4, ( ( _, ( MlyValue.core_user_input core_user_input1, 
core_user_input1left, core_user_input1right)) :: rest671)) => let val 
 result = MlyValue.user_input (fn _ => let val  (core_user_input as 
core_user_input1) = core_user_input1 ()
 in (core_user_input)
end)
 in ( LrTable.NT 4, ( result, core_user_input1left, 
core_user_input1right), rest671)
end
|  ( 5, ( ( _, ( _, _, SEMI_COLON1right)) :: ( _, ( 
MlyValue.core_user_input core_user_input1, core_user_input1left, _))
 :: rest671)) => let val  result = MlyValue.user_input (fn _ => let
 val  (core_user_input as core_user_input1) = core_user_input1 ()
 in (core_user_input)
end)
 in ( LrTable.NT 4, ( result, core_user_input1left, SEMI_COLON1right),
 rest671)
end
|  ( 6, ( ( _, ( MlyValue.ath_structure ath_structure1, 
ath_structure1left, ath_structure1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_structure as 
ath_structure1) = ath_structure1 ()
 in (A.structureInput(ath_structure))
end)
 in ( LrTable.NT 5, ( result, ath_structure1left, ath_structure1right)
, rest671)
end
|  ( 7, ( ( _, ( MlyValue.ath_datatype ath_datatype1, 
ath_datatype1left, ath_datatype1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_datatype as 
ath_datatype1) = ath_datatype1 ()
 in (A.structureInput(ath_datatype))
end)
 in ( LrTable.NT 5, ( result, ath_datatype1left, ath_datatype1right), 
rest671)
end
|  ( 8, ( ( _, ( MlyValue.infix_ath_datatype infix_ath_datatype1, 
infix_ath_datatype1left, infix_ath_datatype1right)) :: rest671)) =>
 let val  result = MlyValue.core_user_input (fn _ => let val  (
infix_ath_datatype as infix_ath_datatype1) = infix_ath_datatype1 ()
 in (A.structureInput(infix_ath_datatype))
end)
 in ( LrTable.NT 5, ( result, infix_ath_datatype1left, 
infix_ath_datatype1right), rest671)
end
|  ( 9, ( ( _, ( MlyValue.ath_datatypes ath_datatypes1, 
ath_datatypes1left, ath_datatypes1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_datatypes as 
ath_datatypes1) = ath_datatypes1 ()
 in (A.structuresInput(ath_datatypes))
end)
 in ( LrTable.NT 5, ( result, ath_datatypes1left, ath_datatypes1right)
, rest671)
end
|  ( 10, ( ( _, ( MlyValue.infix_ath_datatypes infix_ath_datatypes1, 
infix_ath_datatypes1left, infix_ath_datatypes1right)) :: rest671)) =>
 let val  result = MlyValue.core_user_input (fn _ => let val  (
infix_ath_datatypes as infix_ath_datatypes1) = infix_ath_datatypes1 ()
 in (A.structuresInput(infix_ath_datatypes))
end)
 in ( LrTable.NT 5, ( result, infix_ath_datatypes1left, 
infix_ath_datatypes1right), rest671)
end
|  ( 11, ( ( _, ( MlyValue.ath_structures ath_structures1, 
ath_structures1left, ath_structures1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_structures
 as ath_structures1) = ath_structures1 ()
 in (A.structuresInput(ath_structures))
end)
 in ( LrTable.NT 5, ( result, ath_structures1left, 
ath_structures1right), rest671)
end
|  ( 12, ( ( _, ( MlyValue.module module1, module1left, module1right))
 :: rest671)) => let val  result = MlyValue.core_user_input (fn _ =>
 let val  (module as module1) = module1 ()
 in (A.moduleInput(module))
end)
 in ( LrTable.NT 5, ( result, module1left, module1right), rest671)
end
|  ( 13, ( ( _, ( MlyValue.moduleExtension moduleExtension1, 
moduleExtension1left, moduleExtension1right)) :: rest671)) => let val 
 result = MlyValue.core_user_input (fn _ => let val  (moduleExtension
 as moduleExtension1) = moduleExtension1 ()
 in (A.moduleExtension(moduleExtension))
end)
 in ( LrTable.NT 5, ( result, moduleExtension1left, 
moduleExtension1right), rest671)
end
|  ( 14, ( ( _, ( MlyValue.ath_domain ath_domain1, ath_domain1left, 
ath_domain1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_domain as ath_domain1)
 = ath_domain1 ()
 in (A.domainInput(ath_domain))
end)
 in ( LrTable.NT 5, ( result, ath_domain1left, ath_domain1right), 
rest671)
end
|  ( 15, ( ( _, ( MlyValue.ath_domains ath_domains1, ath_domains1left,
 ath_domains1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_domains as 
ath_domains1) = ath_domains1 ()
 in (A.domainsInput(ath_domains))
end)
 in ( LrTable.NT 5, ( result, ath_domains1left, ath_domains1right), 
rest671)
end
|  ( 16, ( ( _, ( MlyValue.subsort subsort1, subsort1left, 
subsort1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (subsort as subsort1) = 
subsort1 ()
 in (A.subSortDeclaration(subsort))
end)
 in ( LrTable.NT 5, ( result, subsort1left, subsort1right), rest671)

end
|  ( 17, ( ( _, ( MlyValue.subsorts subsorts1, subsorts1left, 
subsorts1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (subsorts as subsorts1) = 
subsorts1 ()
 in (A.subSortsDeclaration(subsorts))
end)
 in ( LrTable.NT 5, ( result, subsorts1left, subsorts1right), rest671)

end
|  ( 18, ( ( _, ( MlyValue.ath_fsym ath_fsym1, ath_fsym1left, 
ath_fsym1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_fsym as ath_fsym1) = 
ath_fsym1 ()
 in (A.functionSymbolInput(ath_fsym))
end)
 in ( LrTable.NT 5, ( result, ath_fsym1left, ath_fsym1right), rest671)

end
|  ( 19, ( ( _, ( MlyValue.ath_constant_sym ath_constant_sym1, 
ath_constant_sym1left, ath_constant_sym1right)) :: rest671)) => let
 val  result = MlyValue.core_user_input (fn _ => let val  (
ath_constant_sym as ath_constant_sym1) = ath_constant_sym1 ()
 in (A.constantSymbolInput(ath_constant_sym))
end)
 in ( LrTable.NT 5, ( result, ath_constant_sym1left, 
ath_constant_sym1right), rest671)
end
|  ( 20, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right))
 :: rest671)) => let val  result = MlyValue.core_user_input (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 in (A.phraseInput(phrase))
end)
 in ( LrTable.NT 5, ( result, phrase1left, phrase1right), rest671)
end
|  ( 21, ( ( _, ( MlyValue.symbol_definition symbol_definition1, 
symbol_definition1left, symbol_definition1right)) :: rest671)) => let
 val  result = MlyValue.core_user_input (fn _ => let val  (
symbol_definition as symbol_definition1) = symbol_definition1 ()
 in (A.symbolDefinitionInput(symbol_definition))
end)
 in ( LrTable.NT 5, ( result, symbol_definition1left, 
symbol_definition1right), rest671)
end
|  ( 22, ( ( _, ( MlyValue.directive directive1, directive1left, 
directive1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (directive as directive1) =
 directive1 ()
 in (A.direcInput(directive))
end)
 in ( LrTable.NT 5, ( result, directive1left, directive1right), 
rest671)
end
|  ( 23, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LOAD_FILEleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.loadFile(expression,getPos(LOAD_FILEleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 24, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, ADD_PATHleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.addPath(expression, getPos(ADD_PATHleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 25, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_phrases 
one_or_more_phrases1, _, _)) :: _ :: ( _, ( _, EXPAND_INPUTleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_phrases as 
one_or_more_phrases1) = one_or_more_phrases1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.expandInput(one_or_more_phrases,phrase,getPos(EXPAND_INPUTleft)))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 26, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, (
 MlyValue.comma_separated_phrase_list comma_separated_phrase_list1, _,
 _)) :: ( _, ( _, (EXPAND_INPUTleft as EXPAND_INPUT1left), _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.expandInput(comma_separated_phrase_list,phrase,getPos(EXPAND_INPUTleft))
)
end)
 in ( LrTable.NT 6, ( result, EXPAND_INPUT1left, phrase1right), 
rest671)
end
|  ( 27, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) ::
 rest671)) => let val  result = MlyValue.directive (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.transformOutput(phrase1,phrase2,{first_arg_pos=getPos(phrase1left),second_arg_pos=getPos(phrase2left),
                                                    overall_pos=getPos(LPARENleft)})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 28, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
TRANSFORM_OUTPUTleft as TRANSFORM_OUTPUT1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  phrase1 = 
phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.transformOutput(phrase1,phrase2,{first_arg_pos=getPos(phrase1left),second_arg_pos=getPos(phrase2left),
                                                    overall_pos=getPos(TRANSFORM_OUTPUTleft)})
)
end)
 in ( LrTable.NT 6, ( result, TRANSFORM_OUTPUT1left, phrase2right), 
rest671)
end
|  ( 29, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, OVERLOADleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(LPARENleft),
                                                            getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOADleft),{inverted=false})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 30, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, OVERLOAD_INVleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(LPARENleft),
                                                                 getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOAD_INVleft),{inverted=true})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 31, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
OVERLOADleft as OVERLOAD1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(OVERLOADleft),
                                                getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOADleft),{inverted=false})
)
end)
 in ( LrTable.NT 6, ( result, OVERLOAD1left, phrase2right), rest671)

end
|  ( 32, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
OVERLOAD_INVleft as OVERLOAD_INV1left), _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(OVERLOAD_INVleft),
                                                    getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOAD_INVleft),{inverted=true})
)
end)
 in ( LrTable.NT 6, ( result, OVERLOAD_INV1left, phrase2right), 
rest671)
end
|  ( 33, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.phrase_pair_list phrase_pair_list1, _, _)) :: ( _, ( _, 
OVERLOADleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (phrase_pair_list
 as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOADleft),{inverted=false}))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 34, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.phrase_pair_list phrase_pair_list1, _, _)) :: ( _, ( _, 
OVERLOAD_INVleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (
phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOAD_INVleft),{inverted=true}))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 35, ( ( _, ( MlyValue.phrase_pair_list phrase_pair_list1, _, 
phrase_pair_list1right)) :: ( _, ( _, (OVERLOADleft as OVERLOAD1left),
 _)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOADleft),{inverted=false}))

end)
 in ( LrTable.NT 6, ( result, OVERLOAD1left, phrase_pair_list1right), 
rest671)
end
|  ( 36, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, ADD_DEMONleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.addDemon(expression,getPos(ADD_DEMONleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 37, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, ADD_DEMONSleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.directive (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (A.addDemons(one_or_more_expressions,getPos(ADD_DEMONSleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 38, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (ADD_DEMONleft as ADD_DEMON1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.addDemon(expression,getPos(ADD_DEMONleft)))
end)
 in ( LrTable.NT 6, ( result, ADD_DEMON1left, expression1right), 
rest671)
end
|  ( 39, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.STRING 
STRING1, STRINGleft, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param as param1) = param1 ()
 val  (STRING as STRING1) = STRING1 ()
 in (
let val str = String.implode(map (Char.chr) STRING)
             in
               A.setFlag(param,(str,getPos(STRINGleft)))
             end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 40, ( ( _, ( MlyValue.STRING STRING1, STRINGleft, STRING1right))
 :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, SET_FLAG1left, _
)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (param as param1) = param1 ()
 val  (STRING as STRING1) = STRING1 ()
 in (
let val str = String.implode(map (Char.chr) STRING)
             in
               A.setFlag(param,(str,getPos(STRINGleft)))
             end
)
end)
 in ( LrTable.NT 6, ( result, SET_FLAG1left, STRING1right), rest671)

end
|  ( 41, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (LOAD_FILEleft as LOAD_FILE1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.loadFile(expression,getPos(LOAD_FILEleft)))
end)
 in ( LrTable.NT 6, ( result, LOAD_FILE1left, expression1right), 
rest671)
end
|  ( 42, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (ADD_PATHleft as ADD_PATH1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.addPath(expression, getPos(ADD_PATHleft)))
end)
 in ( LrTable.NT 6, ( result, ADD_PATH1left, expression1right), 
rest671)
end
|  ( 43, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param param1
, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (param as param1) = 
param1 ()
 in (A.useTermParser({tp_name=param,file=(!Paths.current_file)}))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 44, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param param1
, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (param as param1) = 
param1 ()
 in (A.usePropParser({pp_name=param,file=(!Paths.current_file)}))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 45, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.expandNextProof(getPos(LPARENleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 46, ( ( _, ( _, (EXPAND_NEXT_PROOFleft as EXPAND_NEXT_PROOF1left)
, EXPAND_NEXT_PROOF1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (
A.expandNextProof(getPos(EXPAND_NEXT_PROOFleft))))
 in ( LrTable.NT 6, ( result, EXPAND_NEXT_PROOF1left, 
EXPAND_NEXT_PROOF1right), rest671)
end
|  ( 47, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.exitAthena(getPos(LPARENleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 48, ( ( _, ( _, (EXIT_ATHENAleft as EXIT_ATHENA1left), 
EXIT_ATHENA1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.exitAthena(getPos(EXIT_ATHENAleft))))
 in ( LrTable.NT 6, ( result, EXIT_ATHENA1left, EXIT_ATHENA1right), 
rest671)
end
|  ( 49, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, 
PRINT_STACK_TRACEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => (
A.printStackTrace(getPos(PRINT_STACK_TRACEleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 50, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1,
 _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (one_mod_symbol as 
one_mod_symbol1) = one_mod_symbol1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence([one_mod_symbol],expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 51, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _
)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence(one_or_more_mod_symbols,expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 52, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, _, _)) :: ( _, (
 _, SET_PRECEDENCE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_mod_symbol as 
one_mod_symbol1) = one_mod_symbol1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence([one_mod_symbol],expression))
end)
 in ( LrTable.NT 6, ( result, SET_PRECEDENCE1left, expression1right), 
rest671)
end
|  ( 53, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, _)) :: _ :: ( _, ( _, SET_PRECEDENCE1left
, _)) :: rest671)) => let val  result = MlyValue.directive (fn _ =>
 let val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence(one_or_more_mod_symbols,expression))
end)
 in ( LrTable.NT 6, ( result, SET_PRECEDENCE1left, expression1right), 
rest671)
end
|  ( 54, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,true))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 55, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 _, LEFT_ASSOC1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,true))
end)
 in ( LrTable.NT 6, ( result, LEFT_ASSOC1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 56, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,false))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 57, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 _, RIGHT_ASSOC1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,false))
end)
 in ( LrTable.NT 6, ( result, RIGHT_ASSOC1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 58, ( ( _, ( _, (PRINT_STACK_TRACEleft as PRINT_STACK_TRACE1left)
, PRINT_STACK_TRACE1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (
A.printStackTrace(getPos(PRINT_STACK_TRACEleft))))
 in ( LrTable.NT 6, ( result, PRINT_STACK_TRACE1left, 
PRINT_STACK_TRACE1right), rest671)
end
|  ( 59, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_mod_symbol one_mod_symbol1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (one_mod_symbol as one_mod_symbol1) = 
one_mod_symbol1 ()
 in (A.openModule([one_mod_symbol]))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 60, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.openModule(one_or_more_mod_symbols))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 61, ( ( _, ( MlyValue.one_or_more_mod_symbols_infix 
one_or_more_mod_symbols_infix1, _, one_or_more_mod_symbols_infix1right
)) :: ( _, ( _, OPEN_MODULE1left, _)) :: rest671)) => let val  result
 = MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols_infix
 as one_or_more_mod_symbols_infix1) = one_or_more_mod_symbols_infix1
 ()
 in (A.openModule(one_or_more_mod_symbols_infix))
end)
 in ( LrTable.NT 6, ( result, OPEN_MODULE1left, 
one_or_more_mod_symbols_infix1right), rest671)
end
|  ( 62, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.assert(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 63, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.assertClose(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 64, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.param_asgn_exp_list param_asgn_exp_list1, _, _)) :: _ :: ( _,
 ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param_asgn_exp_list as 
param_asgn_exp_list1) = param_asgn_exp_list1 ()
 in (A.assertCloseAsgn(param_asgn_exp_list))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 65, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.param param1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in (A.assertAsgn(param,expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 66, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, 
ASSERT1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in (A.assertAsgn(param,expression))
end)
 in ( LrTable.NT 6, ( result, ASSERT1left, expression1right), rest671)

end
|  ( 67, ( ( _, ( MlyValue.param_asgn_exp_list param_asgn_exp_list1, _
, param_asgn_exp_list1right)) :: ( _, ( _, ASSERT_CLOSE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
param_asgn_exp_list as param_asgn_exp_list1) = param_asgn_exp_list1 ()
 in (A.assertCloseAsgn(param_asgn_exp_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT_CLOSE1left, 
param_asgn_exp_list1right), rest671)
end
|  ( 68, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, ASSERT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.assert(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, ASSERT_CLOSE1left
, _)) :: rest671)) => let val  result = MlyValue.directive (fn _ =>
 let val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.assertClose(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT_CLOSE1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 70, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.retract(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, RETRACT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.retract(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, RETRACT1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 72, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val sym = S.symbol(ID)
                                                    val _ = A.checkNoDots(ID,getPos IDleft)
                                                in
                                                   A.sortDefinition(sym,phrase,false)
                                                end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 73, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, DEFINE_SORT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val sym = S.symbol(ID)
                                                    val _ = A.checkNoDots(ID,getPos IDleft)
                                                in
                                                   A.sortDefinition(sym,phrase,false)
                                                end
)
end)
 in ( LrTable.NT 6, ( result, DEFINE_SORT1left, phrase1right), rest671
)
end
|  ( 74, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let 
                                               val sym = S.symbol(ID)
                                               val _ = A.checkNoDots(ID,getPos IDleft)

                                           in
                                              A.definition(sym,phrase,false)
                                           end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 75, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,true)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 76, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.definitions([A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})],false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, expression1right), rest671)

end
|  ( 77, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos 
	      IDleft);
	      A.definitions([A.makeMethodDefinition({meth_name={name=S.symbol(ID),
	                                                       pos=getPos IDleft,
						     	       sort_as_sym_term=NONE,
                                               	     	       sort_as_fterm=NONE,
						     	       sort_as_exp=NONE,
						     	       op_tag=NONE},
					             meth_params=possibly_wildcard_param_list,	
						     meth_body=deduction,
						     pos=getPos IDleft,
						     file=(!Paths.current_file)})],false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, deduction1right), rest671)

end
|  ( 78, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE_MEMOIZED1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => let val  (ID as ID1)
 = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
	        if (length(possibly_wildcard_param_list) < 1)
		   then raise A.SyntaxError("Procedures of zero arguments cannot be memoized",SOME (A.posOfExp(expression)))
                else ();
	        let val p:A.phrase = A.makeMemoizedFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                                                  fun_params=possibly_wildcard_param_list,
 		                                                  fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
                    val _ = print("\nThe memoized definition was desugared into this: " ^ (A.unparsePhrase p))								   
                in
                    A.definition(Symbol.symbol(ID),p,false)
                end
)
end)
 in ( LrTable.NT 6, ( result, DEFINE_MEMOIZED1left, expression1right),
 rest671)
end
|  ( 79, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: 
( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,false))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 80, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)
) :: ( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _
, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,false)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 81, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: 
( _, ( _, LEFT_BRACKETleft, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)
) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,true))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 82, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)
) :: ( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _
, _)) :: _ :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,true)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 83, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, DEFINE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 84, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, ( _, PRIVATE1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,true)
)
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 85, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: ( _, ( _, DEFINE1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (patterns as 
patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,false))

end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 86, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: (
 _, ( _, DEFINE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),
                                                                                                           phrase,getPos LEFT_BRACKETleft,false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 87, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( _, PRIVATE1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => let val  (patterns
 as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,true))

end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 88, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: _
 :: ( _, ( _, PRIVATE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,true)
)
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 89, ( ( _, ( _, CLEAR1left, CLEAR1right)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => (A.clear_assum_base))
 in ( LrTable.NT 6, ( result, CLEAR1left, CLEAR1right), rest671)
end
|  ( 90, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.directive (fn _ => (
A.clear_assum_base))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 91, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.def_blocks 
def_blocks1, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (def_blocks
 as def_blocks1) = def_blocks1 ()
 in (A.definitions(def_blocks,false))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 92, ( ( _, ( MlyValue.infix_def_blocks infix_def_blocks1, _, 
infix_def_blocks1right)) :: ( _, ( _, DEFINE_STAR1left, _)) :: rest671
)) => let val  result = MlyValue.directive (fn _ => let val  (
infix_def_blocks as infix_def_blocks1) = infix_def_blocks1 ()
 in (A.definitions(infix_def_blocks,false))
end)
 in ( LrTable.NT 6, ( result, DEFINE_STAR1left, infix_def_blocks1right
), rest671)
end
|  ( 93, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.def_blocks 
def_blocks1, _, _)) :: _ :: _ :: ( _, ( _, PRIVATE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
def_blocks as def_blocks1) = def_blocks1 ()
 in (A.definitions(def_blocks,true))
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, RPAREN1right), rest671)

end
|  ( 94, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.ruleDefinition(S.symbol(ID),A.functionExp({params=possibly_wildcard_param_list,
	       body=expression,pos=getPos IDleft}))
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 95, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, RULE1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.ruleDefinition(S.symbol(ID),A.functionExp({params=possibly_wildcard_param_list,
	       body=expression,pos=getPos IDleft}))
)
end)
 in ( LrTable.NT 6, ( result, RULE1left, expression1right), rest671)

end
|  ( 96, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.param param1, param1left, _)) :: rest671))
 => let val  result = MlyValue.param_asgn_exp_list (fn _ => let val  (
param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in ([(param,expression)])
end)
 in ( LrTable.NT 140, ( result, param1left, expression1right), rest671
)
end
|  ( 97, ( ( _, ( MlyValue.param_asgn_exp_list param_asgn_exp_list1, _
, param_asgn_exp_list1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.param param1, param1left,
 _)) :: rest671)) => let val  result = MlyValue.param_asgn_exp_list
 (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 val  (param_asgn_exp_list as param_asgn_exp_list1) = 
param_asgn_exp_list1 ()
 in ((param,expression)::param_asgn_exp_list)
end)
 in ( LrTable.NT 140, ( result, param1left, param_asgn_exp_list1right)
, rest671)
end
|  ( 98, ( ( _, ( MlyValue.any_id any_id1, (any_idleft as any_id1left)
, any_id1right)) :: rest671)) => let val  result = 
MlyValue.one_mod_symbol (fn _ => let val  (any_id as any_id1) = 
any_id1 ()
 in (
let val id_pos = getPos(any_idleft)
                        in
                          (A.makeMS(any_id,SOME id_pos),id_pos)
                        end
)
end)
 in ( LrTable.NT 132, ( result, any_id1left, any_id1right), rest671)

end
|  ( 99, ( ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, one_mod_symbol1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_mod_symbols (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 in ([one_mod_symbol])
end)
 in ( LrTable.NT 133, ( result, one_mod_symbol1left, 
one_mod_symbol1right), rest671)
end
|  ( 100, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 MlyValue.one_mod_symbol one_mod_symbol1, one_mod_symbol1left, _)) :: 
rest671)) => let val  result = MlyValue.one_or_more_mod_symbols (fn _
 => let val  (one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 in (one_mod_symbol::one_or_more_mod_symbols)
end)
 in ( LrTable.NT 133, ( result, one_mod_symbol1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 101, ( ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, one_mod_symbol1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_mod_symbols_infix (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 in ([one_mod_symbol])
end)
 in ( LrTable.NT 134, ( result, one_mod_symbol1left, 
one_mod_symbol1right), rest671)
end
|  ( 102, ( ( _, ( MlyValue.one_or_more_mod_symbols_infix 
one_or_more_mod_symbols_infix1, _, one_or_more_mod_symbols_infix1right
)) :: _ :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_mod_symbols_infix (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 val  (one_or_more_mod_symbols_infix as one_or_more_mod_symbols_infix1
) = one_or_more_mod_symbols_infix1 ()
 in (one_mod_symbol::one_or_more_mod_symbols_infix)
end)
 in ( LrTable.NT 134, ( result, one_mod_symbol1left, 
one_or_more_mod_symbols_infix1right), rest671)
end
|  ( 103, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 104, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 105, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.def_block (fn _ => let val  (
ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 106, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.def_block (fn _ => let val  (
ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 107, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _, ( MlyValue.ID ID2
, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as 
ID1left), _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.def_block (fn _ => let val  (ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID1,getPos ID1left);
            (case (Int.fromString(ID2),Int.fromString(ID3)) of
             (SOME(i),SOME(j)) => 
               (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,j)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
            | _ => Data.genEx("Operator annotation error",
                              SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 108, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.def_block (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeMethodDefinition({meth_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                        meth_params=possibly_wildcard_param_list,
                                        meth_body=deduction,pos= getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, deduction1right), rest671)

end
|  ( 109, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.infix_def_block (fn _
 => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 110, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 111, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _, ( MlyValue.ID ID2
, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as 
ID1left), _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_block (fn _ => let val  (ID as ID1) = ID1
 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID1,getPos ID1left);
            (case (Int.fromString(ID2),Int.fromString(ID3)) of
             (SOME(i),SOME(j)) => 
               (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,j)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
            | _ => Data.genEx("Operator annotation error",
                              SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 112, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_block (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeMethodDefinition({meth_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                        meth_params=possibly_wildcard_param_list,
                                        meth_body=deduction,pos= getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, deduction1right), rest671)

end
|  ( 113, ( ( _, ( _, LEFT_CURLY_BRACE1left, LEFT_CURLY_BRACE1right))
 :: rest671)) => let val  result = MlyValue.lcb (fn _ => ())
 in ( LrTable.NT 138, ( result, LEFT_CURLY_BRACE1left, 
LEFT_CURLY_BRACE1right), rest671)
end
|  ( 114, ( ( _, ( _, RIGHT_CURLY_BRACE1left, RIGHT_CURLY_BRACE1right)
) :: rest671)) => let val  result = MlyValue.rcb (fn _ => ())
 in ( LrTable.NT 139, ( result, RIGHT_CURLY_BRACE1left, 
RIGHT_CURLY_BRACE1right), rest671)
end
|  ( 115, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.input_list 
input_list1, _, _)) :: ( _, ( MlyValue.param param1, paramleft, _)) ::
 _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.module (fn _ => let val  (param as param1) = param1 ()
 val  (input_list as input_list1) = input_list1 ()
 in (
if Symbol.symEq(#name(param),Names.top_module_symbol) then 
                                                  raise A.SyntaxError("The name Top cannot be used for a module",SOME(getPos paramleft))
                                               else
                                                   {module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 2, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 116, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.input_list input_list1, _, _)) :: ( _, ( MlyValue.lcb lcb1, _
, _)) :: ( _, ( MlyValue.param param1, paramleft, _)) :: ( _, ( _, 
MODULE1left, _)) :: rest671)) => let val  result = MlyValue.module (fn
 _ => let val  (param as param1) = param1 ()
 val  lcb1 = lcb1 ()
 val  (input_list as input_list1) = input_list1 ()
 val  rcb1 = rcb1 ()
 in (
if Symbol.symEq(#name(param),Names.top_module_symbol) then 
                                                  raise A.SyntaxError("The name Top cannot be used for a module",SOME(getPos paramleft))
                                         else {module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 2, ( result, MODULE1left, rcb1right), rest671)
end
|  ( 117, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.input_list 
input_list1, _, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.moduleExtension (fn _ => let val  (param as param1) = param1
 ()
 val  (input_list as input_list1) = input_list1 ()
 in (
{module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 3, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 118, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.input_list input_list1, _, _)) :: ( _, ( MlyValue.lcb lcb1, _
, _)) :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, 
EXTEND_MODULE1left, _)) :: rest671)) => let val  result = 
MlyValue.moduleExtension (fn _ => let val  (param as param1) = param1
 ()
 val  lcb1 = lcb1 ()
 val  (input_list as input_list1) = input_list1 ()
 val  rcb1 = rcb1 ()
 in (
{module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 3, ( result, EXTEND_MODULE1left, rcb1right), rest671)

end
|  ( 119, ( ( _, ( MlyValue.def_block def_block1, def_block1left, 
def_block1right)) :: rest671)) => let val  result = 
MlyValue.def_blocks (fn _ => let val  (def_block as def_block1) = 
def_block1 ()
 in ([def_block])
end)
 in ( LrTable.NT 86, ( result, def_block1left, def_block1right), 
rest671)
end
|  ( 120, ( ( _, ( MlyValue.def_blocks def_blocks1, _, 
def_blocks1right)) :: ( _, ( MlyValue.def_block def_block1, 
def_block1left, _)) :: rest671)) => let val  result = 
MlyValue.def_blocks (fn _ => let val  (def_block as def_block1) = 
def_block1 ()
 val  (def_blocks as def_blocks1) = def_blocks1 ()
 in (def_block::def_blocks)
end)
 in ( LrTable.NT 86, ( result, def_block1left, def_blocks1right), 
rest671)
end
|  ( 121, ( ( _, ( MlyValue.infix_def_block infix_def_block1, 
infix_def_block1left, infix_def_block1right)) :: rest671)) => let val 
 result = MlyValue.infix_def_blocks (fn _ => let val  (infix_def_block
 as infix_def_block1) = infix_def_block1 ()
 in ([infix_def_block])
end)
 in ( LrTable.NT 84, ( result, infix_def_block1left, 
infix_def_block1right), rest671)
end
|  ( 122, ( ( _, ( MlyValue.infix_def_blocks infix_def_blocks1, _, 
infix_def_blocks1right)) :: _ :: ( _, ( MlyValue.infix_def_block 
infix_def_block1, infix_def_block1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_blocks (fn _ => let val  (infix_def_block
 as infix_def_block1) = infix_def_block1 ()
 val  (infix_def_blocks as infix_def_blocks1) = infix_def_blocks1 ()
 in (infix_def_block::infix_def_blocks)
end)
 in ( LrTable.NT 84, ( result, infix_def_block1left, 
infix_def_blocks1right), rest671)
end
|  ( 123, ( ( _, ( MlyValue.athena_var athena_var1, athena_var1left, 
athena_var1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_athena_vars (fn _ => let val  (athena_var as 
athena_var1) = athena_var1 ()
 in ([athena_var])
end)
 in ( LrTable.NT 128, ( result, athena_var1left, athena_var1right), 
rest671)
end
|  ( 124, ( ( _, ( MlyValue.one_or_more_athena_vars 
one_or_more_athena_vars1, _, one_or_more_athena_vars1right)) :: ( _, (
 MlyValue.athena_var athena_var1, athena_var1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_athena_vars (fn _ => let val 
 (athena_var as athena_var1) = athena_var1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 in (athena_var::one_or_more_athena_vars)
end)
 in ( LrTable.NT 128, ( result, athena_var1left, 
one_or_more_athena_vars1right), rest671)
end
|  ( 125, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.any_id (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 64, ( result, ID1left, ID1right), rest671)
end
|  ( 126, ( ( _, ( MlyValue.PRIVATE_ID PRIVATE_ID1, PRIVATE_ID1left, 
PRIVATE_ID1right)) :: rest671)) => let val  result = MlyValue.any_id
 (fn _ => let val  (PRIVATE_ID as PRIVATE_ID1) = PRIVATE_ID1 ()
 in (PRIVATE_ID)
end)
 in ( LrTable.NT 64, ( result, PRIVATE_ID1left, PRIVATE_ID1right), 
rest671)
end
|  ( 127, ( ( _, ( MlyValue.phrase phrase2, _, phrase2right)) :: _ :: 
( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671)) => let
 val  result = MlyValue.map_binding (fn _ => let val  phrase1 = 
phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.exp(A.listExp({members=[phrase1,phrase2],pos=getPos(phrase1left)})))

end)
 in ( LrTable.NT 40, ( result, phrase1left, phrase2right), rest671)

end
|  ( 128, ( rest671)) => let val  result = MlyValue.map_bindings (fn _
 => ([]))
 in ( LrTable.NT 41, ( result, defaultPos, defaultPos), rest671)
end
|  ( 129, ( ( _, ( MlyValue.map_binding map_binding1, map_binding1left
, map_binding1right)) :: rest671)) => let val  result = 
MlyValue.map_bindings (fn _ => let val  (map_binding as map_binding1)
 = map_binding1 ()
 in ([map_binding])
end)
 in ( LrTable.NT 41, ( result, map_binding1left, map_binding1right), 
rest671)
end
|  ( 130, ( ( _, ( MlyValue.map_bindings map_bindings1, _, 
map_bindings1right)) :: _ :: ( _, ( MlyValue.map_binding map_binding1,
 map_binding1left, _)) :: rest671)) => let val  result = 
MlyValue.map_bindings (fn _ => let val  (map_binding as map_binding1)
 = map_binding1 ()
 val  (map_bindings as map_bindings1) = map_bindings1 ()
 in (map_binding::map_bindings)
end)
 in ( LrTable.NT 41, ( result, map_binding1left, map_bindings1right), 
rest671)
end
|  ( 131, ( ( _, ( MlyValue.any_id any_id1, (any_idleft as any_id1left
), any_id1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (any_id as any_id1) = any_id1 ()
 in (
let val id_pos = getPos(any_idleft) 
                        val mod_sym = A.makeMS(any_id,SOME id_pos)
                        val (mods,s) = MS.split(mod_sym)
                    in
                       A.idExp({msym=mod_sym,mods=mods,sym=s,no_mods=null(mods),pos=id_pos})
                    end
)
end)
 in ( LrTable.NT 63, ( result, any_id1left, any_id1right), rest671)

end
|  ( 132, ( ( _, ( _, _, DOUBLE_RIGHT_CURLY_BRACE1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, DOUBLE_LEFT_CURLY_BRACE1left, _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (hd one_or_more_expressions)
end)
 in ( LrTable.NT 63, ( result, DOUBLE_LEFT_CURLY_BRACE1left, 
DOUBLE_RIGHT_CURLY_BRACE1right), rest671)
end
|  ( 133, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.expression (fn _ => let
 val  (expression as expression1) = expression1 ()
 in (A.opExp({op_exp=expression,pos=getPos LPARENleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 134, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  (ID as ID1
) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
let val id_pos = getPos(IDleft)
                                in
                                   A.taggedConSym({name=A.makeMS(ID,SOME id_pos),pos=id_pos,sort_as_tagged_symterm=user_sort,sort_as_fterm=NONE})
                                end
)
end)
 in ( LrTable.NT 63, ( result, ID1left, user_sort1right), rest671)
end
|  ( 135, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => (A.unitExp({pos=getPos LPARENleft})))
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 136, ( ( _, ( MlyValue.CHARACTER CHARACTER1, (CHARACTERleft as 
CHARACTER1left), CHARACTER1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (CHARACTER as CHARACTER1) = 
CHARACTER1 ()
 in (A.charExp({code=CHARACTER,pos=getPos CHARACTERleft}))
end)
 in ( LrTable.NT 63, ( result, CHARACTER1left, CHARACTER1right), 
rest671)
end
|  ( 137, ( ( _, ( MlyValue.STRING STRING1, (STRINGleft as STRING1left
), STRING1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (A.stringExp({str=STRING,pos=getPos STRINGleft,mem_index=(~1)}))

end)
 in ( LrTable.NT 63, ( result, STRING1left, STRING1right), rest671)

end
|  ( 138, ( ( _, ( MlyValue.ath_var ath_var1, ath_var1left, 
ath_var1right)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (ath_var as ath_var1) = ath_var1 ()
 in (ath_var)
end)
 in ( LrTable.NT 63, ( result, ath_var1left, ath_var1right), rest671)

end
|  ( 139, ( ( _, ( MlyValue.athena_meta_id athena_meta_id1, 
athena_meta_id1left, athena_meta_id1right)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (athena_meta_id as 
athena_meta_id1) = athena_meta_id1 ()
 in (athena_meta_id)
end)
 in ( LrTable.NT 63, ( result, athena_meta_id1left, 
athena_meta_id1right), rest671)
end
|  ( 140, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( _, LOGICAL_ANDleft, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.logicalAndExp({args=[phrase1,phrase2],pos=getPos LOGICAL_ANDleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 141, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 LOGICAL_ANDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (
one_or_more_phrases as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (
A.logicalAndExp({args=one_or_more_phrases,pos=getPos LOGICAL_ANDleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 142, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 LOGICAL_ORleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (
one_or_more_phrases as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (
A.logicalOrExp({args=one_or_more_phrases,pos=getPos LOGICAL_ORleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 143, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( _, LOGICAL_ORleft, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.logicalOrExp({args=[phrase1,phrase2],pos=getPos LOGICAL_ORleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 144, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( _, MAKE_CELLleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 in (A.cellExp({contents=phrase,pos=getPos MAKE_CELLleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 145, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( _, (MAKE_CELLleft as MAKE_CELL1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 in (A.cellExp({contents=phrase,pos=getPos MAKE_CELLleft}))
end)
 in ( LrTable.NT 63, ( result, MAKE_CELL1left, phrase1right), rest671)

end
|  ( 146, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, REFleft, _)) :: ( _, ( _, LPAREN1left
, _)) :: rest671)) => let val  result = MlyValue.expression (fn _ =>
 let val  (expression as expression1) = expression1 ()
 in (A.refExp({cell_exp=expression,pos=getPos REFleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 147, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( _, (REFleft as REF1left), _)) :: rest671)
) => let val  result = MlyValue.expression (fn _ => let val  (
expression as expression1) = expression1 ()
 in (A.refExp({cell_exp=expression,pos=getPos REFleft}))
end)
 in ( LrTable.NT 63, ( result, REF1left, expression1right), rest671)

end
|  ( 148, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) :: (
 _, ( _, SETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.setCellExp({cell_exp=expression,
                                                               set_phrase=phrase,pos=getPos SETleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 149, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression1, _, _)) :: ( _, ( _, (SETleft as 
SET1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (expression as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.setCellExp({cell_exp=expression,
                                                               set_phrase=phrase,pos=getPos SETleft})
)
end)
 in ( LrTable.NT 63, ( result, SET1left, phrase1right), rest671)
end
|  ( 150, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) :: (
 _, ( _, VECTOR_INITleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.expression (fn _ => let val  (
expression as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorInitExp({length_exp=expression,
                                                               init_val=phrase,pos=getPos VECTOR_INITleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 151, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
VECTOR_INITleft as VECTOR_INIT1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorInitExp({length_exp=expression,
                                                               init_val=phrase,pos=getPos VECTOR_INITleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_INIT1left, phrase1right), 
rest671)
end
|  ( 152, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression2, _, _)) :: (
 _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, 
VECTOR_SETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  expression1 = 
expression1 ()
 val  expression2 = expression2 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorSetExp({vector_exp=expression1,
									index_exp=expression2,
                                                               new_val=phrase,pos=getPos VECTOR_SETleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 153, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression2, _, _)) :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( _, (VECTOR_SETleft
 as VECTOR_SET1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorSetExp({vector_exp=expression1,
									index_exp=expression2,
                                                               new_val=phrase,pos=getPos VECTOR_SETleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_SET1left, phrase1right), rest671
)
end
|  ( 154, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression2, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, VECTOR_SUBleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.vectorSubExp({vector_exp=expression1,
									    index_exp=expression2,
                                                                            pos=getPos VECTOR_SUBleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 155, ( ( _, ( MlyValue.expression expression2, _, 
expression2right)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, (VECTOR_SUBleft as VECTOR_SUB1left), _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  expression1 =
 expression1 ()
 val  expression2 = expression2 ()
 in (
A.vectorSubExp({vector_exp=expression1,
									    index_exp=expression2,
                                                                            pos=getPos VECTOR_SUBleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_SUB1left, expression2right), 
rest671)
end
|  ( 156, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, (
FUNCTIONleft as FUNCTION1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val infix_flag = (length(possibly_wildcard_param_list_no_dots) = 2)
                 in A.functionExp({params=possibly_wildcard_param_list_no_dots,body=expression,
                      pos=getPos FUNCTIONleft})
                 end
)
end)
 in ( LrTable.NT 63, ( result, FUNCTION1left, expression1right), 
rest671)
end
|  ( 157, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, 
FUNCTIONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val infix_flag = (length(possibly_wildcard_param_list_no_dots) = 2)
                 in A.functionExp({params=possibly_wildcard_param_list_no_dots,body=expression,
                      pos=getPos FUNCTIONleft})
                 end
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 158, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression2, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.params params1, _, _)) :: _ :: ( _, ( _, 
WITH_KEYSleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (params as 
params1) = params1 ()
 val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.desugarWithKeys(params,expression1,expression2,getPos WITH_KEYSleft)
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 159, ( ( _, ( MlyValue.expression expression2, _, 
expression2right)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, (
WITH_KEYSleft as WITH_KEYS1left), _)) :: rest671)) => let val  result
 = MlyValue.expression (fn _ => let val  (
one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.desugarWithKeys(one_or_more_comma_separated_params,expression1,expression2,getPos WITH_KEYSleft)
)
end)
 in ( LrTable.NT 63, ( result, WITH_KEYS1left, expression2right), 
rest671)
end
|  ( 160, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _
, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
A.appExp({proc=phrase,args=phrases,alt_exp=ref(NONE),pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 161, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.phrases phrases1, _, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrases as phrases1) = phrases1
 ()
 in (A.listExp({members=phrases,pos=getPos LEFT_BRACKETleft}))
end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 162, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.expression expression2, _, _)) :: _ :: ( _, ( 
MlyValue.pattern pattern1, _, _)) :: _ :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  expression2 = expression2 ()
 in (A.desugarListComprehension(expression1,pattern,expression2,NONE))

end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 163, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.expression expression3, _, _)) :: _ :: ( _, ( 
MlyValue.expression expression2, _, _)) :: _ :: ( _, ( 
MlyValue.pattern pattern1, _, _)) :: _ :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  expression2 = expression2 ()
 val  expression3 = expression3 ()
 in (
A.desugarListComprehension(expression1,pattern,expression2,SOME(expression3))
)
end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 164, ( ( _, ( _, _, MAP_END1right)) :: ( _, ( 
MlyValue.map_bindings map_bindings1, _, _)) :: ( _, ( _, (
MAP_BEGINleft as MAP_BEGIN1left), _)) :: rest671)) => let val  result
 = MlyValue.expression (fn _ => let val  (map_bindings as 
map_bindings1) = map_bindings1 ()
 in (A.makeMapExp(map_bindings,getPos(MAP_BEGINleft)))
end)
 in ( LrTable.NT 63, ( result, MAP_BEGIN1left, MAP_END1right), rest671
)
end
|  ( 165, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, 
METHODleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.methodExp({params=possibly_wildcard_param_list_no_dots,body=deduction,pos=getPos METHODleft,
                     name=ref("")})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 166, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, (
METHODleft as METHOD1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.methodExp({params=possibly_wildcard_param_list_no_dots,body=deduction,pos=getPos METHODleft,
                     name=ref("")})
)
end)
 in ( LrTable.NT 63, ( result, METHOD1left, deduction1right), rest671)

end
|  ( 167, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, TRYleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (A.tryExp({choices=one_or_more_expressions,pos=getPos TRYleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 168, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.one_or_more_separated_expressions 
one_or_more_separated_expressions1, _, _)) :: ( _, ( MlyValue.lcb lcb1
, _, _)) :: ( _, ( _, (TRYleft as TRY1left), _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  lcb1 = lcb1 ()
 val  (one_or_more_separated_expressions as 
one_or_more_separated_expressions1) = 
one_or_more_separated_expressions1 ()
 val  rcb1 = rcb1 ()
 in (
A.tryExp({choices=one_or_more_separated_expressions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 63, ( result, TRY1left, rcb1right), rest671)
end
|  ( 169, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.check_clauses check_clauses1, _, _)) :: ( _, ( _, CHECKleft,
 _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (check_clauses as check_clauses1
) = check_clauses1 ()
 in (A.checkExp({clauses=check_clauses,pos=getPos CHECKleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 170, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_check_clauses infix_check_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (CHECKleft as CHECK1left), _))
 :: rest671)) => let val  result = MlyValue.expression (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_check_clauses as infix_check_clauses1) = 
infix_check_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkExp({clauses=infix_check_clauses,pos=getPos CHECKleft}))

end)
 in ( LrTable.NT 63, ( result, CHECK1left, rcb1right), rest671)
end
|  ( 171, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_match_clauses infix_match_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (MATCHleft as MATCH1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_match_clauses as infix_match_clauses1) = 
infix_match_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchExp({discriminant=phrase,clauses=infix_match_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 63, ( result, MATCH1left, rcb1right), rest671)
end
|  ( 172, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.match_clauses match_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, MATCHleft, _)) :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (match_clauses as match_clauses1) = match_clauses1 ()
 in (
A.matchExp({discriminant=phrase,clauses=match_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 173, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETleft as 
LET1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letExp({bindings=semicolon_separated_bindings,body=expression,pos=getPos LETleft})
)
end)
 in ( LrTable.NT 63, ( result, LET1left, expression1right), rest671)

end
|  ( 174, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETRECleft as 
LETREC1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letRecExp({bindings=semicolon_separated_bindings,body=expression,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 63, ( result, LETREC1left, expression1right), rest671
)
end
|  ( 175, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (expression as expression1) = expression1 ()
 in (A.letExp({bindings=bindings,body=expression,pos=getPos LETleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 176, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, LETRECleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letRecExp({bindings=bindings,body=expression,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 177, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 SEQleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (one_or_more_phrases
 as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (A.beginExp({members=one_or_more_phrases,pos=getPos SEQleft}))
end
)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 178, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _,
 WHILEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.expression (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (A.whileExp({test=phrase1,body=phrase2,pos=getPos WHILEleft}))
end
)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 179, ( ( _, ( MlyValue.phrase phrase2, _, phrase2right)) :: ( _, 
( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (WHILEleft as 
WHILE1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (A.whileExp({test=phrase1,body=phrase2,pos=getPos WHILEleft}))
end
)
 in ( LrTable.NT 63, ( result, WHILE1left, phrase2right), rest671)
end
|  ( 180, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.expression expression1, _,
 _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                   pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 181, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                            pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 182, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
CONCLUDEleft as CONCLUDE1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                    pos=getPos CONCLUDEleft})
)
end)
 in ( LrTable.NT 70, ( result, CONCLUDE1left, deduction1right), 
rest671)
end
|  ( 183, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.param_no_dots param_no_dots1, _, _)) :: _ :: 
( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (param_no_dots as 
param_no_dots1) = param_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=SOME param_no_dots,
                                                                              pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 184, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: _ :: ( _, ( 
MlyValue.param_no_dots param_no_dots1, _, _)) :: ( _, ( _, (
CONCLUDEleft as CONCLUDE1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (param_no_dots as param_no_dots1)
 = param_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=SOME param_no_dots,
                                                                              pos=getPos CONCLUDEleft})
)
end)
 in ( LrTable.NT 70, ( result, CONCLUDE1left, deduction1right), 
rest671)
end
|  ( 185, ( ( _, ( MlyValue.inference_block inference_block1, 
inference_block1left, inference_block1right)) :: rest671)) => let val 
 result = MlyValue.deduction (fn _ => let val  (inference_block as 
inference_block1) = inference_block1 ()
 in (inference_block)
end)
 in ( LrTable.NT 70, ( result, inference_block1left, 
inference_block1right), rest671)
end
|  ( 186, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (ASSUMEleft
 as ASSUME1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeDed({assumption=phrase,body=deduction,pos=getPos ASSUMEleft}))

end)
 in ( LrTable.NT 70, ( result, ASSUME1left, deduction1right), rest671)

end
|  ( 187, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
SUPPOSE_ABSURDleft as SUPPOSE_ABSURD1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdDed({hyp=phrase,body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, SUPPOSE_ABSURD1left, deduction1right), 
rest671)
end
|  ( 188, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.assignments assignments1, _, _)) :: ( _, ( _, (
ASSUMEleft as ASSUME1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (assignments as assignments1) = 
assignments1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.infixAssumeDed({bindings=assignments,body=deduction,pos=getPos ASSUMEleft})
)
end)
 in ( LrTable.NT 70, ( result, ASSUME1left, deduction1right), rest671)

end
|  ( 189, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( _, (SUPPOSE_ABSURDleft as 
SUPPOSE_ABSURD1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                      A.absurdLetDed({named_hyp={bpat=A.idPat({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                                sort_as_fterm=NONE,sort_as_exp=NONE}),
                                                  def=phrase,pos=getPos IDleft},
                                      body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, SUPPOSE_ABSURD1left, deduction1right), 
rest671)
end
|  ( 190, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.case_clauses 
case_clauses1, _, _)) :: _ :: ( _, ( MlyValue.phrase phrase1, _, _))
 :: ( _, ( _, (BY_CASESleft as BY_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=NONE,
                               arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, END1right), rest671)
end
|  ( 191, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.case_clauses case_clauses1, _, _)) :: ( _, ( MlyValue.lcb 
lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
BY_CASESleft as BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=NONE,
                               arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, rcb1right), rest671)
end
|  ( 192, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.case_clauses 
case_clauses1, _, _)) :: _ :: ( _, ( 
MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, _)) :: _ :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (BY_CASESleft as 
BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=SOME(comma_separated_expression_list),
                             arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, END1right), rest671)
end
|  ( 193, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.case_clauses case_clauses1, _, _)) :: ( _, ( MlyValue.lcb 
lcb1, _, _)) :: ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, _)) :: _ :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (BY_CASESleft as 
BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 val  lcb1 = lcb1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=SOME(comma_separated_expression_list),
                             arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, rcb1right), rest671)
end
|  ( 194, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, _)) :: ( _, ( _, (PICK_ANYleft as 
PICK_ANY1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (possibly_typed_params_no_dots
 as possibly_typed_params_no_dots1) = possibly_typed_params_no_dots1
 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickAnyDed({eigenvars=A.checkForDuplicateParams(possibly_typed_params_no_dots),
	 		   body=deduction,pos=getPos PICK_ANYleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_ANY1left, deduction1right), 
rest671)
end
|  ( 195, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.param_option param_option1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( MlyValue.ID ID1, IDleft
, _)) :: ( _, ( _, (PICK_WITNESSleft as PICK_WITNESS1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option as param_option1) = param_option1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                 A.pickWitnessDed({ex_gen=phrase,var_id=S.symbol(ID),inst_id=param_option,body=deduction,
                                    pos=getPos PICK_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_WITNESS1left, deduction1right), 
rest671)
end
|  ( 196, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.param_option_no_dots param_option_no_dots1, _, _))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( 
MlyValue.one_or_more_params_no_dots one_or_more_params_no_dots1, _, _)
) :: ( _, ( _, (PICK_WITNESSESleft as PICK_WITNESSES1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_params_no_dots as one_or_more_params_no_dots1) = 
one_or_more_params_no_dots1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickWitnessesDed({ex_gen=phrase,var_ids=A.getParamNames(one_or_more_params_no_dots),
                                         inst_id=param_option_no_dots,body=deduction,
                                          pos=getPos PICK_WITNESSESleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_WITNESSES1left, deduction1right), 
rest671)
end
|  ( 197, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (INDUCTIONleft as 
INDUCTION1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=infix_dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                         res
                     end
)
end)
 in ( LrTable.NT 70, ( result, INDUCTION1left, END1right), rest671)

end
|  ( 198, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (INDUCTIONleft as INDUCTION1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=infix_dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                         res
                     end
)
end)
 in ( LrTable.NT 70, ( result, INDUCTION1left, rcb1right), rest671)

end
|  ( 199, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
STRUCTURE_CASESleft as STRUCTURE_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=infix_dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, STRUCTURE_CASES1left, END1right), 
rest671)
end
|  ( 200, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (STRUCTURE_CASESleft as STRUCTURE_CASES1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
phrase as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=infix_dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, STRUCTURE_CASES1left, rcb1right), 
rest671)
end
|  ( 201, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (DATATYPE_CASESleft
 as DATATYPE_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                        clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, END1right), 
rest671)
end
|  ( 202, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (DATATYPE_CASESleft as DATATYPE_CASES1left), _)) :: rest671
)) => let val  result = MlyValue.deduction (fn _ => let val  (phrase
 as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                        clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, rcb1right), 
rest671)
end
|  ( 203, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.expression expression1, _
, _)) :: _ :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
DATATYPE_CASESleft as DATATYPE_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (expression as expression1) = expression1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=SOME(expression),
                                                       clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, rcb1right), 
rest671)
end
|  ( 204, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, ASSUMEleft, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                      A.assumeLetDed({bindings=[({bpat=A.idPat({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                                sort_as_fterm=NONE,sort_as_exp=NONE}),
                                                  def=phrase,pos=getPos IDleft})],body=deduction,
                      pos=getPos ASSUMEleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 205, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 _, ASSUMEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeDed({assumption=phrase,body=deduction,pos=getPos ASSUMEleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 206, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.binding binding1, _, _)) :: ( _,
 ( _, ASSUME_LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.deduction (fn _ => let val  (binding
 as binding1) = binding1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeLetDed({bindings=[binding],body=deduction,
                      pos=getPos ASSUME_LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 207, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 _, SUPPOSE_ABSURDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.deduction (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdDed({hyp=phrase,body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 208, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.binding binding1, _, _)) :: ( _,
 ( _, SUPPOSE_ABSURD_LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
binding as binding1) = binding1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdLetDed({named_hyp=binding,body=deduction,pos=getPos SUPPOSE_ABSURD_LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 209, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dcheck_clauses dcheck_clauses1, _, _)) :: ( _, ( _, 
DCHECKleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.deduction (fn _ => let val  (dcheck_clauses as 
dcheck_clauses1) = dcheck_clauses1 ()
 in (A.checkDed({clauses=dcheck_clauses,pos=getPos DCHECKleft}))
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 210, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) ::
 _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
case expression of
                    A.idExp({msym,...}) => 
                      if Basic.isMember(MS.name(msym),["prim-mp", "prim-both"]) andalso length(phrases) = 2 then 
                         (A.BMethAppDed({method=expression,arg1=hd phrases, arg2 = hd(tl(phrases)), pos=getPos LPARENleft}))
                      else
                           if Basic.isMember(MS.name(msym),["prim-conj-intro"]) andalso length(phrases) = 1 then 
                             (A.UMethAppDed({method=expression,arg=hd phrases, pos=getPos LPARENleft}))                   
                          else
                         (A.methodAppDed({method=expression,args=phrases,pos=getPos LPARENleft}))
                  | _ => (A.methodAppDed({method=expression,args=phrases,pos=getPos LPARENleft}))
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 211, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.expression expression1, 
expressionleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
A.methodAppDed({method=expression,args=phrases,pos=getPos expressionleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 212, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, DMATCHleft, _)) :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
A.matchDed({discriminant=phrase,clauses=dmatch_clauses,pos=getPos DMATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 213, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, DLETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (A.letDed({bindings=bindings,body=deduction,pos=getPos DLETleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 214, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, DLETRECleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=bindings,body=deduction,pos=getPos DLETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 215, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETleft as 
LET1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LET1left, deduction1right), rest671)

end
|  ( 216, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DLETleft as 
DLET1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos DLETleft})
)
end)
 in ( LrTable.NT 70, ( result, DLET1left, deduction1right), rest671)

end
|  ( 217, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETRECleft as 
LETREC1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, LETREC1left, deduction1right), rest671)

end
|  ( 218, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DLETRECleft
 as DLETREC1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos DLETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, DLETREC1left, deduction1right), rest671
)
end
|  ( 219, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, _)) :: ( _, ( MlyValue.lcb lcb1,
 _, _)) :: ( _, ( _, (TRYleft as TRY1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  lcb1 = lcb1 ()
 val  (one_or_more_separated_deductions as 
one_or_more_separated_deductions1) = one_or_more_separated_deductions1
 ()
 val  rcb1 = rcb1 ()
 in (
A.tryDed({choices=one_or_more_separated_deductions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 70, ( result, TRY1left, rcb1right), rest671)
end
|  ( 220, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (MATCHleft as 
MATCH1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, MATCH1left, END1right), rest671)
end
|  ( 221, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (MATCHleft as MATCH1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, MATCH1left, rcb1right), rest671)
end
|  ( 222, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (DMATCHleft as DMATCH1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos DMATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, DMATCH1left, rcb1right), rest671)
end
|  ( 223, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dcheck_clauses infix_dcheck_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (CHECKleft as CHECK1left), _))
 :: rest671)) => let val  result = MlyValue.deduction (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkDed({clauses=infix_dcheck_clauses,pos=getPos CHECKleft}))

end)
 in ( LrTable.NT 70, ( result, CHECK1left, rcb1right), rest671)
end
|  ( 224, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dcheck_clauses infix_dcheck_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DCHECKleft as DCHECK1left), _)
) :: rest671)) => let val  result = MlyValue.deduction (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkDed({clauses=infix_dcheck_clauses,pos=getPos DCHECKleft}))

end)
 in ( LrTable.NT 70, ( result, DCHECK1left, rcb1right), rest671)
end
|  ( 225, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_deductions one_or_more_deductions1, _, _)) :: ( _
, ( _, DTRYleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (A.tryDed({choices=one_or_more_deductions,pos=getPos DTRYleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 226, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, _)) :: _ :: ( _, ( _, (TRYleft
 as TRY1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (one_or_more_separated_deductions
 as one_or_more_separated_deductions1) = 
one_or_more_separated_deductions1 ()
 in (
A.tryDed({choices=one_or_more_separated_deductions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 70, ( result, TRY1left, END1right), rest671)
end
|  ( 227, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_deductions one_or_more_deductions1, _, _)) :: ( _
, ( _, DSEQleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (A.beginDed({members=one_or_more_deductions,pos=getPos DSEQleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 228, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, GEN_OVERleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.genOverDed({eigenvar_exp=expression,body=deduction,pos=getPos GEN_OVERleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 229, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
GEN_OVERleft as GEN_OVER1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.genOverDed({eigenvar_exp=expression,body=deduction,pos=getPos GEN_OVERleft})
)
end)
 in ( LrTable.NT 70, ( result, GEN_OVER1left, deduction1right), 
rest671)
end
|  ( 230, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, _)) :: ( _, ( _, PICK_ANYleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (possibly_typed_params_no_dots
 as possibly_typed_params_no_dots1) = possibly_typed_params_no_dots1
 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickAnyDed({eigenvars=A.checkForDuplicateParams(possibly_typed_params_no_dots),
				   body=deduction,pos=getPos PICK_ANYleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 231, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 MlyValue.expression expression1, _, _)) :: ( _, ( _, WITH_WITNESSleft
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.withWitnessDed({eigenvar_exp=expression,ex_gen=phrase,body=deduction,
                                       pos=getPos WITH_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 232, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.param_option_no_dots 
param_option_no_dots1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)
) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, PICK_WITNESSleft
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                     A.pickWitnessDed({ex_gen=phrase,var_id=S.symbol(ID),inst_id=param_option_no_dots,body=deduction,
                                       pos=getPos PICK_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 233, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.param_option_no_dots 
param_option_no_dots1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)
) :: _ :: ( _, ( MlyValue.one_or_more_params_no_dots 
one_or_more_params_no_dots1, _, _)) :: _ :: ( _, ( _, 
PICK_WITNESSESleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_params_no_dots as one_or_more_params_no_dots1) = 
one_or_more_params_no_dots1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickWitnessesDed({ex_gen=phrase,var_ids=A.getParamNames(one_or_more_params_no_dots),
                                        inst_id=param_option_no_dots,body=deduction,
                                         pos=getPos PICK_WITNESSESleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 234, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, INDUCTIONleft, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 235, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, STRUCTURE_CASESleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 236, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, DATATYPE_CASESleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 237, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.expression expression1, _, _)) :: _ :: ( _, ( MlyValue.phrase
 phrase1, _, _)) :: ( _, ( _, DATATYPE_CASESleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (expression as expression1) = expression1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=SOME(expression),
                                                       clauses=dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 238, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: 
rest671)) => let val  result = MlyValue.phrase_pair (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
(phrase1,phrase2,getPos(LPARENleft), getPos(phrase1left), getPos(phrase2left))
)
end)
 in ( LrTable.NT 136, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 239, ( ( _, ( MlyValue.phrase_pair phrase_pair1, phrase_pair1left
, phrase_pair1right)) :: rest671)) => let val  result = 
MlyValue.phrase_pair_list (fn _ => let val  (phrase_pair as 
phrase_pair1) = phrase_pair1 ()
 in ([phrase_pair])
end)
 in ( LrTable.NT 137, ( result, phrase_pair1left, phrase_pair1right), 
rest671)
end
|  ( 240, ( ( _, ( MlyValue.phrase_pair_list phrase_pair_list1, _, 
phrase_pair_list1right)) :: ( _, ( MlyValue.phrase_pair phrase_pair1, 
phrase_pair1left, _)) :: rest671)) => let val  result = 
MlyValue.phrase_pair_list (fn _ => let val  (phrase_pair as 
phrase_pair1) = phrase_pair1 ()
 val  (phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (phrase_pair::phrase_pair_list)
end)
 in ( LrTable.NT 137, ( result, phrase_pair1left, 
phrase_pair_list1right), rest671)
end
|  ( 241, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.comma_separated_expression_list (fn _ => let val  (expression
 as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 66, ( result, expression1left, expression1right), 
rest671)
end
|  ( 242, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: _ :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.comma_separated_expression_list (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (expression::comma_separated_expression_list)
end)
 in ( LrTable.NT 66, ( result, expression1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 243, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 67, ( result, phrase1left, phrase1right), rest671)

end
|  ( 244, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671))
 => let val  result = MlyValue.comma_separated_phrase_list (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (phrase::comma_separated_phrase_list)
end)
 in ( LrTable.NT 67, ( result, phrase1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 245, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 68, ( result, phrase1left, phrase1right), rest671)

end
|  ( 246, ( ( _, ( MlyValue.opt_comma_separated_phrase_list 
opt_comma_separated_phrase_list1, _, 
opt_comma_separated_phrase_list1right)) :: _ :: ( _, ( MlyValue.phrase
 phrase1, phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (opt_comma_separated_phrase_list as 
opt_comma_separated_phrase_list1) = opt_comma_separated_phrase_list1
 ()
 in (phrase::opt_comma_separated_phrase_list)
end)
 in ( LrTable.NT 68, ( result, phrase1left, 
opt_comma_separated_phrase_list1right), rest671)
end
|  ( 247, ( ( _, ( MlyValue.opt_comma_separated_phrase_list 
opt_comma_separated_phrase_list1, _, 
opt_comma_separated_phrase_list1right)) :: ( _, ( MlyValue.phrase 
phrase1, phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (opt_comma_separated_phrase_list as 
opt_comma_separated_phrase_list1) = opt_comma_separated_phrase_list1
 ()
 in (phrase::opt_comma_separated_phrase_list)
end)
 in ( LrTable.NT 68, ( result, phrase1left, 
opt_comma_separated_phrase_list1right), rest671)
end
|  ( 248, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: ( _, ( _, FROMleft, FROMright)) :: ( _, ( MlyValue.expression 
expression1, expression1left, _)) :: rest671)) => let val  result = 
MlyValue.inference (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.methodAppDed({method=A.idExp({msym=A.mSym N.spfPrimMethod_symbol,mods=[],sym=N.spfPrimMethod_symbol,no_mods=true,pos=getPos FROMleft}),
                                           args=[A.exp(expression),
                                                 A.exp(A.listExp({members=comma_separated_phrase_list,pos=getPos FROMright}))],
                                                 pos=A.posOfExp(expression)})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 249, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.expression expression2, _, _)) :: ( _, ( _, 
BYleft, _)) :: ( _, ( MlyValue.expression expression1, expression1left
, _)) :: rest671)) => let val  result = MlyValue.inference (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  expression2 = expression2 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.byDed({wanted_res=expression1,conc_name=NONE,body=A.methodAppDed({method=expression2,
                         args=comma_separated_phrase_list,pos=A.posOfExp(expression)}),pos=getPos BYleft})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 250, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.expression expression1, expression1left, _))
 :: rest671)) => let val  result = MlyValue.inference (fn _ => let
 val  (expression as expression1) = expression1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.methodAppDed({method=expression,args=comma_separated_phrase_list,pos=A.posOfExp(expression)})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 251, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = MlyValue.inference
 (fn _ => let val  (deduction as deduction1) = deduction1 ()
 in (deduction)
end)
 in ( LrTable.NT 71, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 252, ( ( _, ( MlyValue.inference inference1, inference1left, 
inference1right)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  (inference as 
inference1) = inference1 ()
 in ({param=NONE,def=A.ded(inference),pos=A.posOfDed(inference)})
end)
 in ( LrTable.NT 72, ( result, inference1left, inference1right), 
rest671)
end
|  ( 253, ( ( _, ( MlyValue.inference inference1, _, inference1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.possibly_named_inference (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (inference as inference1) = inference1 ()
 in (
{param=SOME(A.someParam({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                            sort_as_fterm=NONE,sort_as_exp=NONE})),
			    def=A.ded(inference),pos=A.posOfDed(inference)}
)
end)
 in ( LrTable.NT 72, ( result, ID1left, inference1right), rest671)
end
|  ( 254, ( ( _, ( MlyValue.inference inference1, _, inference1right))
 :: _ :: ( _, ( _, (ANY_PATleft as ANY_PAT1left), _)) :: rest671)) =>
 let val  result = MlyValue.possibly_named_inference (fn _ => let val 
 (inference as inference1) = inference1 ()
 in (
{param=SOME(A.wildCard(getPos ANY_PATleft)),
			    def=A.ded(inference),pos=A.posOfDed(inference)}
)
end)
 in ( LrTable.NT 72, ( result, ANY_PAT1left, inference1right), rest671
)
end
|  ( 255, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left)
, _)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (expression as expression1) = expression1 ()
 in (
{param=SOME(A.someParam({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                    sort_as_fterm=NONE,sort_as_exp=NONE})),
			    def=A.exp(expression),pos=A.posOfExp(expression)}
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 256, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _))
 :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) ::
 rest671)) => let val  result = MlyValue.possibly_named_inference (fn
 _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (expression as expression1) = expression1 ()
 in (
case Int.fromString(ID2) of
                                  SOME(i) => 
                                     ({param=SOME(A.someParam({name=S.symbol(ID1),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                               op_tag=SOME(i,~1),sort_as_fterm=NONE,sort_as_exp=NONE})),
                                                               
                                      def=A.exp(expression),pos=A.posOfExp(expression)})
                                | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 257, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _,
 ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (expression as expression1) = expression1 ()
 in (
case (Int.fromString(ID2),Int.fromString(ID3)) of
                                  (SOME(i),SOME(j)) => 
                                    ({param=SOME(A.someParam({name=S.symbol(ID1),pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,j),
                                                    sort_as_fterm=NONE,sort_as_exp=NONE})),
 			              def=A.exp(expression),pos=A.posOfExp(expression)})
                               | _ => Data.genEx("Operator annotation error",
                                                 SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 258, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( _, (ANY_PATleft as ANY_PAT1left), _)
) :: rest671)) => let val  result = MlyValue.possibly_named_inference
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (
{param=SOME(A.wildCard(getPos ANY_PATleft)), 
			    def=A.exp(expression),pos=A.posOfExp(expression)}
)
end)
 in ( LrTable.NT 72, ( result, ANY_PAT1left, expression1right), 
rest671)
end
|  ( 259, ( ( _, ( MlyValue.possibly_named_inference 
possibly_named_inference1, possibly_named_inference1left, 
possibly_named_inference1right)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 in ([possibly_named_inference])
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
possibly_named_inference1right), rest671)
end
|  ( 260, ( ( _, ( MlyValue.inference_list inference_list1, _, 
inference_list1right)) :: _ :: ( _, ( 
MlyValue.possibly_named_inference possibly_named_inference1, 
possibly_named_inference1left, _)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 in (possibly_named_inference::inference_list)
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
inference_list1right), rest671)
end
|  ( 261, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.expression expression1, expression1left, _))
 :: rest671)) => let val  result = MlyValue.case_clause (fn _ => let
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({case_name=NONE,alt=expression,proof=deduction})
end)
 in ( LrTable.NT 75, ( result, expression1left, deduction1right), 
rest671)
end
|  ( 262, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.expression expression1, _, _)) :: _ :: ( _, (
 MlyValue.param param1, param1left, _)) :: rest671)) => let val  
result = MlyValue.case_clause (fn _ => let val  (param as param1) = 
param1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({case_name=SOME(param),alt=expression,proof=deduction})
end)
 in ( LrTable.NT 75, ( result, param1left, deduction1right), rest671)

end
|  ( 263, ( ( _, ( MlyValue.case_clause case_clause1, case_clause1left
, case_clause1right)) :: rest671)) => let val  result = 
MlyValue.case_clauses (fn _ => let val  (case_clause as case_clause1)
 = case_clause1 ()
 in ([case_clause])
end)
 in ( LrTable.NT 76, ( result, case_clause1left, case_clause1right), 
rest671)
end
|  ( 264, ( ( _, ( MlyValue.case_clauses case_clauses1, _, 
case_clauses1right)) :: ( _, ( MlyValue.single_logical_or 
single_logical_or1, _, _)) :: ( _, ( MlyValue.case_clause case_clause1
, case_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.case_clauses (fn _ => let val  (case_clause as case_clause1)
 = case_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (case_clause::case_clauses)
end)
 in ( LrTable.NT 76, ( result, case_clause1left, case_clauses1right), 
rest671)
end
|  ( 265, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.inference_list
 inference_list1, _, _)) :: ( _, ( _, (BEGINleft as BEGIN1left), _))
 :: rest671)) => let val  result = MlyValue.inference_block (fn _ =>
 let val  (inference_list as inference_list1) = inference_list1 ()
 in (
case rev(inference_list) of 
                     (b:A.optBinding as {param,def=A.ded(d),pos})::rest => 
                       A.letDed({bindings=A.getBindings(rev (rest)),body=d,pos=getPos BEGINleft})
                   | (b as {param,def=A.exp(e),pos})::_ => 
                        raise A.SyntaxError("expression found in the tail position of"^
                                            "\na begin-end inference block---a deduction is"^
                                            " required in that position",SOME pos)
)
end)
 in ( LrTable.NT 74, ( result, BEGIN1left, END1right), rest671)
end
|  ( 266, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.inference_list inference_list1, _, _)) :: ( _, ( MlyValue.lcb
 lcb1, (lcbleft as lcb1left), _)) :: rest671)) => let val  result = 
MlyValue.inference_block (fn _ => let val  lcb1 = lcb1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 val  rcb1 = rcb1 ()
 in (
case rev(inference_list) of 
                     (b:A.optBinding as {param,def=A.ded(d),pos})::rest => 
                       A.letDed({bindings=A.getBindings(rev (rest)),body=d,pos=getPos lcbleft})
                   | (b as {param,def=A.exp(e),pos})::_ => 
                        raise A.SyntaxError("expression found in the tail position of"^
                                            "\na begin-end inference block---a deduction is"^
                                            " required in that position",SOME pos)
)
end)
 in ( LrTable.NT 74, ( result, lcb1left, rcb1right), rest671)
end
|  ( 267, ( rest671)) => let val  result = MlyValue.deductions (fn _
 => ([]))
 in ( LrTable.NT 77, ( result, defaultPos, defaultPos), rest671)
end
|  ( 268, ( ( _, ( MlyValue.deductions deductions1, _, 
deductions1right)) :: ( _, ( MlyValue.deduction deduction1, 
deduction1left, _)) :: rest671)) => let val  result = 
MlyValue.deductions (fn _ => let val  (deduction as deduction1) = 
deduction1 ()
 val  (deductions as deductions1) = deductions1 ()
 in (deduction::deductions)
end)
 in ( LrTable.NT 77, ( result, deduction1left, deductions1right), 
rest671)
end
|  ( 269, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = MlyValue.phrase
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.exp(expression))
end)
 in ( LrTable.NT 81, ( result, expression1left, expression1right), 
rest671)
end
|  ( 270, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = MlyValue.phrase
 (fn _ => let val  (deduction as deduction1) = deduction1 ()
 in (A.ded(deduction))
end)
 in ( LrTable.NT 81, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 271, ( rest671)) => let val  result = MlyValue.phrases (fn _ => (
[]))
 in ( LrTable.NT 82, ( result, defaultPos, defaultPos), rest671)
end
|  ( 272, ( ( _, ( MlyValue.phrases phrases1, _, phrases1right)) :: (
 _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671)) => let
 val  result = MlyValue.phrases (fn _ => let val  (phrase as phrase1)
 = phrase1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (phrase::phrases)
end)
 in ( LrTable.NT 82, ( result, phrase1left, phrases1right), rest671)

end
|  ( 273, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_expressions (fn _ => let val  (expression as 
expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 65, ( result, expression1left, expression1right), 
rest671)
end
|  ( 274, ( ( _, ( MlyValue.one_or_more_expressions 
one_or_more_expressions1, _, one_or_more_expressions1right)) :: ( _, (
 MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_expressions (fn _ => let val 
 (expression as expression1) = expression1 ()
 val  (one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (expression::one_or_more_expressions)
end)
 in ( LrTable.NT 65, ( result, expression1left, 
one_or_more_expressions1right), rest671)
end
|  ( 275, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = MlyValue.one_or_more_phrases (fn _
 => let val  (phrase as phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 69, ( result, phrase1left, phrase1right), rest671)

end
|  ( 276, ( ( _, ( MlyValue.one_or_more_phrases one_or_more_phrases1,
 _, one_or_more_phrases1right)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_phrases (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  (one_or_more_phrases as one_or_more_phrases1) = 
one_or_more_phrases1 ()
 in (phrase::one_or_more_phrases)
end)
 in ( LrTable.NT 69, ( result, phrase1left, one_or_more_phrases1right)
, rest671)
end
|  ( 277, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_deductions (fn _ => let val  (deduction as 
deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 80, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 278, ( ( _, ( MlyValue.one_or_more_deductions 
one_or_more_deductions1, _, one_or_more_deductions1right)) :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_deductions (fn _ => let val  (
deduction as deduction1) = deduction1 ()
 val  (one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (deduction::one_or_more_deductions)
end)
 in ( LrTable.NT 80, ( result, deduction1left, 
one_or_more_deductions1right), rest671)
end
|  ( 279, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_separated_deductions (fn _ => let val  (deduction
 as deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 78, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 280, ( ( _, ( MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, 
one_or_more_separated_deductions1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_separated_deductions (fn _ => let
 val  (deduction as deduction1) = deduction1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (one_or_more_separated_deductions as 
one_or_more_separated_deductions1) = one_or_more_separated_deductions1
 ()
 in (deduction::one_or_more_separated_deductions)
end)
 in ( LrTable.NT 78, ( result, deduction1left, 
one_or_more_separated_deductions1right), rest671)
end
|  ( 281, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_separated_expressions (fn _ => let val  (
expression as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 79, ( result, expression1left, expression1right), 
rest671)
end
|  ( 282, ( ( _, ( MlyValue.one_or_more_separated_expressions 
one_or_more_separated_expressions1, _, 
one_or_more_separated_expressions1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_separated_expressions (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (one_or_more_separated_expressions as 
one_or_more_separated_expressions1) = 
one_or_more_separated_expressions1 ()
 in (expression::one_or_more_separated_expressions)
end)
 in ( LrTable.NT 79, ( result, expression1left, 
one_or_more_separated_expressions1right), rest671)
end
|  ( 283, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, META_IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.athena_meta_id (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (A.quotedIdeExp({name=ID,pos=getPos META_IDleft}))
end)
 in ( LrTable.NT 127, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 284, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.athena_meta_id (fn _ => let val  (ID as ID1) = ID1
 ()
 in (A.quotedIdeExp({name=ID,pos=getPos QUOTE_SYMBOLleft}))
end)
 in ( LrTable.NT 127, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 285, ( ( _, ( MlyValue.STRING STRING1, _, STRING1right)) :: ( _, 
( _, (QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let
 val  result = MlyValue.athena_meta_id (fn _ => let val  (STRING as 
STRING1) = STRING1 ()
 in (
let val escape = "\""
                                         val str = implode(map Char.chr STRING)
                                         val str' = escape ^ str ^ escape 
                                     in
                                        A.quotedIdeExp({name=str',pos=getPos QUOTE_SYMBOLleft})
                                     end
)
end)
 in ( LrTable.NT 127, ( result, QUOTE_SYMBOL1left, STRING1right), 
rest671)
end
|  ( 286, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.athena_var (fn _ => let val  (ID as ID1) = ID1 ()
 in (AthTermVar.athTermVar(ID))
end)
 in ( LrTable.NT 125, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 287, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, 
QMARK1left, _)) :: rest671)) => let val  result = MlyValue.athena_var
 (fn _ => let val  (ID as ID1) = ID1 ()
 in (AthTermVar.athTermVar(ID))
end)
 in ( LrTable.NT 125, ( result, QMARK1left, ID1right), rest671)
end
|  ( 288, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671))
 => let val  result = MlyValue.ath_var (fn _ => let val  (ID as ID1) =
 ID1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),user_sort=NONE,
				pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 126, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 289, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.user_sort 
user_sort1, _, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: ( _,
 ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.ath_var (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),
							       user_sort=SOME(user_sort),pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 126, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 290, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QMARKleft as QMARK1left), _)) :: rest671)) => let val  result = 
MlyValue.ath_var (fn _ => let val  (ID as ID1) = ID1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),user_sort=NONE,pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 126, ( result, QMARK1left, ID1right), rest671)
end
|  ( 291, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, (QMARKleft as 
QMARK1left), _)) :: rest671)) => let val  result = MlyValue.ath_var
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),
						   user_sort=SOME(user_sort),pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 126, ( result, QMARK1left, user_sort1right), rest671)

end
|  ( 292, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.ath_var (fn _ => (
A.termVarExp({term_var=AthTermVar.fresh(),
						   user_sort=NONE,pos=getPos ANY_PATleft})
))
 in ( LrTable.NT 126, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 293, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.user_sort (fn _ => let val  (ID as ID1) = ID1 ()
 in (SymTerm.makeTaggedVar(Symbol.symbol(ID),getPos(QUOTE_SYMBOLleft))
)
end)
 in ( LrTable.NT 31, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 294, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.user_sort (fn _ => let val  (
ID as ID1) = ID1 ()
 in (
let val id_pos = getPos(IDleft)
                in
                   SymTerm.makeTaggedConstant(A.makeMS(ID,SOME id_pos),id_pos)
                end
)
end)
 in ( LrTable.NT 31, ( result, ID1left, ID1right), rest671)
end
|  ( 295, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_user_sorts one_or_more_user_sorts1, _, _)) :: ( _
, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.user_sort (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (one_or_more_user_sorts as one_or_more_user_sorts1) = 
one_or_more_user_sorts1 ()
 in (
let val id_pos = getPos(IDleft)
                 in
                   SymTerm.makeTaggedApp(A.makeMS(ID,SOME id_pos),id_pos,one_or_more_user_sorts)
                 end
)
end)
 in ( LrTable.NT 31, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 296, ( ( _, ( MlyValue.user_sort user_sort1, user_sort1left, 
user_sort1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_user_sorts (fn _ => let val  (user_sort as 
user_sort1) = user_sort1 ()
 in ([user_sort])
end)
 in ( LrTable.NT 32, ( result, user_sort1left, user_sort1right), 
rest671)
end
|  ( 297, ( ( _, ( MlyValue.one_or_more_user_sorts 
one_or_more_user_sorts1, _, one_or_more_user_sorts1right)) :: ( _, ( 
MlyValue.user_sort user_sort1, user_sort1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_user_sorts (fn _ => let val  (
user_sort as user_sort1) = user_sort1 ()
 val  (one_or_more_user_sorts as one_or_more_user_sorts1) = 
one_or_more_user_sorts1 ()
 in (user_sort::one_or_more_user_sorts)
end)
 in ( LrTable.NT 32, ( result, user_sort1left, 
one_or_more_user_sorts1right), rest671)
end
|  ( 298, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.one_or_more_ids (fn _ => let val  (ID
 as ID1) = ID1 ()
 in ([ID])
end)
 in ( LrTable.NT 62, ( result, ID1left, ID1right), rest671)
end
|  ( 299, ( ( _, ( MlyValue.one_or_more_ids one_or_more_ids1, _, 
one_or_more_ids1right)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: 
rest671)) => let val  result = MlyValue.one_or_more_ids (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (one_or_more_ids as one_or_more_ids1) = one_or_more_ids1 ()
 in (ID::one_or_more_ids)
end)
 in ( LrTable.NT 62, ( result, ID1left, one_or_more_ids1right), 
rest671)
end
|  ( 300, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, DOMAINleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.ath_domain (fn _ => let val  (
ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,arity=0,sort_predicate=NONE,pos=getPos DOMAINleft})

end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 301, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
DOMAINleft as DOMAIN1left), _)) :: rest671)) => let val  result = 
MlyValue.ath_domain (fn _ => let val  (ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,arity=0,sort_predicate=NONE,pos=getPos DOMAINleft})

end)
 in ( LrTable.NT 20, ( result, DOMAIN1left, ID1right), rest671)
end
|  ( 302, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, _,
 _)) :: _ :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, 
DOMAINleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.ath_domain (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
 let val msym = A.makeMS(ID2,SOME (IDleft))
                 in
                    {name=S.symbol ID1,arity=0,sort_predicate=SOME(msym),pos=getPos DOMAINleft}
                 end
)
end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 303, ( ( _, ( _, _, RPAREN2right)) :: _ :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, _, _)) :: _ :: ( _, ( _, DOMAINleft, _)) :: ( _, ( _,
 LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_domain (fn _ => let val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,arity=length(one_or_more_params),sort_predicate=NONE,pos=getPos DOMAINleft}
)
end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 304, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, _, _)) :: _ :: ( _, ( _, (DOMAINleft as DOMAIN1left),
 _)) :: rest671)) => let val  result = MlyValue.ath_domain (fn _ =>
 let val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,arity=length(one_or_more_params),sort_predicate=NONE,pos=getPos DOMAINleft}
)
end)
 in ( LrTable.NT 20, ( result, DOMAIN1left, RPAREN1right), rest671)

end
|  ( 305, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_domains (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 in (
List.map (fn {name=n,pos=p} => {name=n,arity=0,sort_predicate=NONE,pos=p})
			  one_or_more_params
)
end)
 in ( LrTable.NT 21, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 306, ( ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, 
one_or_more_comma_separated_params1right)) :: ( _, ( _, DOMAINS1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_domains (fn _ =>
 let val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (
List.map (fn {name=n,pos=p} => {name=n,arity=0,sort_predicate=NONE,pos=p})
			  one_or_more_comma_separated_params
)
end)
 in ( LrTable.NT 21, ( result, DOMAINS1left, 
one_or_more_comma_separated_params1right), rest671)
end
|  ( 307, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param 
param2, _, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.subsort (fn _ => let val  param1 = param1 ()
 val  param2 = param2 ()
 in (
let val (pos1,pos2) = (#pos(param1),#pos(param2))
                val (name1,name2) = (#name(param1),#name(param2))
                val (msym1,msym2) = (A.makeMS(Symbol.name(name1),SOME pos1),A.makeMS(Symbol.name name2,SOME pos2))
            in
               (msym1,pos1,msym2,pos2)
            end
)
end)
 in ( LrTable.NT 22, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 308, ( ( _, ( MlyValue.param param2, param2left, param2right)) ::
 ( _, ( MlyValue.param param1, param1left, _)) :: ( _, ( _, 
SUBSORT1left, _)) :: rest671)) => let val  result = MlyValue.subsort
 (fn _ => let val  param1 = param1 ()
 val  param2 = param2 ()
 in (
let val (pos1,pos2) = (getPos(param1left),getPos(param2left))
                val (name1,name2) = (#name(param1),#name(param2))
                val (msym1,msym2) = (A.makeMS(Symbol.name name1,SOME pos1),A.makeMS(Symbol.name name2,SOME pos2))
            in
               (msym1,pos1,msym2,pos2)
            end
)
end)
 in ( LrTable.NT 22, ( result, SUBSORT1left, param2right), rest671)

end
|  ( 309, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.param 
param1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_params 
one_or_more_params1, _, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) ::
 rest671)) => let val  result = MlyValue.subsorts (fn _ => let val  (
one_or_more_params as one_or_more_params1) = one_or_more_params1 ()
 val  (param as param1) = param1 ()
 in (
let val mod_sym_and_pos_list = map (fn {name,pos,...}:A.param => (A.makeMS(Symbol.name name,SOME pos),pos)) one_or_more_params
                val (mod_sym,pos) = let val (name,pos) = (#name(param),#pos(param))
                                    in 
                                       (A.makeMS(Symbol.name name,SOME pos),pos)
                                    end
            in
              (mod_sym_and_pos_list,(mod_sym,pos))
            end
)
end)
 in ( LrTable.NT 23, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 310, ( ( _, ( MlyValue.param param1, _, param1right)) :: _ :: ( _
, ( MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: (
 _, ( _, SUBSORTS1left, _)) :: rest671)) => let val  result = 
MlyValue.subsorts (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (param as param1) = param1 ()
 in (
let val mod_sym_and_pos_list = map (fn {name,pos,...}:A.param => (A.makeMS(Symbol.name name,SOME pos),pos)) one_or_more_params
                val (mod_sym,pos) = let val (name,pos) = (#name(param),#pos(param))
                                    in 
                                       (A.makeMS(Symbol.name name,SOME pos),pos)
                                    end
            in
              (mod_sym_and_pos_list,(mod_sym,pos))
            end
)
end)
 in ( LrTable.NT 23, ( result, SUBSORTS1left, param1right), rest671)

end
|  ( 311, ( ( _, ( _, LEFT_ASSOC1left, LEFT_ASSOC1right)) :: rest671))
 => let val  result = MlyValue.associativity (fn _ => (true))
 in ( LrTable.NT 131, ( result, LEFT_ASSOC1left, LEFT_ASSOC1right), 
rest671)
end
|  ( 312, ( ( _, ( _, RIGHT_ASSOC1left, RIGHT_ASSOC1right)) :: rest671
)) => let val  result = MlyValue.associativity (fn _ => (false))
 in ( LrTable.NT 131, ( result, RIGHT_ASSOC1left, RIGHT_ASSOC1right), 
rest671)
end
|  ( 313, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, LEFT_BRACKET1left, _)) :: rest671)) => let val  result = 
MlyValue.input_transformer_declaration (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (one_or_more_expressions)
end)
 in ( LrTable.NT 42, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 314, ( rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=NONE})
)
 in ( LrTable.NT 129, ( result, defaultPos, defaultPos), rest671)
end
|  ( 315, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (
input_transformer_declaration as input_transformer_declaration1) = 
input_transformer_declaration1 ()
 in (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=SOME input_transformer_declaration}
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 316, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671))
 => let val  result = MlyValue.declaration_prec_assoc (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],NONE))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 317, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],SOME(input_transformer_declaration)))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 318, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],NONE))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 319, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],SOME input_transformer_declaration))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 320, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 321, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: 
rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn _
 => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],
                                                                                                                         SOME input_transformer_declaration))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 322, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left
), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],NONE))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 323, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],
                                                                                                         SOME input_transformer_declaration))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 324, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],NONE))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 325, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],SOME input_transformer_declaration))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 326, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID3, ID3left, _)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],SOME input_transformer_declaration))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 327, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID3, 
ID3left, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left)
, _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],NONE))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 328, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 329, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 330, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _,
 ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 331, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 332, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)
) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.declaration_prec_assoc (fn _ => let val  ID1 =
 ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],NONE))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 333, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _,
 ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],SOME input_transformer_declaration))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 334, ( rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=NONE})
)
 in ( LrTable.NT 130, ( result, defaultPos, defaultPos), rest671)
end
|  ( 335, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671)) => let val  
result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
input_transformer_declaration as input_transformer_declaration1) = 
input_transformer_declaration1 ()
 in (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=SOME input_transformer_declaration}
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 336, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left),
 _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],NONE))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 337, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (
LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val  
result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as 
ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],SOME input_transformer_declaration))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 338, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],NONE))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 339, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],SOME input_transformer_declaration))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 340, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val 
 result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 341, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left)
, _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],
                                                                                         SOME input_transformer_declaration))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 342, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],NONE))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 343, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],
                                                                                                         SOME input_transformer_declaration))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 344, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],NONE))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 345, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],SOME input_transformer_declaration))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 346, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID3, ID3left, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],NONE))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 347, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID3, ID3left, _)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val 
 result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],SOME input_transformer_declaration))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 348, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 349, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 350, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _,
 ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  
ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 351, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 352, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)
) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671
)) => let val  result = MlyValue.sb_declaration_prec_assoc (fn _ =>
 let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],NONE))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 353, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _,
 ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],SOME input_transformer_declaration))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 354, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, _, _)) :: _ :: ( _, (
 MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: _ :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_constant_sym (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
List.map (fn {name=n,pos=p} => 
			  	{name=n,pos=p,obtype_params = [],argument_types=[],input_transformer=NONE,
		                    range_type=athena_object_type,prec=NONE,assoc=NONE,overload_sym=NONE}) one_or_more_params
)
end)
 in ( LrTable.NT 24, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 355, ( ( _, ( MlyValue.athena_object_type athena_object_type1, _,
 athena_object_type1right)) :: _ :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, DECLARE1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_constant_sym (fn _
 => let val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
List.map (fn {name=n,pos=p} => 
			  	{name=n,pos=p,obtype_params = [],argument_types=[],input_transformer=NONE,
		                    range_type=athena_object_type,prec=NONE,assoc=NONE,overload_sym=NONE}) 
                     one_or_more_comma_separated_params
)
end)
 in ( LrTable.NT 24, ( result, DECLARE1left, athena_object_type1right)
, rest671)
end
|  ( 356, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, _, _)) :: ( _, ( 
MlyValue.param param1, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.ath_constant_sym (fn _ => let
 val  (param as param1) = param1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
let val n = #name(param) 
                       val p = #pos(param)
                    in [{name=n,pos=p,obtype_params = [],argument_types=[],range_type=athena_object_type,
                         input_transformer=NONE,prec=NONE,assoc=NONE,overload_sym=NONE}]
                   end
)
end)
 in ( LrTable.NT 24, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 357, ( ( _, ( _, _, RPAREN4right)) :: ( _, ( 
MlyValue.declaration_prec_assoc declaration_prec_assoc1, _, _)) :: _
 :: ( _, ( MlyValue.athena_object_type athena_object_type1, _, _)) ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: _ :: ( _, ( MlyValue.possible_obtype_params 
possible_obtype_params1, _, _)) :: _ :: _ :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_fsym (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (possible_obtype_params as possible_obtype_params1) = 
possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (declaration_prec_assoc as declaration_prec_assoc1) = 
declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt:A.param option,input_transformer_option)  = 
                                   (#precedence(declaration_prec_assoc),#assoc(declaration_prec_assoc),
                                    #overload_sym(declaration_prec_assoc),#input_transformer(declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
             in
               List.map (fn {name=n,pos=p} =>
			  {name=n,pos=p,obtype_params = possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
	                   input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type}) one_or_more_params
             end
)
end)
 in ( LrTable.NT 25, ( result, LPAREN1left, RPAREN4right), rest671)

end
|  ( 358, ( ( _, ( MlyValue.sb_declaration_prec_assoc 
sb_declaration_prec_assoc1, _, sb_declaration_prec_assoc1right)) :: (
 _, ( MlyValue.athena_object_type athena_object_type1, _, _)) :: _ ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: ( _, ( 
MlyValue.comma_separated_possible_obtype_params 
comma_separated_possible_obtype_params1, _, _)) :: _ :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, DECLARE1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_fsym (fn _ => let
 val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  (comma_separated_possible_obtype_params as 
comma_separated_possible_obtype_params1) = 
comma_separated_possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (sb_declaration_prec_assoc as sb_declaration_prec_assoc1) = 
sb_declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name comma_separated_possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt,input_transformer_option)  = 
                            (#precedence(sb_declaration_prec_assoc),#assoc(sb_declaration_prec_assoc),
                             #overload_sym(sb_declaration_prec_assoc),#input_transformer(sb_declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
             in
               List.map (fn {name=n,pos=p} =>
			  {name=n,pos=p,obtype_params = comma_separated_possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
	                   input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type})
			  one_or_more_comma_separated_params
             end
)
end)
 in ( LrTable.NT 25, ( result, DECLARE1left, 
sb_declaration_prec_assoc1right), rest671)
end
|  ( 359, ( ( _, ( _, _, RPAREN3right)) :: ( _, ( 
MlyValue.declaration_prec_assoc declaration_prec_assoc1, _, _)) :: _
 :: ( _, ( MlyValue.athena_object_type athena_object_type1, _, _)) ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: _ :: ( _, ( MlyValue.possible_obtype_params 
possible_obtype_params1, _, _)) :: _ :: ( _, ( MlyValue.param param1,
 _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.ath_fsym (fn _ => let val  (param as param1) = 
param1 ()
 val  (possible_obtype_params as possible_obtype_params1) = 
possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (declaration_prec_assoc as declaration_prec_assoc1) = 
declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt,input_transformer_option)  = 
                                                              (#precedence(declaration_prec_assoc),#assoc(declaration_prec_assoc),
                                                               #overload_sym(declaration_prec_assoc),#input_transformer(declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
                 fun app_name(n) = Symbol.symbol((Symbol.name(n))^"goo")
             in
               List.map (fn {name=n,pos=p} =>
                         {name=n,pos=p,obtype_params = possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
                          input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type}) [param]
             end
)
end)
 in ( LrTable.NT 25, ( result, LPAREN1left, RPAREN3right), rest671)

end
|  ( 360, ( rest671)) => let val  result = 
MlyValue.possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 60, ( result, defaultPos, defaultPos), rest671)
end
|  ( 361, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.possible_obtype_params (fn _ => let val  (one_or_more_params
 as one_or_more_params1) = one_or_more_params1 ()
 in (one_or_more_params)
end)
 in ( LrTable.NT 60, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 362, ( rest671)) => let val  result = 
MlyValue.comma_separated_possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 59, ( result, defaultPos, defaultPos), rest671)
end
|  ( 363, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = 
MlyValue.comma_separated_possible_obtype_params (fn _ => let val  (
one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (one_or_more_comma_separated_params)
end)
 in ( LrTable.NT 59, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 364, ( rest671)) => let val  result = 
MlyValue.bracket_enclosed_possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 61, ( result, defaultPos, defaultPos), rest671)
end
|  ( 365, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( _, 
LEFT_BRACKET1left, _)) :: rest671)) => let val  result = 
MlyValue.bracket_enclosed_possible_obtype_params (fn _ => let val  (
one_or_more_params as one_or_more_params1) = one_or_more_params1 ()
 in (one_or_more_params)
end)
 in ( LrTable.NT 61, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 366, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.ath_structure_profile (fn _
 => let val  (ID as ID1) = ID1 ()
 in ({name=S.symbol ID,pos=getPos IDleft,obtype_params=[]})
end)
 in ( LrTable.NT 19, ( result, ID1left, ID1right), rest671)
end
|  ( 367, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.ath_structure_profile (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,pos=getPos IDleft,
                           obtype_params=one_or_more_params}
)
end)
 in ( LrTable.NT 19, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 368, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.ath_structure_constructor (fn
 _ => let val  (ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,pos=getPos IDleft,argument_types=[],selectors=[]})

end)
 in ( LrTable.NT 26, ( result, ID1left, ID1right), rest671)
end
|  ( 369, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type_list 
selector_tagged_athena_object_type_list1, _, _)) :: ( _, ( MlyValue.ID
 ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.ath_structure_constructor (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (selector_tagged_athena_object_type_list as 
selector_tagged_athena_object_type_list1) = 
selector_tagged_athena_object_type_list1 ()
 in (
let val (sels,otypes) = Basic.unZip(selector_tagged_athena_object_type_list)
			       in
				  {name=S.symbol ID,pos=getPos IDleft,selectors=sels,
                                   argument_types=otypes}
			       end
)
end)
 in ( LrTable.NT 26, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 370, ( ( _, ( MlyValue.ath_structure_constructor 
ath_structure_constructor1, ath_structure_constructor1left, 
ath_structure_constructor1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_ath_structure_constructors (fn _ => let val  (
ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 in ([ath_structure_constructor])
end)
 in ( LrTable.NT 27, ( result, ath_structure_constructor1left, 
ath_structure_constructor1right), rest671)
end
|  ( 371, ( ( _, ( MlyValue.one_or_more_ath_structure_constructors 
one_or_more_ath_structure_constructors1, _, 
one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.ath_structure_constructor ath_structure_constructor1, 
ath_structure_constructor1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_ath_structure_constructors (fn _ => let val  (
ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 val  (one_or_more_ath_structure_constructors as 
one_or_more_ath_structure_constructors1) = 
one_or_more_ath_structure_constructors1 ()
 in (ath_structure_constructor::one_or_more_ath_structure_constructors
)
end)
 in ( LrTable.NT 27, ( result, ath_structure_constructor1left, 
one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 372, ( ( _, ( MlyValue.ath_structure_constructor 
ath_structure_constructor1, ath_structure_constructor1left, 
ath_structure_constructor1right)) :: rest671)) => let val  result = 
MlyValue.infix_one_or_more_ath_structure_constructors (fn _ => let
 val  (ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 in ([ath_structure_constructor])
end)
 in ( LrTable.NT 28, ( result, ath_structure_constructor1left, 
ath_structure_constructor1right), rest671)
end
|  ( 373, ( ( _, ( 
MlyValue.infix_one_or_more_ath_structure_constructors 
infix_one_or_more_ath_structure_constructors1, _, 
infix_one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.ath_structure_constructor ath_structure_constructor1, 
ath_structure_constructor1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_one_or_more_ath_structure_constructors (fn _ => let
 val  (ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_one_or_more_ath_structure_constructors as 
infix_one_or_more_ath_structure_constructors1) = 
infix_one_or_more_ath_structure_constructors1 ()
 in (
ath_structure_constructor::infix_one_or_more_ath_structure_constructors
)
end)
 in ( LrTable.NT 28, ( result, ath_structure_constructor1left, 
infix_one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 374, ( ( _, ( MlyValue.one_or_more_ath_structure_constructors 
one_or_more_ath_structure_constructors1, _, 
one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.ath_structure_profile ath_structure_profile1, 
ath_structure_profile1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_struc_clause (fn _ => let val  (ath_structure_profile as 
ath_structure_profile1) = ath_structure_profile1 ()
 val  (one_or_more_ath_structure_constructors as 
one_or_more_ath_structure_constructors1) = 
one_or_more_ath_structure_constructors1 ()
 in (
let val name = #name ath_structure_profile
                      val pos = #pos ath_structure_profile
                      val obtype_params = #obtype_params ath_structure_profile 
                      val obtype_names = map #name obtype_params
                      fun constantsToVars({name,pos,argument_types,selectors}:A.absyn_structure_constructor) =
                          let fun f(t) = Terms.taggedSymConstantsToVars(t,obtype_names)
                              val new_ob_types = map f argument_types
                          in
                             {name=name,pos=pos,argument_types=new_ob_types,selectors=selectors}
                          end
                      in 
                         {name=name,pos=pos,obtype_params=obtype_params,free=false,
                          constructors=(map constantsToVars
                                            one_or_more_ath_structure_constructors)}
                  end
)
end)
 in ( LrTable.NT 14, ( result, ath_structure_profile1left, 
one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 375, ( ( _, ( 
MlyValue.infix_one_or_more_ath_structure_constructors 
infix_one_or_more_ath_structure_constructors1, _, 
infix_one_or_more_ath_structure_constructors1right)) :: _ :: ( _, ( 
MlyValue.ath_structure_profile ath_structure_profile1, 
ath_structure_profile1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_struc_clause (fn _ => let val  (
ath_structure_profile as ath_structure_profile1) = 
ath_structure_profile1 ()
 val  (infix_one_or_more_ath_structure_constructors as 
infix_one_or_more_ath_structure_constructors1) = 
infix_one_or_more_ath_structure_constructors1 ()
 in (
let val name = #name ath_structure_profile
                      val pos = #pos ath_structure_profile
                      val obtype_params = #obtype_params ath_structure_profile 
                      val obtype_names = map #name obtype_params
                      fun constantsToVars({name,pos,argument_types,selectors}:A.absyn_structure_constructor) =
                          let fun f(t) = Terms.taggedSymConstantsToVars(t,obtype_names)
                              val new_ob_types = map f argument_types
                          in
                             {name=name,pos=pos,argument_types=new_ob_types,selectors=selectors}
                          end
                      in 
                         {name=name,pos=pos,obtype_params=obtype_params,free=false,
                          constructors=(map constantsToVars
                                            infix_one_or_more_ath_structure_constructors)}
                  end
)
end)
 in ( LrTable.NT 15, ( result, ath_structure_profile1left, 
infix_one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 376, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.rec_ath_struc_clause (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (ath_struc_clause)
end)
 in ( LrTable.NT 16, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 377, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_structure (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (ath_struc_clause)
end)
 in ( LrTable.NT 7, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 378, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_datatype (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (A.makeFree(ath_struc_clause))
end)
 in ( LrTable.NT 8, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 379, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, _, infix_ath_struc_clause1right)) :: ( _, ( _
, DATATYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatype (fn _ => let val  (infix_ath_struc_clause
 as infix_ath_struc_clause1) = infix_ath_struc_clause1 ()
 in (A.makeFree(infix_ath_struc_clause))
end)
 in ( LrTable.NT 9, ( result, DATATYPE1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 380, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, _, infix_ath_struc_clause1right)) :: ( _, ( _
, STRUCTURE1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatype (fn _ => let val  (infix_ath_struc_clause
 as infix_ath_struc_clause1) = infix_ath_struc_clause1 ()
 in (A.makeNonFree(infix_ath_struc_clause))
end)
 in ( LrTable.NT 9, ( result, STRUCTURE1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 381, ( ( _, ( MlyValue.rec_ath_struc_clause rec_ath_struc_clause1
, rec_ath_struc_clause1left, rec_ath_struc_clause1right)) :: rest671))
 => let val  result = MlyValue.one_or_more_rec_ath_struc_clauses (fn _
 => let val  (rec_ath_struc_clause as rec_ath_struc_clause1) = 
rec_ath_struc_clause1 ()
 in ([rec_ath_struc_clause])
end)
 in ( LrTable.NT 17, ( result, rec_ath_struc_clause1left, 
rec_ath_struc_clause1right), rest671)
end
|  ( 382, ( ( _, ( MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, 
one_or_more_rec_ath_struc_clauses1right)) :: ( _, ( 
MlyValue.rec_ath_struc_clause rec_ath_struc_clause1, 
rec_ath_struc_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_struc_clauses (fn _ => let val  (
rec_ath_struc_clause as rec_ath_struc_clause1) = rec_ath_struc_clause1
 ()
 val  (one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (rec_ath_struc_clause::one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 17, ( result, rec_ath_struc_clause1left, 
one_or_more_rec_ath_struc_clauses1right), rest671)
end
|  ( 383, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, infix_ath_struc_clause1left, 
infix_ath_struc_clause1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_datatype_clauses (fn _ => let val  (
infix_ath_struc_clause as infix_ath_struc_clause1) = 
infix_ath_struc_clause1 ()
 in ([infix_ath_struc_clause])
end)
 in ( LrTable.NT 18, ( result, infix_ath_struc_clause1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 384, ( ( _, ( MlyValue.one_or_more_rec_ath_datatype_clauses 
one_or_more_rec_ath_datatype_clauses1, _, 
one_or_more_rec_ath_datatype_clauses1right)) :: _ :: ( _, ( 
MlyValue.infix_ath_struc_clause infix_ath_struc_clause1, 
infix_ath_struc_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_datatype_clauses (fn _ => let val  (
infix_ath_struc_clause as infix_ath_struc_clause1) = 
infix_ath_struc_clause1 ()
 val  (one_or_more_rec_ath_datatype_clauses as 
one_or_more_rec_ath_datatype_clauses1) = 
one_or_more_rec_ath_datatype_clauses1 ()
 in (infix_ath_struc_clause::one_or_more_rec_ath_datatype_clauses)
end
)
 in ( LrTable.NT 18, ( result, infix_ath_struc_clause1left, 
one_or_more_rec_ath_datatype_clauses1right), rest671)
end
|  ( 385, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_structures (fn _ => let val  (
one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 11, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 386, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_datatypes (fn _ => let val  (
one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (List.map A.makeFree one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 12, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 387, ( ( _, ( MlyValue.one_or_more_rec_ath_datatype_clauses 
one_or_more_rec_ath_datatype_clauses1, _, 
one_or_more_rec_ath_datatype_clauses1right)) :: ( _, ( _, 
DATATYPES1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatypes (fn _ => let val  (
one_or_more_rec_ath_datatype_clauses as 
one_or_more_rec_ath_datatype_clauses1) = 
one_or_more_rec_ath_datatype_clauses1 ()
 in (List.map A.makeFree one_or_more_rec_ath_datatype_clauses)
end)
 in ( LrTable.NT 13, ( result, DATATYPES1left, 
one_or_more_rec_ath_datatype_clauses1right), rest671)
end
|  ( 388, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.athena_object_type (fn _ =>
 let val  (ID as ID1) = ID1 ()
 in (
let val id_pos = getPos(IDleft)
                       in 
                          SymTerm.makeTaggedConstant(A.makeMS(ID,SOME id_pos),id_pos)
                       end
)
end)
 in ( LrTable.NT 30, ( result, ID1left, ID1right), rest671)
end
|  ( 389, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, _)) :: ( _, ( _, FUNleft, _)) :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.athena_object_type (fn _ => let val  (
one_or_more_athena_object_types as one_or_more_athena_object_types1) =
 one_or_more_athena_object_types1 ()
 in (
let val id_pos = getPos(FUNleft)
                        in
                           SymTerm.makeTaggedApp(A.makeMS("Fun",SOME id_pos),id_pos,one_or_more_athena_object_types)
                        end
)
end)
 in ( LrTable.NT 30, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 390, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.athena_object_type (fn _ => let val  (ID as ID1) = 
ID1 ()
 val  (one_or_more_athena_object_types as 
one_or_more_athena_object_types1) = one_or_more_athena_object_types1
 ()
 in (
let val id_pos = getPos(IDleft)
                        in
                           SymTerm.makeTaggedApp(A.makeMS(ID,SOME id_pos),id_pos,one_or_more_athena_object_types)
                        end
)
end)
 in ( LrTable.NT 30, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 391, ( ( _, ( MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, athena_object_type1right)) :: rest671)) =>
 let val  result = MlyValue.selector_tagged_athena_object_type (fn _
 => let val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ((NONE,athena_object_type))
end)
 in ( LrTable.NT 33, ( result, athena_object_type1left, 
athena_object_type1right), rest671)
end
|  ( 392, ( ( _, ( MlyValue.athena_object_type athena_object_type1, _,
 athena_object_type1right)) :: _ :: ( _, ( MlyValue.param param1, 
param1left, _)) :: rest671)) => let val  result = 
MlyValue.selector_tagged_athena_object_type (fn _ => let val  (param
 as param1) = param1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ((SOME(param),athena_object_type))
end)
 in ( LrTable.NT 33, ( result, param1left, athena_object_type1right), 
rest671)
end
|  ( 393, ( rest671)) => let val  result = 
MlyValue.athena_object_type_list (fn _ => ([]))
 in ( LrTable.NT 36, ( result, defaultPos, defaultPos), rest671)
end
|  ( 394, ( ( _, ( MlyValue.athena_object_type_list 
athena_object_type_list1, _, athena_object_type_list1right)) :: ( _, (
 MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, _)) :: rest671)) => let val  result = 
MlyValue.athena_object_type_list (fn _ => let val  (athena_object_type
 as athena_object_type1) = athena_object_type1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 in (athena_object_type::athena_object_type_list)
end)
 in ( LrTable.NT 36, ( result, athena_object_type1left, 
athena_object_type_list1right), rest671)
end
|  ( 395, ( rest671)) => let val  result = 
MlyValue.selector_tagged_athena_object_type_list (fn _ => ([]))
 in ( LrTable.NT 37, ( result, defaultPos, defaultPos), rest671)
end
|  ( 396, ( ( _, ( MlyValue.selector_tagged_athena_object_type_list 
selector_tagged_athena_object_type_list1, _, 
selector_tagged_athena_object_type_list1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, _)) :: rest671)) => let val  
result = MlyValue.selector_tagged_athena_object_type_list (fn _ => let
 val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 val  (selector_tagged_athena_object_type_list as 
selector_tagged_athena_object_type_list1) = 
selector_tagged_athena_object_type_list1 ()
 in (
selector_tagged_athena_object_type::selector_tagged_athena_object_type_list
)
end)
 in ( LrTable.NT 37, ( result, selector_tagged_athena_object_type1left
, selector_tagged_athena_object_type_list1right), rest671)
end
|  ( 397, ( ( _, ( MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, athena_object_type1right)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_athena_object_types (fn _ =>
 let val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ([athena_object_type])
end)
 in ( LrTable.NT 34, ( result, athena_object_type1left, 
athena_object_type1right), rest671)
end
|  ( 398, ( ( _, ( MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, 
one_or_more_athena_object_types1right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_athena_object_types (fn _ => let val  (
athena_object_type as athena_object_type1) = athena_object_type1 ()
 val  (one_or_more_athena_object_types as 
one_or_more_athena_object_types1) = one_or_more_athena_object_types1
 ()
 in (athena_object_type::one_or_more_athena_object_types)
end)
 in ( LrTable.NT 34, ( result, athena_object_type1left, 
one_or_more_athena_object_types1right), rest671)
end
|  ( 399, ( ( _, ( MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, 
selector_tagged_athena_object_type1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_selector_tagged_athena_object_types (fn
 _ => let val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 in ([selector_tagged_athena_object_type])
end)
 in ( LrTable.NT 35, ( result, selector_tagged_athena_object_type1left
, selector_tagged_athena_object_type1right), rest671)
end
|  ( 400, ( ( _, ( 
MlyValue.one_or_more_selector_tagged_athena_object_types 
one_or_more_selector_tagged_athena_object_types1, _, 
one_or_more_selector_tagged_athena_object_types1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, _)) :: rest671)) => let val  
result = MlyValue.one_or_more_selector_tagged_athena_object_types (fn
 _ => let val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 val  (one_or_more_selector_tagged_athena_object_types as 
one_or_more_selector_tagged_athena_object_types1) = 
one_or_more_selector_tagged_athena_object_types1 ()
 in (
selector_tagged_athena_object_type::one_or_more_selector_tagged_athena_object_types
)
end)
 in ( LrTable.NT 35, ( result, selector_tagged_athena_object_type1left
, one_or_more_selector_tagged_athena_object_types1right), rest671)
end
|  ( 401, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.param (fn _ => let val  (ID
 as ID1) = ID1 ()
 in ({name=S.symbol ID, pos=getPos IDleft})
end)
 in ( LrTable.NT 38, ( result, ID1left, ID1right), rest671)
end
|  ( 402, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.param_no_dots (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
A.checkNoDots(ID,getPos IDleft);{name=S.symbol ID, pos=getPos IDleft})

end)
 in ( LrTable.NT 39, ( result, ID1left, ID1right), rest671)
end
|  ( 403, ( rest671)) => let val  result = MlyValue.param_option (fn _
 => (NONE))
 in ( LrTable.NT 51, ( result, defaultPos, defaultPos), rest671)
end
|  ( 404, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = MlyValue.param_option (fn _ => let
 val  (param as param1) = param1 ()
 in (SOME(#name(param)))
end)
 in ( LrTable.NT 51, ( result, param1left, param1right), rest671)
end
|  ( 405, ( rest671)) => let val  result = 
MlyValue.param_option_no_dots (fn _ => (NONE))
 in ( LrTable.NT 52, ( result, defaultPos, defaultPos), rest671)
end
|  ( 406, ( ( _, ( MlyValue.param_no_dots param_no_dots1, 
param_no_dots1left, param_no_dots1right)) :: rest671)) => let val  
result = MlyValue.param_option_no_dots (fn _ => let val  (
param_no_dots as param_no_dots1) = param_no_dots1 ()
 in (SOME(#name(param_no_dots)))
end)
 in ( LrTable.NT 52, ( result, param_no_dots1left, param_no_dots1right
), rest671)
end
|  ( 407, ( rest671)) => let val  result = MlyValue.params (fn _ => (
[]))
 in ( LrTable.NT 53, ( result, defaultPos, defaultPos), rest671)
end
|  ( 408, ( ( _, ( MlyValue.params params1, _, params1right)) :: ( _, 
( MlyValue.param param1, param1left, _)) :: rest671)) => let val  
result = MlyValue.params (fn _ => let val  (param as param1) = param1
 ()
 val  (params as params1) = params1 ()
 in (param::params)
end)
 in ( LrTable.NT 53, ( result, param1left, params1right), rest671)
end
|  ( 409, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.possibly_typed_param (fn _ =>
 let val  (ID as ID1) = ID1 ()
 in (

                          {name=S.symbol ID, pos=getPos IDleft,sort_as_sym_term=NONE,sort_as_fterm=NONE,op_tag=NONE,sort_as_exp=NONE}
)
end)
 in ( LrTable.NT 47, ( result, ID1left, ID1right), rest671)
end
|  ( 410, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.possibly_typed_param (fn _ => let val 
 (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (

                                          {name=S.symbol ID, pos=getPos IDleft,sort_as_sym_term=SOME user_sort,op_tag=NONE,
					    sort_as_fterm=NONE,sort_as_exp=NONE}
)
end)
 in ( LrTable.NT 47, ( result, ID1left, user_sort1right), rest671)
end
|  ( 411, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, ID1left, _)) ::
 rest671)) => let val  result = MlyValue.possibly_typed_param (fn _ =>
 let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (

                               (case Int.fromString(ID2) of
                                  SOME(i) => 
                                      ({name=S.symbol ID1, pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,~1),
  				        sort_as_fterm=NONE,sort_as_exp=NONE})
                                | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 47, ( result, ID1left, RPAREN1right), rest671)
end
|  ( 412, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID3, _,
 _)) :: ( _, ( MlyValue.ID ID2, _, _)) :: _ :: ( _, ( _, LPARENleft, _
)) :: _ :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: rest671)) => let
 val  result = MlyValue.possibly_typed_param (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (

                               (case (Int.fromString(ID2),Int.fromString(ID3)) of
                                   (SOME(i),SOME(j)) => 
                                       ({name=S.symbol ID1, pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,j),
  				         sort_as_fterm=NONE,sort_as_exp=NONE})
                                 | _ => Data.genEx("Operator annotation error: invalid arity and/or precedence",
                                                   SOME(getPos LPARENleft),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 47, ( result, ID1left, RPAREN1right), rest671)
end
|  ( 413, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_typed_param_no_dots (fn _ =>
 let val  (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in (
let val res as {name,pos,...} = possibly_typed_param
                                   in
                                      (A.checkNoDots(S.name name,pos);res)
                                   end
)
end)
 in ( LrTable.NT 48, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 414, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_typed_params (fn _ => let val 
 (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in ([possibly_typed_param])
end)
 in ( LrTable.NT 49, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 415, ( ( _, ( MlyValue.possibly_typed_params 
possibly_typed_params1, _, possibly_typed_params1right)) :: ( _, ( 
MlyValue.possibly_typed_param possibly_typed_param1, 
possibly_typed_param1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_typed_params (fn _ => let val  (possibly_typed_param
 as possibly_typed_param1) = possibly_typed_param1 ()
 val  (possibly_typed_params as possibly_typed_params1) = 
possibly_typed_params1 ()
 in (possibly_typed_param::possibly_typed_params)
end)
 in ( LrTable.NT 49, ( result, possibly_typed_param1left, 
possibly_typed_params1right), rest671)
end
|  ( 416, ( ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right)) :: rest671)) => let val  result =
 MlyValue.possibly_typed_params_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 in ([possibly_typed_param_no_dots])
end)
 in ( LrTable.NT 50, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right), rest671)
end
|  ( 417, ( ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, possibly_typed_params_no_dots1right
)) :: ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, _))
 :: rest671)) => let val  result = 
MlyValue.possibly_typed_params_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 val  (possibly_typed_params_no_dots as possibly_typed_params_no_dots1
) = possibly_typed_params_no_dots1 ()
 in (possibly_typed_param_no_dots::possibly_typed_params_no_dots)
end)
 in ( LrTable.NT 50, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_params_no_dots1right), rest671)
end
|  ( 418, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_wildcard_param (fn _ => let
 val  (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in (A.someParam(possibly_typed_param))
end)
 in ( LrTable.NT 43, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 419, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.possibly_wildcard_param
 (fn _ => (A.wildCard(getPos ANY_PATleft)))
 in ( LrTable.NT 43, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 420, ( ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right)) :: rest671)) => let val  result =
 MlyValue.possibly_wildcard_param_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 in (A.someParam(possibly_typed_param_no_dots))
end)
 in ( LrTable.NT 44, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right), rest671)
end
|  ( 421, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_no_dots (fn _ => (
A.wildCard(getPos ANY_PATleft)))
 in ( LrTable.NT 44, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 422, ( rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list (fn _ => ([]))
 in ( LrTable.NT 45, ( result, defaultPos, defaultPos), rest671)
end
|  ( 423, ( ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, possibly_wildcard_param_list1right))
 :: ( _, ( MlyValue.possibly_wildcard_param possibly_wildcard_param1, 
possibly_wildcard_param1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 in (possibly_wildcard_param::possibly_wildcard_param_list)
end)
 in ( LrTable.NT 45, ( result, possibly_wildcard_param1left, 
possibly_wildcard_param_list1right), rest671)
end
|  ( 424, ( rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list_no_dots (fn _ => ([]))
 in ( LrTable.NT 46, ( result, defaultPos, defaultPos), rest671)
end
|  ( 425, ( ( _, ( MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, 
possibly_wildcard_param_list_no_dots1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param_no_dots 
possibly_wildcard_param_no_dots1, possibly_wildcard_param_no_dots1left
, _)) :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list_no_dots (fn _ => let val  (
possibly_wildcard_param_no_dots as possibly_wildcard_param_no_dots1) =
 possibly_wildcard_param_no_dots1 ()
 val  (possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 in (
possibly_wildcard_param_no_dots::possibly_wildcard_param_list_no_dots)

end)
 in ( LrTable.NT 46, ( result, possibly_wildcard_param_no_dots1left, 
possibly_wildcard_param_list_no_dots1right), rest671)
end
|  ( 426, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = 
MlyValue.one_or_more_comma_separated_params (fn _ => let val  (param
 as param1) = param1 ()
 in ([param])
end)
 in ( LrTable.NT 58, ( result, param1left, param1right), rest671)
end
|  ( 427, ( ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, 
one_or_more_comma_separated_params1right)) :: _ :: ( _, ( 
MlyValue.param param1, param1left, _)) :: rest671)) => let val  result
 = MlyValue.one_or_more_comma_separated_params (fn _ => let val  (
param as param1) = param1 ()
 val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (param::one_or_more_comma_separated_params)
end)
 in ( LrTable.NT 58, ( result, param1left, 
one_or_more_comma_separated_params1right), rest671)
end
|  ( 428, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps (fn _ => let val  (param
 as param1) = param1 ()
 in ([param])
end)
 in ( LrTable.NT 54, ( result, param1left, param1right), rest671)
end
|  ( 429, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps 
one_or_more_params_maybe_with_reps1, _, 
one_or_more_params_maybe_with_reps1right)) :: ( _, ( MlyValue.param 
param1, param1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps (fn _ => let val  (param
 as param1) = param1 ()
 val  (one_or_more_params_maybe_with_reps as 
one_or_more_params_maybe_with_reps1) = 
one_or_more_params_maybe_with_reps1 ()
 in (param::one_or_more_params_maybe_with_reps)
end)
 in ( LrTable.NT 54, ( result, param1left, 
one_or_more_params_maybe_with_reps1right), rest671)
end
|  ( 430, ( ( _, ( MlyValue.param_no_dots param_no_dots1, 
param_no_dots1left, param_no_dots1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_params_maybe_with_reps_no_dots (fn _ =>
 let val  (param_no_dots as param_no_dots1) = param_no_dots1 ()
 in ([param_no_dots])
end)
 in ( LrTable.NT 55, ( result, param_no_dots1left, param_no_dots1right
), rest671)
end
|  ( 431, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps_no_dots
 one_or_more_params_maybe_with_reps_no_dots1, _, 
one_or_more_params_maybe_with_reps_no_dots1right)) :: ( _, ( 
MlyValue.param_no_dots param_no_dots1, param_no_dots1left, _)) :: 
rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps_no_dots (fn _ => let val 
 (param_no_dots as param_no_dots1) = param_no_dots1 ()
 val  (one_or_more_params_maybe_with_reps_no_dots as 
one_or_more_params_maybe_with_reps_no_dots1) = 
one_or_more_params_maybe_with_reps_no_dots1 ()
 in (param_no_dots::one_or_more_params_maybe_with_reps_no_dots)
end)
 in ( LrTable.NT 55, ( result, param_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right), rest671)
end
|  ( 432, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps 
one_or_more_params_maybe_with_reps1, 
one_or_more_params_maybe_with_reps1left, 
one_or_more_params_maybe_with_reps1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_params (fn _ => let val  (
one_or_more_params_maybe_with_reps as 
one_or_more_params_maybe_with_reps1) = 
one_or_more_params_maybe_with_reps1 ()
 in (A.getParams(one_or_more_params_maybe_with_reps))
end)
 in ( LrTable.NT 56, ( result, one_or_more_params_maybe_with_reps1left
, one_or_more_params_maybe_with_reps1right), rest671)
end
|  ( 433, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps_no_dots
 one_or_more_params_maybe_with_reps_no_dots1, 
one_or_more_params_maybe_with_reps_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right)) :: rest671)) => let
 val  result = MlyValue.one_or_more_params_no_dots (fn _ => let val  (
one_or_more_params_maybe_with_reps_no_dots as 
one_or_more_params_maybe_with_reps_no_dots1) = 
one_or_more_params_maybe_with_reps_no_dots1 ()
 in (A.getParams(one_or_more_params_maybe_with_reps_no_dots))
end)
 in ( LrTable.NT 57, ( result, 
one_or_more_params_maybe_with_reps_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right), rest671)
end
|  ( 434, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.struc_pattern (fn _ => (
A.anyPat({pos=getPos ANY_PATleft})))
 in ( LrTable.NT 89, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 435, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.struc_pattern (fn _ => let val  (
possibly_typed_param as possibly_typed_param1) = possibly_typed_param1
 ()
 in (A.idPat(possibly_typed_param))
end)
 in ( LrTable.NT 89, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 436, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.struc_patterns struc_patterns1, _, _)) :: ( _, ( _, (
LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val  
result = MlyValue.struc_pattern (fn _ => let val  (struc_patterns as 
struc_patterns1) = struc_patterns1 ()
 in (
A.listPats({member_pats=struc_patterns,pos=getPos LEFT_BRACKETleft}))

end)
 in ( LrTable.NT 89, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 437, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.struc_pattern struc_pattern2, _, _)) :: ( _, ( 
MlyValue.struc_pattern struc_pattern1, _, _)) :: ( _, ( _, LISTleft, _
)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.struc_pattern (fn _ => let val  struc_pattern1 = 
struc_pattern1 ()
 val  struc_pattern2 = struc_pattern2 ()
 in (
A.listPat({head_pat=struc_pattern1,tail_pat=struc_pattern2,pos=getPos LISTleft})
)
end)
 in ( LrTable.NT 89, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 438, ( rest671)) => let val  result = MlyValue.struc_patterns (fn
 _ => ([]))
 in ( LrTable.NT 91, ( result, defaultPos, defaultPos), rest671)
end
|  ( 439, ( ( _, ( MlyValue.struc_patterns struc_patterns1, _, 
struc_patterns1right)) :: ( _, ( MlyValue.struc_pattern struc_pattern1
, struc_pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.struc_patterns (fn _ => let val  (struc_pattern as 
struc_pattern1) = struc_pattern1 ()
 val  (struc_patterns as struc_patterns1) = struc_patterns1 ()
 in (struc_pattern::struc_patterns)
end)
 in ( LrTable.NT 91, ( result, struc_pattern1left, 
struc_patterns1right), rest671)
end
|  ( 440, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.pattern (fn _ => (
A.anyPat({pos=getPos ANY_PATleft})))
 in ( LrTable.NT 88, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 441, ( ( _, ( MlyValue.expression expression1, expressionleft, 
expression1right)) :: ( _, ( _, EXCL_MARK1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  (expression as 
expression1) = expression1 ()
 in (A.makeCharConstraintRE(expression,getPos(expressionleft)))
end)
 in ( LrTable.NT 88, ( result, EXCL_MARK1left, expression1right), 
rest671)
end
|  ( 442, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => (A.unitValPat({pos=getPos LPARENleft})))
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 443, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_typed_param as possibly_typed_param1) = possibly_typed_param1
 ()
 in (A.idPat(possibly_typed_param))
end)
 in ( LrTable.NT 88, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 444, ( ( _, ( MlyValue.STRING STRING1, (STRINGleft as STRING1left
), STRING1right)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (A.constantStringPat({str=STRING,pos=getPos STRINGleft}))
end)
 in ( LrTable.NT 88, ( result, STRING1left, STRING1right), rest671)

end
|  ( 445, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.patterns patterns1, _, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.pattern (fn _ => let val  (patterns as patterns1) = patterns1
 ()
 in (A.listPats({member_pats=patterns,pos=getPos LEFT_BRACKETleft}))

end)
 in ( LrTable.NT 88, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 446, ( ( _, ( MlyValue.athena_var athena_var1, (athena_varleft
 as athena_var1left), athena_var1right)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (athena_var as athena_var1
) = athena_var1 ()
 in (
A.constantTermVarPat({term_var=athena_var,pos=getPos athena_varleft}))

end)
 in ( LrTable.NT 88, ( result, athena_var1left, athena_var1right), 
rest671)
end
|  ( 447, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, (QMARKleft as 
QMARK1left), _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.constantTermVarPat({term_var=AthTermVar.athTermVarWithSort(ID,FTerm.translateFromSymTerm(SymTerm.stripTags user_sort)),
						          pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 88, ( result, QMARK1left, user_sort1right), rest671)

end
|  ( 448, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, META_IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (ID
 as ID1) = ID1 ()
 in (A.constantMetaIdPat({name=S.symbol ID,pos=getPos META_IDleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 449, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 in (
A.constantMetaIdPat({name=S.symbol ID,pos=getPos QUOTE_SYMBOLleft}))

end)
 in ( LrTable.NT 88, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 450, ( ( _, ( MlyValue.CHARACTER CHARACTER1, (CHARACTERleft as 
CHARACTER1left), CHARACTER1right)) :: rest671)) => let val  result = 
MlyValue.pattern (fn _ => let val  (CHARACTER as CHARACTER1) = 
CHARACTER1 ()
 in (A.constantCharPat({ch=CHARACTER,pos=getPos CHARACTERleft}))
end)
 in ( LrTable.NT 88, ( result, CHARACTER1left, CHARACTER1right), 
rest671)
end
|  ( 451, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, VAL_OFleft, _)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.pattern (fn _ => let val 
 (ID as ID1) = ID1 ()
 in (
A.valOfPat({id={name=S.symbol ID,pos=getPos IDleft},lex_ad=NONE,
                                               pos=getPos VAL_OFleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 452, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_VARleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someVarPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_VARleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 453, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_VECTORleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someVectorPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_VECTORleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 454, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_CHARleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someCharPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_CHARleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 455, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_QUANTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someQuantPat({id=possibly_wildcard_param,
                                                       pos=getPos SOME_QUANTleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 456, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_PROP_CONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.somePropConPat({id=possibly_wildcard_param,
                                                            pos=getPos SOME_PROP_CONleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 457, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_TERMleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someTermPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_TERMleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 458, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_ATOMleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someAtomPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_ATOMleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 459, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_PROPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.somePropPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_PROPleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 460, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_FUNCTIONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someFunctionPat({id=possibly_wildcard_param,
                                                             pos=getPos SOME_FUNCTIONleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 461, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_METHODleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someMethodPat({id=possibly_wildcard_param,
                                                         pos=getPos SOME_METHODleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 462, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_SYMBOLleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someSymbolPat({id=possibly_wildcard_param,
                                                         pos=getPos SOME_SYMBOLleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 463, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_SUBleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someSubPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_SUBleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 464, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_TABLEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someTablePat({id=possibly_wildcard_param,pos=getPos SOME_TABLEleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 465, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_MAPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someMapPat({id=possibly_wildcard_param,pos=getPos SOME_MAPleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 466, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern2, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, LISTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.pattern (fn _ => let val  pattern1 = pattern1
 ()
 val  pattern2 = pattern2 ()
 in (
A.listPat({head_pat=pattern1,tail_pat=pattern2,pos=getPos LISTleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 467, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, CELLleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 in (A.cellPat({pat=pattern,pos=getPos CELLleft}))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 468, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.two_or_more_patterns two_or_more_patterns1, _, _)) :: ( _, (
 _, SPLIT_PATleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  (
two_or_more_patterns as two_or_more_patterns1) = two_or_more_patterns1
 ()
 in (
A.splitPat({pats=two_or_more_patterns,pos=getPos SPLIT_PATleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 469, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_STARleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.reStarPat({pat=pattern,pos=getPos RE_STARleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 470, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_OPTIONALleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.reOptPat({pat=pattern,pos=getPos RE_OPTIONALleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 471, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_PLUSleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.rePlusPat({pat=pattern,pos=getPos RE_PLUSleft,code=A.getRECode(),re_form=GeneralRE.any0(GeneralRE.trivial_tag)})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 472, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_LITleft, _)) :: ( _, ( _, LPAREN1left
, _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 in (A.reLitPat({pat=pattern,pos=getPos RE_LITleft}))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 473, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern2, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, RE_RANGEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  pattern1 = 
pattern1 ()
 val  pattern2 = pattern2 ()
 in (
let val (l,h) = A.getPatCodes(pattern1,pattern2)
              in
                 A.reRangePat({from_pat=pattern1,to_pat=pattern2,lo=l,hi=h,pos=getPos RE_RANGEleft})
              end
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 474, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, ( _, 
RE_REPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.pattern (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (ID as ID1) = ID1 ()
 in (
case Int.fromString(ID) of
                                               SOME(i) => A.reRepPat({pat=pattern,times=i,pos=getPos RE_REPleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
                                             | _ => raise A.SyntaxError("an integer numeral was expected here",SOME(getPos IDleft))
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 475, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_LISTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someListPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_LISTleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 476, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_CELLleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someCellPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_CELLleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 477, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.pattern pattern1, 
patternleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.pattern (fn _ => let val  (pattern as pattern1
) = pattern1 ()
 val  (expression as expression1) = expression1 ()
 in (A.wherePat({pat=pattern,guard=expression,pos=getPos patternleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 478, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_patterns one_or_more_patterns1, 
one_or_more_patternsleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
one_or_more_patterns as one_or_more_patterns1) = one_or_more_patterns1
 ()
 in (
A.disjPat({pats=one_or_more_patterns,pos=getPos one_or_more_patternsleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 479, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_patterns one_or_more_patterns1, _, _)) :: ( _, ( 
MlyValue.pattern pattern1, patternleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (
A.compoundPat({head_pat=pattern,rest_pats=one_or_more_patterns,pos=getPos patternleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 480, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, 
NAMEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 val  (pattern as pattern1) = pattern1 ()
 in (A.namedPat({name=S.symbol ID,pat=pattern,pos=getPos NAMEleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 481, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, NAMEleft, _)) :: ( _, ( MlyValue.ID ID1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 val  (pattern as pattern1) = pattern1 ()
 in (A.namedPat({name=S.symbol ID,pat=pattern,pos=getPos NAMEleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 482, ( ( _, ( MlyValue.pattern pattern1, pattern1left, 
pattern1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 in ([pattern])
end)
 in ( LrTable.NT 101, ( result, pattern1left, pattern1right), rest671)

end
|  ( 483, ( ( _, ( MlyValue.one_or_more_patterns one_or_more_patterns1
, _, one_or_more_patterns1right)) :: ( _, ( MlyValue.pattern pattern1,
 pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (pattern::one_or_more_patterns)
end)
 in ( LrTable.NT 101, ( result, pattern1left, 
one_or_more_patterns1right), rest671)
end
|  ( 484, ( ( _, ( MlyValue.one_or_more_patterns one_or_more_patterns1
, _, one_or_more_patterns1right)) :: ( _, ( MlyValue.pattern pattern1,
 pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.two_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (pattern::one_or_more_patterns)
end)
 in ( LrTable.NT 102, ( result, pattern1left, 
one_or_more_patterns1right), rest671)
end
|  ( 485, ( rest671)) => let val  result = MlyValue.patterns (fn _ =>
 ([]))
 in ( LrTable.NT 90, ( result, defaultPos, defaultPos), rest671)
end
|  ( 486, ( ( _, ( MlyValue.patterns patterns1, _, patterns1right)) ::
 ( _, ( MlyValue.pattern pattern1, pattern1left, _)) :: rest671)) =>
 let val  result = MlyValue.patterns (fn _ => let val  (pattern as 
pattern1) = pattern1 ()
 val  (patterns as patterns1) = patterns1 ()
 in (pattern::patterns)
end)
 in ( LrTable.NT 90, ( result, pattern1left, patterns1right), rest671)

end
|  ( 487, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = MlyValue.condition (fn _ => let
 val  (phrase as phrase1) = phrase1 ()
 in (A.boolCond(phrase))
end)
 in ( LrTable.NT 100, ( result, phrase1left, phrase1right), rest671)

end
|  ( 488, ( ( _, ( _, ELSE1left, ELSE1right)) :: rest671)) => let val 
 result = MlyValue.condition (fn _ => (A.elseCond))
 in ( LrTable.NT 100, ( result, ELSE1left, ELSE1right), rest671)
end
|  ( 489, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.condition condition1, _, _)) ::
 ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.check_clause (fn _ => let val  (condition as condition1) = 
condition1 ()
 val  (expression as expression1) = expression1 ()
 in ({test=condition,result=expression})
end)
 in ( LrTable.NT 92, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 490, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.condition condition1, 
condition1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_check_clause (fn _ => let val  (condition as condition1
) = condition1 ()
 val  (expression as expression1) = expression1 ()
 in ({test=condition,result=expression})
end)
 in ( LrTable.NT 93, ( result, condition1left, expression1right), 
rest671)
end
|  ( 491, ( ( _, ( MlyValue.infix_check_clause infix_check_clause1, 
infix_check_clause1left, infix_check_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_check_clauses (fn _ => let val  (
infix_check_clause as infix_check_clause1) = infix_check_clause1 ()
 in ([infix_check_clause])
end)
 in ( LrTable.NT 94, ( result, infix_check_clause1left, 
infix_check_clause1right), rest671)
end
|  ( 492, ( ( _, ( MlyValue.infix_check_clauses infix_check_clauses1,
 _, infix_check_clauses1right)) :: ( _, ( MlyValue.single_logical_or 
single_logical_or1, _, _)) :: ( _, ( MlyValue.infix_check_clause 
infix_check_clause1, infix_check_clause1left, _)) :: rest671)) => let
 val  result = MlyValue.infix_check_clauses (fn _ => let val  (
infix_check_clause as infix_check_clause1) = infix_check_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_check_clauses as infix_check_clauses1) = 
infix_check_clauses1 ()
 in (infix_check_clause::infix_check_clauses)
end)
 in ( LrTable.NT 94, ( result, infix_check_clause1left, 
infix_check_clauses1right), rest671)
end
|  ( 493, ( rest671)) => let val  result = MlyValue.check_clauses (fn
 _ => ([]))
 in ( LrTable.NT 95, ( result, defaultPos, defaultPos), rest671)
end
|  ( 494, ( ( _, ( MlyValue.check_clauses check_clauses1, _, 
check_clauses1right)) :: ( _, ( MlyValue.check_clause check_clause1, 
check_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.check_clauses (fn _ => let val  (check_clause as 
check_clause1) = check_clause1 ()
 val  (check_clauses as check_clauses1) = check_clauses1 ()
 in (check_clause::check_clauses)
end)
 in ( LrTable.NT 95, ( result, check_clause1left, check_clauses1right)
, rest671)
end
|  ( 495, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.condition condition1, _, _)) :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.dcheck_clause (fn _ => let val  (condition as condition1) = 
condition1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({test=condition,result=deduction})
end)
 in ( LrTable.NT 96, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 496, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.condition condition1, condition1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_dcheck_clause (fn _ =>
 let val  (condition as condition1) = condition1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({test=condition,result=deduction})
end)
 in ( LrTable.NT 97, ( result, condition1left, deduction1right), 
rest671)
end
|  ( 497, ( ( _, ( MlyValue.infix_dcheck_clause infix_dcheck_clause1, 
infix_dcheck_clause1left, infix_dcheck_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_dcheck_clauses (fn _ => let val  (
infix_dcheck_clause as infix_dcheck_clause1) = infix_dcheck_clause1 ()
 in ([infix_dcheck_clause])
end)
 in ( LrTable.NT 98, ( result, infix_dcheck_clause1left, 
infix_dcheck_clause1right), rest671)
end
|  ( 498, ( ( _, ( MlyValue.infix_dcheck_clauses infix_dcheck_clauses1
, _, infix_dcheck_clauses1right)) :: ( _, ( MlyValue.single_logical_or
 single_logical_or1, _, _)) :: ( _, ( MlyValue.infix_dcheck_clause 
infix_dcheck_clause1, infix_dcheck_clause1left, _)) :: rest671)) =>
 let val  result = MlyValue.infix_dcheck_clauses (fn _ => let val  (
infix_dcheck_clause as infix_dcheck_clause1) = infix_dcheck_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 in (infix_dcheck_clause::infix_dcheck_clauses)
end)
 in ( LrTable.NT 98, ( result, infix_dcheck_clause1left, 
infix_dcheck_clauses1right), rest671)
end
|  ( 499, ( rest671)) => let val  result = MlyValue.dcheck_clauses (fn
 _ => ([]))
 in ( LrTable.NT 99, ( result, defaultPos, defaultPos), rest671)
end
|  ( 500, ( ( _, ( MlyValue.dcheck_clauses dcheck_clauses1, _, 
dcheck_clauses1right)) :: ( _, ( MlyValue.dcheck_clause dcheck_clause1
, dcheck_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.dcheck_clauses (fn _ => let val  (dcheck_clause as 
dcheck_clause1) = dcheck_clause1 ()
 val  (dcheck_clauses as dcheck_clauses1) = dcheck_clauses1 ()
 in (dcheck_clause::dcheck_clauses)
end)
 in ( LrTable.NT 99, ( result, dcheck_clause1left, 
dcheck_clauses1right), rest671)
end
|  ( 501, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.match_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 103, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 502, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _,
 ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.dmatch_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 105, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 503, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.pattern pattern1, pattern1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_dmatch_clause (fn _ =>
 let val  (pattern as pattern1) = pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 106, ( result, pattern1left, deduction1right), 
rest671)
end
|  ( 504, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.pattern pattern1, 
pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_match_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 107, ( result, pattern1left, expression1right), 
rest671)
end
|  ( 505, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.pattern pattern1, _, _)) ::
 ( _, ( MlyValue.single_logical_or single_logical_or1, 
single_logical_or1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clause (fn _ => let val  single_logical_or1 =
 single_logical_or1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 108, ( result, single_logical_or1left, 
expression1right), rest671)
end
|  ( 506, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, single_logical_or1left,
 _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clause (fn _ => let val  single_logical_or1
 = single_logical_or1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 109, ( result, single_logical_or1left, 
deduction1right), rest671)
end
|  ( 507, ( rest671)) => let val  result = MlyValue.match_clauses (fn
 _ => ([]))
 in ( LrTable.NT 104, ( result, defaultPos, defaultPos), rest671)
end
|  ( 508, ( ( _, ( MlyValue.match_clauses match_clauses1, _, 
match_clauses1right)) :: ( _, ( MlyValue.match_clause match_clause1, 
match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.match_clauses (fn _ => let val  (match_clause as 
match_clause1) = match_clause1 ()
 val  (match_clauses as match_clauses1) = match_clauses1 ()
 in (match_clause::match_clauses)
end)
 in ( LrTable.NT 104, ( result, match_clause1left, match_clauses1right
), rest671)
end
|  ( 509, ( rest671)) => let val  result = MlyValue.dmatch_clauses (fn
 _ => ([]))
 in ( LrTable.NT 113, ( result, defaultPos, defaultPos), rest671)
end
|  ( 510, ( ( _, ( MlyValue.dmatch_clauses dmatch_clauses1, _, 
dmatch_clauses1right)) :: ( _, ( MlyValue.dmatch_clause dmatch_clause1
, dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.dmatch_clauses (fn _ => let val  (dmatch_clause as 
dmatch_clause1) = dmatch_clause1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (dmatch_clause::dmatch_clauses)
end)
 in ( LrTable.NT 113, ( result, dmatch_clause1left, 
dmatch_clauses1right), rest671)
end
|  ( 511, ( ( _, ( MlyValue.sep_infix_match_clause 
sep_infix_match_clause1, sep_infix_match_clause1left, 
sep_infix_match_clause1right)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clauses (fn _ => let val  (
sep_infix_match_clause as sep_infix_match_clause1) = 
sep_infix_match_clause1 ()
 in ([sep_infix_match_clause])
end)
 in ( LrTable.NT 110, ( result, sep_infix_match_clause1left, 
sep_infix_match_clause1right), rest671)
end
|  ( 512, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, _, sep_infix_match_clauses1right)) :: ( _, (
 MlyValue.sep_infix_match_clause sep_infix_match_clause1, 
sep_infix_match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clauses (fn _ => let val  (
sep_infix_match_clause as sep_infix_match_clause1) = 
sep_infix_match_clause1 ()
 val  (sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (sep_infix_match_clause::sep_infix_match_clauses)
end)
 in ( LrTable.NT 110, ( result, sep_infix_match_clause1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 513, ( ( _, ( MlyValue.sep_infix_dmatch_clause 
sep_infix_dmatch_clause1, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clause1right)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clause as sep_infix_dmatch_clause1) = 
sep_infix_dmatch_clause1 ()
 in ([sep_infix_dmatch_clause])
end)
 in ( LrTable.NT 111, ( result, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clause1right), rest671)
end
|  ( 514, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, _, sep_infix_dmatch_clauses1right)) :: ( _,
 ( MlyValue.sep_infix_dmatch_clause sep_infix_dmatch_clause1, 
sep_infix_dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clause as sep_infix_dmatch_clause1) = 
sep_infix_dmatch_clause1 ()
 val  (sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (sep_infix_dmatch_clause::sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 111, ( result, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 515, ( ( _, ( MlyValue.infix_match_clause infix_match_clause1, 
infix_match_clause1left, infix_match_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_match_clauses (fn _ => let val  (
infix_match_clause as infix_match_clause1) = infix_match_clause1 ()
 in ([infix_match_clause])
end)
 in ( LrTable.NT 112, ( result, infix_match_clause1left, 
infix_match_clause1right), rest671)
end
|  ( 516, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, sep_infix_match_clauses1left, 
sep_infix_match_clauses1right)) :: rest671)) => let val  result = 
MlyValue.infix_match_clauses (fn _ => let val  (
sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (sep_infix_match_clauses)
end)
 in ( LrTable.NT 112, ( result, sep_infix_match_clauses1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 517, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, _, sep_infix_match_clauses1right)) :: ( _, (
 MlyValue.infix_match_clause infix_match_clause1, 
infix_match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_match_clauses (fn _ => let val  (infix_match_clause as 
infix_match_clause1) = infix_match_clause1 ()
 val  (sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (infix_match_clause::sep_infix_match_clauses)
end)
 in ( LrTable.NT 112, ( result, infix_match_clause1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 518, ( ( _, ( MlyValue.infix_dmatch_clause infix_dmatch_clause1, 
infix_dmatch_clause1left, infix_dmatch_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_dmatch_clauses (fn _ => let val  (
infix_dmatch_clause as infix_dmatch_clause1) = infix_dmatch_clause1 ()
 in ([infix_dmatch_clause])
end)
 in ( LrTable.NT 114, ( result, infix_dmatch_clause1left, 
infix_dmatch_clause1right), rest671)
end
|  ( 519, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, sep_infix_dmatch_clauses1left, 
sep_infix_dmatch_clauses1right)) :: rest671)) => let val  result = 
MlyValue.infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 114, ( result, sep_infix_dmatch_clauses1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 520, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, _, sep_infix_dmatch_clauses1right)) :: ( _,
 ( MlyValue.infix_dmatch_clause infix_dmatch_clause1, 
infix_dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_dmatch_clauses (fn _ => let val  (infix_dmatch_clause
 as infix_dmatch_clause1) = infix_dmatch_clause1 ()
 val  (sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (infix_dmatch_clause::sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 114, ( result, infix_dmatch_clause1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 521, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result =
 MlyValue.binding (fn _ => let val  (pattern as pattern1) = pattern1
 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val _ = A.checkNoDotsPat(pattern)
                                       in
                                          {bpat=pattern,def=phrase,pos=getPos LPARENleft}
                                       end
)
end)
 in ( LrTable.NT 115, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 522, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( _, ASGNleft, _)) :: ( _, ( MlyValue.pattern pattern1, pattern1left,
 _)) :: rest671)) => let val  result = MlyValue.binding_assignment (fn
 _ => let val  (pattern as pattern1) = pattern1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val _ = A.checkNoDotsPat(pattern)
                                         in
                                            {bpat=pattern,def=phrase,pos=getPos ASGNleft}
                                         end
)
end)
 in ( LrTable.NT 116, ( result, pattern1left, phrase1right), rest671)

end
|  ( 523, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: 
( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671)) => let
 val  result = MlyValue.assignment (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
{bpat=A.makePosLessIdPat(S.symbol ID),def=phrase,pos=getPos IDleft})

end)
 in ( LrTable.NT 122, ( result, ID1left, phrase1right), rest671)
end
|  ( 524, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: 
( _, ( _, (ANY_PATleft as ANY_PAT1left), _)) :: rest671)) => let val  
result = MlyValue.assignment (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 in (
{bpat=A.anyPat({pos=getPos ANY_PATleft}),def=phrase,pos=getPos ANY_PATleft}
)
end)
 in ( LrTable.NT 122, ( result, ANY_PAT1left, phrase1right), rest671)

end
|  ( 525, ( ( _, ( MlyValue.assignment assignment1, assignment1left, 
assignment1right)) :: rest671)) => let val  result = 
MlyValue.assignments (fn _ => let val  (assignment as assignment1) = 
assignment1 ()
 in ([assignment])
end)
 in ( LrTable.NT 123, ( result, assignment1left, assignment1right), 
rest671)
end
|  ( 526, ( ( _, ( MlyValue.assignments assignments1, _, 
assignments1right)) :: _ :: ( _, ( MlyValue.assignment assignment1, 
assignment1left, _)) :: rest671)) => let val  result = 
MlyValue.assignments (fn _ => let val  (assignment as assignment1) = 
assignment1 ()
 val  (assignments as assignments1) = assignments1 ()
 in (assignment::assignments)
end)
 in ( LrTable.NT 123, ( result, assignment1left, assignments1right), 
rest671)
end
|  ( 527, ( rest671)) => let val  result = MlyValue.bindings (fn _ =>
 ([]))
 in ( LrTable.NT 117, ( result, defaultPos, defaultPos), rest671)
end
|  ( 528, ( ( _, ( MlyValue.bindings bindings1, _, bindings1right)) ::
 ( _, ( MlyValue.binding binding1, binding1left, _)) :: rest671)) =>
 let val  result = MlyValue.bindings (fn _ => let val  (binding as 
binding1) = binding1 ()
 val  (bindings as bindings1) = bindings1 ()
 in (binding::bindings)
end)
 in ( LrTable.NT 117, ( result, binding1left, bindings1right), rest671
)
end
|  ( 529, ( ( _, ( MlyValue.binding_assignment binding_assignment1, 
binding_assignment1left, binding_assignment1right)) :: rest671)) =>
 let val  result = MlyValue.semicolon_separated_bindings (fn _ => let
 val  (binding_assignment as binding_assignment1) = 
binding_assignment1 ()
 in ([binding_assignment])
end)
 in ( LrTable.NT 118, ( result, binding_assignment1left, 
binding_assignment1right), rest671)
end
|  ( 530, ( ( _, ( MlyValue.semicolon_separated_bindings 
semicolon_separated_bindings1, _, semicolon_separated_bindings1right))
 :: _ :: ( _, ( MlyValue.binding_assignment binding_assignment1, 
binding_assignment1left, _)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_bindings (fn _ => let val  (
binding_assignment as binding_assignment1) = binding_assignment1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 in (binding_assignment::semicolon_separated_bindings)
end)
 in ( LrTable.NT 118, ( result, binding_assignment1left, 
semicolon_separated_bindings1right), rest671)
end
|  ( 531, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_phrases (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 119, ( result, phrase1left, phrase1right), rest671)

end
|  ( 532, ( ( _, ( MlyValue.semicolon_separated_phrases 
semicolon_separated_phrases1, _, semicolon_separated_phrases1right))
 :: _ :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671))
 => let val  result = MlyValue.semicolon_separated_phrases (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 val  (semicolon_separated_phrases as semicolon_separated_phrases1) = 
semicolon_separated_phrases1 ()
 in (phrase::semicolon_separated_phrases)
end)
 in ( LrTable.NT 119, ( result, phrase1left, 
semicolon_separated_phrases1right), rest671)
end
|  ( 533, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_deductions (fn _ => let val  (deduction
 as deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 120, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 534, ( ( _, ( MlyValue.semicolon_separated_deductions 
semicolon_separated_deductions1, _, 
semicolon_separated_deductions1right)) :: _ :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.semicolon_separated_deductions (fn _ => let
 val  (deduction as deduction1) = deduction1 ()
 val  (semicolon_separated_deductions as 
semicolon_separated_deductions1) = semicolon_separated_deductions1 ()
 in (deduction::semicolon_separated_deductions)
end)
 in ( LrTable.NT 120, ( result, deduction1left, 
semicolon_separated_deductions1right), rest671)
end
|  ( 535, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_expressions (fn _ => let val  (expression
 as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 121, ( result, expression1left, expression1right), 
rest671)
end
|  ( 536, ( ( _, ( MlyValue.semicolon_separated_expressions 
semicolon_separated_expressions1, _, 
semicolon_separated_expressions1right)) :: _ :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.semicolon_separated_expressions (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  (semicolon_separated_expressions as 
semicolon_separated_expressions1) = semicolon_separated_expressions1
 ()
 in (expression::semicolon_separated_expressions)
end)
 in ( LrTable.NT 121, ( result, expression1left, 
semicolon_separated_expressions1right), rest671)
end
|  ( 537, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,condition=A.desugarUB(expression)}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 538, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _,
 DEFINE_SYMBOL1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,condition=A.desugarUB(expression)}
)
end)
 in ( LrTable.NT 124, ( result, DEFINE_SYMBOL1left, expression1right),
 rest671)
end
|  ( 539, ( ( _, ( _, _, RPAREN2right)) :: _ :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( MlyValue.athena_var 
athena_var1, _, _)) :: _ :: _ :: ( _, ( MlyValue.ID ID1, IDleft, _))
 :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (athena_var as athena_var1) = athena_var1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val id_pos = getPos IDleft
                      in
                      {name=S.symbol(ID),pos=id_pos,abbreviated=false,
                       condition=A.desugarUB(A.makeConstantSymCondition({constant_name=A.makeMS(ID,SOME id_pos),
                                                             the_var=athena_var,
                                                             def_description=expression}))}
                      end
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 540, ( ( _, ( _, _, RPAREN3right)) :: _ :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( MlyValue.athena_var 
athena_var1, _, _)) :: _ :: _ :: _ :: ( _, ( 
MlyValue.one_or_more_athena_vars one_or_more_athena_vars1, _, _)) :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.symbol_definition (fn
 _ => let val  (ID as ID1) = ID1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 val  (athena_var as athena_var1) = athena_var1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,
                       condition=A.desugarUB(A.makeFunSymCondition({fun_name=S.symbol(ID),
                                                        arg_vars=one_or_more_athena_vars,
                                                        the_var=athena_var,def_description=expression}))}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN3right), rest671)

end
|  ( 541, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_athena_vars 
one_or_more_athena_vars1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)
) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = 
ID1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=true,
                       condition=A.desugarUB(A.makeFunOrRelSymCondition({fun_or_rel_name=S.symbol(ID),
                                                             arg_vars=one_or_more_athena_vars,
                                                             term_or_condition=expression}))}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN2right), rest671)

end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.input_stream x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Athena_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_ANY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_WITNESS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_WITNESSES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun CHECK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun DCHECK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun LOGICAL_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.VOID,p1,p2))
fun LOGICAL_OR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun EXPAND_INPUT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun PRIVATE_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.PRIVATE_ID (fn () => i),p1,p2))
fun PRIVATE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN_MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun EXTEND_MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun ANY_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.ANY_ID (fn () => i),p1,p2))
fun RE_STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_PLUS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_OPTIONAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_LIT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_REP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_RANGE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun SOME_FUNCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun EXIT_ATHENA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun FROM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun FOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun START_LOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun END_LOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun TRANSFORM_OUTPUT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun CHARACTER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.CHARACTER (fn () => i),p1,p2))
fun LOAD_FILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun DIF_ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun NAME (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_TERM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD_INV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_MEMOIZED (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_ATOM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_PROP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun QMARK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCL_MARK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun QUOTE_WORD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun QUOTE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun EXPAND_NEXT_PROOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_CURLY_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_CURLY_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun BACK_QUOTE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun LETREC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun DLETREC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun SPLIT_PAT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun BY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun PRINT_STACK_TRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMI_COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun CONCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun DOUBLE_LEFT_CURLY_BRACE (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 61,(ParserData.MlyValue.VOID,p1,p2))
fun DOUBLE_RIGHT_CURLY_BRACE (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 62,(ParserData.MlyValue.VOID,p1,p2))
fun LPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun CLAIM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun SET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun WILDCARD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_CHAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun MATCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun LET_UPPER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.VOID,p1,p2))
fun DLET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 78,(
ParserData.MlyValue.VOID,p1,p2))
fun TRY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 79,(
ParserData.MlyValue.VOID,p1,p2))
fun DTRY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 80,(
ParserData.MlyValue.VOID,p1,p2))
fun APPLY_METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 81,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_VAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 82,(
ParserData.MlyValue.VOID,p1,p2))
fun SEQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 83,(
ParserData.MlyValue.VOID,p1,p2))
fun DSEQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 84,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_VECTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 85,(
ParserData.MlyValue.VOID,p1,p2))
fun MAP_BEGIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 86,(
ParserData.MlyValue.VOID,p1,p2))
fun MAP_END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 87,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUAL_SIGN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 88,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSERT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 89,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSERT_CLOSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 90,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSUME (p1,p2) = Token.TOKEN (ParserData.LrTable.T 91,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSUME_LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 92,(
ParserData.MlyValue.VOID,p1,p2))
fun SUPPOSE_ABSURD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 93,(
ParserData.MlyValue.VOID,p1,p2))
fun SUPPOSE_ABSURD_LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 94
,(ParserData.MlyValue.VOID,p1,p2))
fun ON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 95,(
ParserData.MlyValue.VOID,p1,p2))
fun PROVE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 96,(
ParserData.MlyValue.VOID,p1,p2))
fun DMATCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 97,(
ParserData.MlyValue.VOID,p1,p2))
fun EITHER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 98,(
ParserData.MlyValue.VOID,p1,p2))
fun ABSURD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 99,(
ParserData.MlyValue.VOID,p1,p2))
fun MP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 100,(
ParserData.MlyValue.VOID,p1,p2))
fun DN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 101,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUIV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 102,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_IFF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 103,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_IFF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 104,(
ParserData.MlyValue.VOID,p1,p2))
fun BOTH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 105,(
ParserData.MlyValue.VOID,p1,p2))
fun ASGN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 106,(
ParserData.MlyValue.VOID,p1,p2))
fun BY_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 107,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 108,(
ParserData.MlyValue.VOID,p1,p2))
fun META_ID (p1,p2) = Token.TOKEN (ParserData.LrTable.T 109,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 110,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 111,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 112,(
ParserData.MlyValue.VOID,p1,p2))
fun CD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 113,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL_OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 114,(
ParserData.MlyValue.VOID,p1,p2))
fun VAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 115,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN_ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 116,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 117,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 118,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_SORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 119,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_LIST (p1,p2) = Token.TOKEN (ParserData.LrTable.T 120,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 121,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_SUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 122,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_TABLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 123,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_MAP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 124,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 125,(
ParserData.MlyValue.VOID,p1,p2))
fun POUND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 126,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 127,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 128,(
ParserData.MlyValue.VOID,p1,p2))
fun DOMAIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 129,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 130,(
ParserData.MlyValue.VOID,p1,p2))
fun PROVIDED (p1,p2) = Token.TOKEN (ParserData.LrTable.T 131,(
ParserData.MlyValue.VOID,p1,p2))
fun DECLARE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 132,(
ParserData.MlyValue.VOID,p1,p2))
fun DDECLARE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 133,(
ParserData.MlyValue.VOID,p1,p2))
fun DIRECTIVE_PREFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 134,(
ParserData.MlyValue.VOID,p1,p2))
fun EGEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 135,(
ParserData.MlyValue.VOID,p1,p2))
fun BEGIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 136,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 137,(
ParserData.MlyValue.VOID,p1,p2))
fun CLEAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 138,(
ParserData.MlyValue.VOID,p1,p2))
fun THE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 139,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 140,(
ParserData.MlyValue.VOID,p1,p2))
fun DOMAINS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 141,(
ParserData.MlyValue.VOID,p1,p2))
fun OVER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 142,(
ParserData.MlyValue.VOID,p1,p2))
fun EGEN_UNIQUE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 143,(
ParserData.MlyValue.VOID,p1,p2))
fun LEIBNIZ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 144,(
ParserData.MlyValue.VOID,p1,p2))
fun EQ_REFLEX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 145,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_QUANT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 146,(
ParserData.MlyValue.VOID,p1,p2))
fun USPEC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 147,(
ParserData.MlyValue.VOID,p1,p2))
fun FETCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 148,(
ParserData.MlyValue.VOID,p1,p2))
fun RETRACT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 149,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 150,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_DEMON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 151,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_DEMONS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 152,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_PROP_CON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 153,(
ParserData.MlyValue.VOID,p1,p2))
fun UNEQUAL_TERMS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 154,(
ParserData.MlyValue.VOID,p1,p2))
fun INDUCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 155,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 156,(
ParserData.MlyValue.VOID,p1,p2))
fun LIST (p1,p2) = Token.TOKEN (ParserData.LrTable.T 157,(
ParserData.MlyValue.VOID,p1,p2))
fun CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 158,(
ParserData.MlyValue.VOID,p1,p2))
fun RULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 159,(
ParserData.MlyValue.VOID,p1,p2))
fun GEN_OVER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 160,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_PREDICATE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 161,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_KEYS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 162,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_WITNESS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 163,(
ParserData.MlyValue.VOID,p1,p2))
fun MAKE_CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 164,(
ParserData.MlyValue.VOID,p1,p2))
fun REF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 165,(
ParserData.MlyValue.VOID,p1,p2))
fun USE_TERM_PARSER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 166,(
ParserData.MlyValue.VOID,p1,p2))
fun USE_PROP_PARSER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 167,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 168,(
ParserData.MlyValue.VOID,p1,p2))
fun SPECIALIZE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 169,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_FLAG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 170,(
ParserData.MlyValue.VOID,p1,p2))
fun EX_GENERALIZE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 171,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 172,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE_CASES_ON_TERM (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 173,(ParserData.MlyValue.VOID,p1,p2))
fun SUBSORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 174,(
ParserData.MlyValue.VOID,p1,p2))
fun SUBSORTS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 175,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_INIT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 176,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_SUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 177,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_SET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 178,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_CNF_CONVERTER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 179
,(ParserData.MlyValue.VOID,p1,p2))
fun GET_CNF_CONVERTER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 180
,(ParserData.MlyValue.VOID,p1,p2))
fun ANY_PAT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 181,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_PRECEDENCE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 182,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_ASSOC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 183,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_ASSOC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 184,(
ParserData.MlyValue.VOID,p1,p2))
fun BIN_OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 185,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_PATH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 186,(
ParserData.MlyValue.VOID,p1,p2))
end
end
