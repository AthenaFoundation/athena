functor AthenaLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : Athena_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
(*==================================================

Athena's Yacc grammar.

===================================================*)

structure A = AbstractSyntax
structure N = Names
structure S = Symbol
structure MS = ModSymbol

type pos = int * int

fun getPos((l,p)) = {line=l,pos=p,file=(!Paths.current_file)}


end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\001\000\076\006\002\000\076\006\003\000\076\006\004\000\076\006\
\\005\000\076\006\006\000\076\006\012\000\076\006\013\000\076\006\
\\014\000\076\006\015\000\076\006\016\000\076\006\024\000\076\006\
\\025\000\076\006\028\000\076\006\033\000\076\006\034\000\076\006\
\\035\000\076\006\039\000\050\001\040\000\076\006\041\000\076\006\
\\042\000\076\006\043\000\076\006\044\000\076\006\047\000\076\006\
\\050\000\076\006\051\000\076\006\052\000\076\006\053\000\076\006\
\\055\000\076\006\056\000\076\006\059\000\076\006\060\000\076\006\
\\061\000\076\006\062\000\076\006\064\000\076\006\065\000\076\006\
\\066\000\076\006\068\000\076\006\070\000\076\006\071\000\076\006\
\\075\000\076\006\076\000\076\006\077\000\076\006\078\000\076\006\
\\080\000\076\006\081\000\076\006\088\000\076\006\091\000\076\006\
\\092\000\076\006\093\000\076\006\095\000\076\006\099\000\076\006\
\\108\000\102\007\109\000\076\006\119\000\076\006\120\000\076\006\
\\121\000\076\006\127\000\076\006\129\000\076\006\131\000\076\006\
\\134\000\076\006\138\000\076\006\139\000\076\006\140\000\076\006\
\\142\000\076\006\143\000\076\006\151\000\076\006\153\000\076\006\
\\157\000\076\006\158\000\076\006\161\000\076\006\162\000\076\006\
\\164\000\076\006\166\000\076\006\167\000\076\006\172\000\076\006\
\\175\000\076\006\177\000\076\006\178\000\076\006\179\000\076\006\
\\180\000\076\006\181\000\076\006\184\000\076\006\185\000\076\006\
\\186\000\076\006\187\000\076\006\189\000\076\006\000\000\
\\001\000\002\000\076\006\003\000\076\006\004\000\076\006\005\000\076\006\
\\006\000\076\006\039\000\050\001\052\000\076\006\055\000\076\006\
\\056\000\076\006\058\000\076\006\061\000\076\006\064\000\076\006\
\\077\000\076\006\078\000\076\006\080\000\076\006\081\000\076\006\
\\093\000\076\006\095\000\076\006\099\000\076\006\108\000\103\007\
\\109\000\076\006\138\000\076\006\157\000\076\006\158\000\076\006\
\\162\000\076\006\175\000\076\006\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\007\000\059\002\013\000\102\000\024\000\098\000\
\\025\000\097\000\034\000\094\000\047\000\087\000\050\000\086\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\061\000\080\000\
\\062\000\079\000\064\000\116\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\073\000\078\000\072\000\
\\080\000\071\000\081\000\070\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\138\000\055\000\
\\139\000\054\000\157\000\048\000\158\000\047\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\012\000\103\000\013\000\102\000\014\000\101\000\
\\015\000\100\000\016\000\099\000\024\000\098\000\025\000\097\000\
\\028\000\096\000\033\000\095\000\034\000\094\000\035\000\093\000\
\\040\000\092\000\041\000\091\000\042\000\090\000\043\000\089\000\
\\044\000\088\000\047\000\087\000\050\000\086\000\051\000\085\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\059\000\081\000\
\\061\000\080\000\062\000\079\000\064\000\078\000\068\000\077\000\
\\070\000\076\000\075\000\075\000\076\000\074\000\077\000\073\000\
\\078\000\072\000\080\000\071\000\081\000\070\000\088\000\069\000\
\\091\000\068\000\092\000\067\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\119\000\062\000\120\000\061\000\
\\121\000\060\000\127\000\059\000\129\000\058\000\131\000\057\000\
\\134\000\056\000\138\000\055\000\139\000\054\000\140\000\053\000\
\\142\000\052\000\143\000\051\000\151\000\050\000\153\000\049\000\
\\157\000\048\000\158\000\047\000\161\000\046\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\172\000\041\000\
\\175\000\040\000\177\000\039\000\178\000\038\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\185\000\033\000\
\\186\000\032\000\187\000\031\000\189\000\030\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\030\000\066\002\034\000\094\000\047\000\087\000\050\000\086\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\061\000\080\000\
\\062\000\079\000\064\000\116\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\073\000\078\000\072\000\
\\080\000\071\000\081\000\070\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\138\000\055\000\
\\139\000\054\000\157\000\048\000\158\000\047\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\065\000\072\004\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\073\000\078\000\072\000\
\\080\000\071\000\081\000\070\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\138\000\055\000\
\\139\000\054\000\157\000\048\000\158\000\047\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\108\000\017\005\109\000\063\000\138\000\055\000\
\\139\000\054\000\157\000\048\000\158\000\047\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\047\001\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\117\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\173\000\115\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\118\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\117\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\173\000\115\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\114\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\175\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\180\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\179\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\232\001\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\179\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\148\003\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\024\001\
\\006\000\104\000\009\000\022\001\010\000\021\001\011\000\020\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\007\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\116\000\
\\065\000\003\001\068\000\077\000\070\000\002\001\075\000\001\001\
\\076\000\000\001\077\000\255\000\078\000\254\000\080\000\071\000\
\\081\000\252\000\085\000\249\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\111\000\240\000\
\\117\000\239\000\138\000\055\000\139\000\230\000\141\000\006\004\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\219\000\
\\166\000\217\000\167\000\216\000\175\000\040\000\179\000\209\000\
\\180\000\208\000\181\000\207\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\024\001\
\\006\000\104\000\009\000\022\001\010\000\021\001\011\000\020\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\007\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\116\000\
\\065\000\003\001\068\000\077\000\070\000\002\001\075\000\001\001\
\\076\000\000\001\077\000\255\000\078\000\254\000\080\000\071\000\
\\081\000\252\000\085\000\249\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\111\000\240\000\
\\117\000\239\000\138\000\055\000\139\000\230\000\141\000\053\005\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\219\000\
\\166\000\217\000\167\000\216\000\175\000\040\000\179\000\209\000\
\\180\000\208\000\181\000\207\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\024\001\
\\006\000\104\000\009\000\022\001\010\000\021\001\011\000\020\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\050\000\086\000\052\000\084\000\055\000\007\001\
\\056\000\082\000\061\000\080\000\062\000\079\000\064\000\116\000\
\\065\000\003\001\068\000\077\000\070\000\002\001\075\000\001\001\
\\076\000\000\001\077\000\255\000\078\000\254\000\080\000\071\000\
\\081\000\252\000\085\000\249\000\088\000\069\000\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\111\000\240\000\
\\117\000\239\000\138\000\055\000\139\000\230\000\157\000\048\000\
\\158\000\047\000\162\000\045\000\164\000\219\000\166\000\217\000\
\\167\000\216\000\175\000\040\000\179\000\209\000\180\000\208\000\
\\181\000\207\000\184\000\034\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\107\001\
\\006\000\104\000\052\000\084\000\055\000\106\001\056\000\082\000\
\\058\000\078\002\061\000\080\000\064\000\105\001\077\000\104\001\
\\078\000\103\001\080\000\071\000\081\000\102\001\093\000\066\000\
\\095\000\065\000\099\000\064\000\109\000\063\000\138\000\055\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\175\000\040\000\000\000\
\\001\000\002\000\108\000\003\000\107\000\004\000\106\000\005\000\107\001\
\\006\000\104\000\052\000\084\000\055\000\106\001\056\000\082\000\
\\061\000\080\000\064\000\105\001\077\000\104\001\078\000\103\001\
\\080\000\071\000\081\000\102\001\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\157\000\048\000\
\\158\000\047\000\162\000\045\000\175\000\040\000\000\000\
\\001\000\002\000\027\001\003\000\026\001\004\000\025\001\005\000\024\001\
\\006\000\023\001\009\000\022\001\010\000\021\001\011\000\020\001\
\\012\000\019\001\013\000\102\000\014\000\018\001\015\000\017\001\
\\016\000\016\001\024\000\098\000\025\000\097\000\028\000\015\001\
\\033\000\014\001\034\000\094\000\035\000\013\001\040\000\012\001\
\\041\000\011\001\042\000\010\001\047\000\087\000\048\000\009\001\
\\050\000\086\000\051\000\008\001\052\000\084\000\055\000\007\001\
\\056\000\006\001\059\000\005\001\061\000\004\001\062\000\079\000\
\\064\000\116\000\065\000\003\001\068\000\077\000\070\000\002\001\
\\075\000\001\001\076\000\000\001\077\000\255\000\078\000\254\000\
\\080\000\253\000\081\000\252\000\082\000\251\000\083\000\250\000\
\\085\000\249\000\086\000\248\000\088\000\069\000\091\000\247\000\
\\092\000\246\000\093\000\245\000\094\000\244\000\095\000\243\000\
\\096\000\242\000\099\000\241\000\109\000\063\000\111\000\240\000\
\\117\000\239\000\119\000\238\000\120\000\237\000\121\000\236\000\
\\127\000\235\000\129\000\234\000\130\000\233\000\131\000\232\000\
\\134\000\231\000\138\000\055\000\139\000\230\000\140\000\229\000\
\\142\000\228\000\143\000\227\000\151\000\226\000\153\000\225\000\
\\154\000\224\000\157\000\223\000\158\000\222\000\161\000\221\000\
\\162\000\220\000\164\000\219\000\165\000\218\000\166\000\217\000\
\\167\000\216\000\168\000\215\000\169\000\214\000\172\000\213\000\
\\175\000\212\000\177\000\211\000\178\000\210\000\179\000\209\000\
\\180\000\208\000\181\000\207\000\184\000\034\000\185\000\206\000\
\\186\000\205\000\187\000\204\000\189\000\203\000\000\000\
\\001\000\002\000\027\001\003\000\026\001\004\000\025\001\005\000\024\001\
\\006\000\023\001\009\000\022\001\010\000\021\001\011\000\020\001\
\\013\000\102\000\024\000\098\000\025\000\097\000\034\000\094\000\
\\047\000\087\000\048\000\009\001\050\000\086\000\052\000\084\000\
\\055\000\007\001\056\000\006\001\061\000\004\001\062\000\079\000\
\\064\000\116\000\065\000\003\001\068\000\077\000\070\000\002\001\
\\075\000\001\001\076\000\000\001\077\000\255\000\078\000\254\000\
\\080\000\253\000\081\000\252\000\082\000\251\000\083\000\250\000\
\\085\000\249\000\086\000\248\000\088\000\069\000\093\000\245\000\
\\094\000\244\000\095\000\243\000\096\000\242\000\099\000\241\000\
\\109\000\063\000\111\000\240\000\117\000\239\000\138\000\055\000\
\\139\000\230\000\157\000\223\000\158\000\222\000\162\000\220\000\
\\164\000\219\000\165\000\218\000\166\000\217\000\167\000\216\000\
\\175\000\212\000\179\000\209\000\180\000\208\000\181\000\207\000\
\\184\000\034\000\000\000\
\\001\000\002\000\118\002\003\000\117\002\004\000\116\002\005\000\127\000\
\\006\000\115\002\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\048\000\009\001\050\000\086\000\
\\055\000\126\000\056\000\114\002\061\000\113\002\062\000\079\000\
\\064\000\125\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\124\000\078\000\123\000\080\000\112\002\
\\081\000\122\000\082\000\251\000\083\000\250\000\086\000\248\000\
\\088\000\069\000\093\000\111\002\094\000\244\000\095\000\110\002\
\\096\000\242\000\099\000\109\002\139\000\054\000\157\000\108\002\
\\158\000\107\002\162\000\106\002\164\000\044\000\165\000\218\000\
\\166\000\043\000\167\000\042\000\175\000\105\002\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\126\000\062\000\079\000\064\000\125\000\068\000\077\000\
\\070\000\076\000\075\000\075\000\076\000\074\000\077\000\124\000\
\\078\000\123\000\081\000\122\000\088\000\069\000\138\000\191\000\
\\139\000\054\000\164\000\044\000\166\000\043\000\167\000\042\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\125\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\108\000\128\005\139\000\054\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\125\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\003\003\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\007\005\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\184\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\125\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\001\000\005\000\127\000\013\000\102\000\024\000\032\001\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\125\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\001\000\010\000\175\002\018\000\174\002\019\000\173\002\020\000\172\002\
\\021\000\171\002\022\000\170\002\023\000\169\002\024\000\168\002\
\\025\000\132\001\026\000\167\002\027\000\166\002\034\000\131\001\
\\037\000\165\002\038\000\164\002\045\000\163\002\046\000\162\002\
\\047\000\130\001\048\000\129\001\050\000\128\001\057\000\161\002\
\\064\000\127\001\065\000\160\002\068\000\126\001\073\000\159\002\
\\084\000\158\002\087\000\157\002\111\000\156\002\112\000\155\002\
\\116\000\154\002\117\000\153\002\122\000\152\002\123\000\151\002\
\\124\000\150\002\125\000\149\002\126\000\148\002\148\000\147\002\
\\155\000\146\002\159\000\145\002\160\000\144\002\184\000\125\001\000\000\
\\001\000\011\000\123\003\024\000\099\003\110\000\098\003\000\000\
\\001\000\011\000\088\004\024\000\099\003\110\000\098\003\000\000\
\\001\000\011\000\214\004\000\000\
\\001\000\011\000\018\005\000\000\
\\001\000\013\000\102\000\024\000\131\000\000\000\
\\001\000\013\000\102\000\024\000\131\000\064\000\134\000\000\000\
\\001\000\013\000\102\000\024\000\131\000\064\000\181\001\000\000\
\\001\000\013\000\102\000\024\000\131\000\065\000\070\003\000\000\
\\001\000\024\000\208\005\025\000\208\005\034\000\208\005\039\000\069\002\
\\047\000\208\005\048\000\208\005\050\000\208\005\064\000\208\005\
\\068\000\208\005\071\000\110\007\184\000\208\005\000\000\
\\001\000\024\000\089\007\039\000\102\007\064\000\089\007\065\000\089\007\000\000\
\\001\000\024\000\140\000\000\000\
\\001\000\024\000\140\000\064\000\194\001\000\000\
\\001\000\024\000\140\000\064\000\208\001\000\000\
\\001\000\024\000\155\000\000\000\
\\001\000\024\000\160\000\064\000\159\000\000\000\
\\001\000\024\000\164\000\064\000\163\000\000\000\
\\001\000\024\000\167\000\064\000\166\000\068\000\165\000\000\000\
\\001\000\024\000\168\000\000\000\
\\001\000\024\000\036\001\025\000\035\001\000\000\
\\001\000\024\000\037\001\000\000\
\\001\000\024\000\063\001\000\000\
\\001\000\024\000\063\001\064\000\023\002\000\000\
\\001\000\024\000\064\001\000\000\
\\001\000\024\000\068\001\000\000\
\\001\000\024\000\068\001\025\000\132\001\034\000\131\001\047\000\130\001\
\\048\000\129\001\050\000\128\001\064\000\127\001\068\000\126\001\
\\132\000\172\003\184\000\125\001\000\000\
\\001\000\024\000\068\001\025\000\132\001\034\000\131\001\047\000\130\001\
\\048\000\129\001\050\000\128\001\064\000\127\001\068\000\126\001\
\\184\000\125\001\000\000\
\\001\000\024\000\068\001\184\000\124\002\000\000\
\\001\000\024\000\108\001\000\000\
\\001\000\024\000\118\001\000\000\
\\001\000\024\000\120\001\000\000\
\\001\000\024\000\133\001\000\000\
\\001\000\024\000\204\001\064\000\203\001\000\000\
\\001\000\024\000\210\001\064\000\209\001\000\000\
\\001\000\024\000\220\001\064\000\219\001\068\000\218\001\000\000\
\\001\000\024\000\221\001\000\000\
\\001\000\024\000\224\001\000\000\
\\001\000\024\000\225\001\000\000\
\\001\000\024\000\024\002\000\000\
\\001\000\024\000\033\002\000\000\
\\001\000\024\000\035\002\000\000\
\\001\000\024\000\046\002\050\000\045\002\064\000\044\002\000\000\
\\001\000\024\000\046\002\050\000\045\002\064\000\081\002\000\000\
\\001\000\024\000\046\002\050\000\045\002\064\000\118\003\000\000\
\\001\000\024\000\051\002\064\000\050\002\068\000\049\002\000\000\
\\001\000\024\000\096\002\025\000\132\001\034\000\131\001\047\000\130\001\
\\048\000\129\001\050\000\128\001\064\000\127\001\068\000\126\001\
\\184\000\125\001\000\000\
\\001\000\024\000\133\002\064\000\006\003\000\000\
\\001\000\024\000\133\002\064\000\112\004\000\000\
\\001\000\024\000\133\002\064\000\185\004\000\000\
\\001\000\024\000\138\002\064\000\137\002\000\000\
\\001\000\024\000\176\002\000\000\
\\001\000\024\000\178\002\000\000\
\\001\000\024\000\194\002\184\000\193\002\000\000\
\\001\000\024\000\250\002\000\000\
\\001\000\024\000\001\003\000\000\
\\001\000\024\000\008\003\000\000\
\\001\000\024\000\021\003\000\000\
\\001\000\024\000\073\003\064\000\072\003\068\000\071\003\000\000\
\\001\000\024\000\099\003\110\000\098\003\000\000\
\\001\000\024\000\100\003\000\000\
\\001\000\024\000\104\003\000\000\
\\001\000\024\000\151\003\000\000\
\\001\000\024\000\163\003\110\000\162\003\000\000\
\\001\000\024\000\166\003\000\000\
\\001\000\024\000\182\003\000\000\
\\001\000\024\000\183\003\000\000\
\\001\000\024\000\185\003\000\000\
\\001\000\024\000\194\003\000\000\
\\001\000\024\000\011\004\110\000\162\003\000\000\
\\001\000\024\000\014\004\000\000\
\\001\000\024\000\017\004\000\000\
\\001\000\024\000\054\004\000\000\
\\001\000\024\000\093\004\000\000\
\\001\000\024\000\153\004\000\000\
\\001\000\024\000\180\004\000\000\
\\001\000\024\000\222\004\000\000\
\\001\000\024\000\225\004\065\000\224\004\000\000\
\\001\000\024\000\037\005\000\000\
\\001\000\024\000\041\005\065\000\040\005\000\000\
\\001\000\024\000\058\005\000\000\
\\001\000\024\000\064\005\065\000\063\005\000\000\
\\001\000\024\000\077\005\065\000\076\005\000\000\
\\001\000\024\000\103\005\068\000\102\005\186\000\101\005\187\000\100\005\000\000\
\\001\000\024\000\116\005\068\000\102\005\069\000\115\005\000\000\
\\001\000\024\000\122\005\068\000\102\005\069\000\121\005\186\000\101\005\
\\187\000\100\005\000\000\
\\001\000\024\000\136\005\068\000\102\005\069\000\135\005\000\000\
\\001\000\024\000\140\005\068\000\102\005\069\000\139\005\000\000\
\\001\000\024\000\145\005\068\000\102\005\069\000\144\005\186\000\101\005\
\\187\000\100\005\000\000\
\\001\000\024\000\149\005\068\000\102\005\186\000\101\005\187\000\100\005\000\000\
\\001\000\024\000\167\005\065\000\166\005\068\000\102\005\000\000\
\\001\000\024\000\172\005\065\000\171\005\068\000\102\005\186\000\101\005\
\\187\000\100\005\000\000\
\\001\000\024\000\181\005\065\000\180\005\068\000\102\005\000\000\
\\001\000\024\000\184\005\065\000\183\005\068\000\102\005\000\000\
\\001\000\024\000\189\005\065\000\188\005\068\000\102\005\186\000\101\005\
\\187\000\100\005\000\000\
\\001\000\025\000\098\001\000\000\
\\001\000\025\000\241\002\000\000\
\\001\000\029\000\075\001\058\000\074\001\097\000\073\001\000\000\
\\001\000\029\000\099\001\000\000\
\\001\000\029\000\139\001\052\000\084\000\138\000\138\001\000\000\
\\001\000\030\000\064\002\000\000\
\\001\000\030\000\066\002\000\000\
\\001\000\037\000\078\004\000\000\
\\001\000\037\000\205\004\000\000\
\\001\000\039\000\117\001\000\000\
\\001\000\039\000\027\003\065\000\026\003\000\000\
\\001\000\039\000\238\004\000\000\
\\001\000\047\000\004\004\064\000\003\004\000\000\
\\001\000\052\000\084\000\000\000\
\\001\000\052\000\084\000\064\000\244\001\000\000\
\\001\000\052\000\084\000\064\000\245\001\000\000\
\\001\000\052\000\084\000\064\000\253\001\000\000\
\\001\000\052\000\084\000\064\000\254\001\000\000\
\\001\000\052\000\084\000\097\000\097\001\138\000\096\001\000\000\
\\001\000\052\000\084\000\138\000\191\000\000\000\
\\001\000\052\000\084\000\138\000\110\001\000\000\
\\001\000\052\000\084\000\138\000\112\001\000\000\
\\001\000\052\000\084\000\138\000\163\001\000\000\
\\001\000\052\000\084\000\138\000\071\002\000\000\
\\001\000\052\000\084\000\138\000\214\003\000\000\
\\001\000\053\000\070\001\000\000\
\\001\000\058\000\176\001\000\000\
\\001\000\063\000\026\002\000\000\
\\001\000\064\000\138\000\000\000\
\\001\000\064\000\148\000\000\000\
\\001\000\064\000\195\000\000\000\
\\001\000\064\000\196\000\000\000\
\\001\000\064\000\038\001\000\000\
\\001\000\064\000\041\001\000\000\
\\001\000\064\000\055\001\127\000\054\001\000\000\
\\001\000\064\000\185\001\000\000\
\\001\000\064\000\196\001\000\000\
\\001\000\064\000\213\001\000\000\
\\001\000\064\000\228\001\000\000\
\\001\000\064\000\244\001\000\000\
\\001\000\064\000\247\001\000\000\
\\001\000\064\000\248\001\000\000\
\\001\000\064\000\253\001\000\000\
\\001\000\064\000\013\002\000\000\
\\001\000\064\000\023\002\000\000\
\\001\000\064\000\019\003\000\000\
\\001\000\064\000\069\004\000\000\
\\001\000\064\000\190\004\000\000\
\\001\000\064\000\009\005\000\000\
\\001\000\064\000\075\005\000\000\
\\001\000\065\000\205\001\000\000\
\\001\000\065\000\252\001\000\000\
\\001\000\065\000\255\001\000\000\
\\001\000\065\000\008\002\000\000\
\\001\000\065\000\086\002\000\000\
\\001\000\065\000\088\002\000\000\
\\001\000\065\000\219\002\000\000\
\\001\000\065\000\221\002\000\000\
\\001\000\065\000\223\002\000\000\
\\001\000\065\000\227\002\000\000\
\\001\000\065\000\228\002\000\000\
\\001\000\065\000\229\002\000\000\
\\001\000\065\000\242\002\000\000\
\\001\000\065\000\243\002\000\000\
\\001\000\065\000\253\002\000\000\
\\001\000\065\000\254\002\000\000\
\\001\000\065\000\255\002\000\000\
\\001\000\065\000\000\003\000\000\
\\001\000\065\000\010\003\163\000\009\003\000\000\
\\001\000\065\000\011\003\000\000\
\\001\000\065\000\016\003\000\000\
\\001\000\065\000\017\003\000\000\
\\001\000\065\000\024\003\000\000\
\\001\000\065\000\025\003\000\000\
\\001\000\065\000\028\003\000\000\
\\001\000\065\000\036\003\000\000\
\\001\000\065\000\037\003\000\000\
\\001\000\065\000\038\003\000\000\
\\001\000\065\000\040\003\000\000\
\\001\000\065\000\043\003\000\000\
\\001\000\065\000\045\003\000\000\
\\001\000\065\000\046\003\000\000\
\\001\000\065\000\062\003\000\000\
\\001\000\065\000\064\003\000\000\
\\001\000\065\000\066\003\000\000\
\\001\000\065\000\069\003\000\000\
\\001\000\065\000\075\003\000\000\
\\001\000\065\000\076\003\000\000\
\\001\000\065\000\077\003\000\000\
\\001\000\065\000\078\003\000\000\
\\001\000\065\000\081\003\000\000\
\\001\000\065\000\154\003\000\000\
\\001\000\065\000\164\003\000\000\
\\001\000\065\000\167\003\000\000\
\\001\000\065\000\206\003\000\000\
\\001\000\065\000\235\003\000\000\
\\001\000\065\000\236\003\000\000\
\\001\000\065\000\237\003\000\000\
\\001\000\065\000\238\003\000\000\
\\001\000\065\000\239\003\000\000\
\\001\000\065\000\243\003\000\000\
\\001\000\065\000\244\003\000\000\
\\001\000\065\000\245\003\000\000\
\\001\000\065\000\249\003\000\000\
\\001\000\065\000\251\003\000\000\
\\001\000\065\000\253\003\000\000\
\\001\000\065\000\255\003\000\000\
\\001\000\065\000\000\004\000\000\
\\001\000\065\000\005\004\000\000\
\\001\000\065\000\008\004\000\000\
\\001\000\065\000\012\004\000\000\
\\001\000\065\000\015\004\000\000\
\\001\000\065\000\022\004\000\000\
\\001\000\065\000\023\004\000\000\
\\001\000\065\000\025\004\000\000\
\\001\000\065\000\026\004\000\000\
\\001\000\065\000\028\004\000\000\
\\001\000\065\000\029\004\000\000\
\\001\000\065\000\030\004\000\000\
\\001\000\065\000\033\004\000\000\
\\001\000\065\000\034\004\000\000\
\\001\000\065\000\036\004\000\000\
\\001\000\065\000\037\004\000\000\
\\001\000\065\000\040\004\000\000\
\\001\000\065\000\041\004\000\000\
\\001\000\065\000\043\004\000\000\
\\001\000\065\000\045\004\000\000\
\\001\000\065\000\046\004\000\000\
\\001\000\065\000\047\004\000\000\
\\001\000\065\000\048\004\000\000\
\\001\000\065\000\049\004\000\000\
\\001\000\065\000\050\004\000\000\
\\001\000\065\000\051\004\000\000\
\\001\000\065\000\052\004\000\000\
\\001\000\065\000\056\004\000\000\
\\001\000\065\000\059\004\000\000\
\\001\000\065\000\062\004\000\000\
\\001\000\065\000\067\004\000\000\
\\001\000\065\000\068\004\000\000\
\\001\000\065\000\072\004\000\000\
\\001\000\065\000\080\004\000\000\
\\001\000\065\000\113\004\000\000\
\\001\000\065\000\124\004\000\000\
\\001\000\065\000\127\004\000\000\
\\001\000\065\000\129\004\000\000\
\\001\000\065\000\130\004\000\000\
\\001\000\065\000\131\004\000\000\
\\001\000\065\000\132\004\000\000\
\\001\000\065\000\133\004\000\000\
\\001\000\065\000\134\004\000\000\
\\001\000\065\000\135\004\000\000\
\\001\000\065\000\136\004\000\000\
\\001\000\065\000\137\004\000\000\
\\001\000\065\000\138\004\000\000\
\\001\000\065\000\139\004\000\000\
\\001\000\065\000\140\004\000\000\
\\001\000\065\000\141\004\000\000\
\\001\000\065\000\142\004\000\000\
\\001\000\065\000\143\004\000\000\
\\001\000\065\000\145\004\000\000\
\\001\000\065\000\146\004\000\000\
\\001\000\065\000\147\004\000\000\
\\001\000\065\000\149\004\000\000\
\\001\000\065\000\150\004\000\000\
\\001\000\065\000\154\004\000\000\
\\001\000\065\000\155\004\000\000\
\\001\000\065\000\156\004\000\000\
\\001\000\065\000\157\004\000\000\
\\001\000\065\000\158\004\000\000\
\\001\000\065\000\175\004\000\000\
\\001\000\065\000\177\004\000\000\
\\001\000\065\000\178\004\000\000\
\\001\000\065\000\186\004\000\000\
\\001\000\065\000\187\004\000\000\
\\001\000\065\000\189\004\000\000\
\\001\000\065\000\192\004\000\000\
\\001\000\065\000\193\004\000\000\
\\001\000\065\000\195\004\000\000\
\\001\000\065\000\206\004\000\000\
\\001\000\065\000\208\004\000\000\
\\001\000\065\000\209\004\000\000\
\\001\000\065\000\215\004\000\000\
\\001\000\065\000\217\004\000\000\
\\001\000\065\000\235\004\000\000\
\\001\000\065\000\237\004\000\000\
\\001\000\065\000\239\004\000\000\
\\001\000\065\000\241\004\000\000\
\\001\000\065\000\242\004\000\000\
\\001\000\065\000\243\004\000\000\
\\001\000\065\000\244\004\000\000\
\\001\000\065\000\245\004\000\000\
\\001\000\065\000\246\004\000\000\
\\001\000\065\000\000\005\000\000\
\\001\000\065\000\001\005\000\000\
\\001\000\065\000\002\005\000\000\
\\001\000\065\000\003\005\000\000\
\\001\000\065\000\010\005\000\000\
\\001\000\065\000\011\005\000\000\
\\001\000\065\000\013\005\000\000\
\\001\000\065\000\014\005\000\000\
\\001\000\065\000\020\005\000\000\
\\001\000\065\000\021\005\000\000\
\\001\000\065\000\022\005\000\000\
\\001\000\065\000\023\005\000\000\
\\001\000\065\000\026\005\000\000\
\\001\000\065\000\027\005\000\000\
\\001\000\065\000\028\005\000\000\
\\001\000\065\000\031\005\000\000\
\\001\000\065\000\033\005\000\000\
\\001\000\065\000\043\005\000\000\
\\001\000\065\000\047\005\000\000\
\\001\000\065\000\050\005\000\000\
\\001\000\065\000\051\005\000\000\
\\001\000\065\000\052\005\000\000\
\\001\000\065\000\054\005\000\000\
\\001\000\065\000\060\005\000\000\
\\001\000\065\000\066\005\000\000\
\\001\000\065\000\073\005\000\000\
\\001\000\065\000\074\005\000\000\
\\001\000\065\000\078\005\000\000\
\\001\000\065\000\080\005\000\000\
\\001\000\065\000\082\005\000\000\
\\001\000\065\000\083\005\000\000\
\\001\000\065\000\092\005\000\000\
\\001\000\065\000\094\005\000\000\
\\001\000\065\000\095\005\000\000\
\\001\000\065\000\104\005\000\000\
\\001\000\065\000\105\005\000\000\
\\001\000\065\000\106\005\000\000\
\\001\000\065\000\107\005\000\000\
\\001\000\065\000\109\005\000\000\
\\001\000\065\000\112\005\000\000\
\\001\000\065\000\123\005\000\000\
\\001\000\065\000\129\005\000\000\
\\001\000\065\000\130\005\000\000\
\\001\000\065\000\146\005\000\000\
\\001\000\065\000\150\005\000\000\
\\001\000\065\000\168\005\000\000\
\\001\000\065\000\178\005\000\000\
\\001\000\065\000\185\005\000\000\
\\001\000\065\000\190\005\000\000\
\\001\000\065\000\191\005\000\000\
\\001\000\065\000\193\005\068\000\102\005\000\000\
\\001\000\065\000\194\005\000\000\
\\001\000\065\000\196\005\068\000\102\005\000\000\
\\001\000\065\000\198\005\068\000\102\005\000\000\
\\001\000\065\000\199\005\000\000\
\\001\000\065\000\201\005\068\000\102\005\000\000\
\\001\000\065\000\202\005\000\000\
\\001\000\065\000\203\005\000\000\
\\001\000\065\000\204\005\000\000\
\\001\000\065\000\205\005\000\000\
\\001\000\068\000\160\003\000\000\
\\001\000\068\000\207\003\000\000\
\\001\000\068\000\191\004\000\000\
\\001\000\068\000\219\004\000\000\
\\001\000\068\000\030\005\000\000\
\\001\000\068\000\102\005\069\000\156\005\000\000\
\\001\000\068\000\102\005\069\000\159\005\000\000\
\\001\000\068\000\102\005\069\000\161\005\000\000\
\\001\000\068\000\102\005\069\000\164\005\000\000\
\\001\000\069\000\170\001\000\000\
\\001\000\069\000\140\002\000\000\
\\001\000\069\000\169\003\000\000\
\\001\000\069\000\018\004\000\000\
\\001\000\069\000\077\004\000\000\
\\001\000\069\000\204\004\000\000\
\\001\000\069\000\233\004\000\000\
\\001\000\069\000\249\004\000\000\
\\001\000\069\000\255\004\133\000\254\004\000\000\
\\001\000\069\000\059\005\000\000\
\\001\000\069\000\065\005\000\000\
\\001\000\069\000\071\005\000\000\
\\001\000\069\000\079\005\000\000\
\\001\000\069\000\117\005\000\000\
\\001\000\069\000\133\005\000\000\
\\001\000\069\000\137\005\000\000\
\\001\000\069\000\141\005\000\000\
\\001\000\069\000\154\005\000\000\
\\001\000\069\000\157\005\000\000\
\\001\000\069\000\162\005\000\000\
\\001\000\069\000\174\005\000\000\
\\001\000\069\000\175\005\000\000\
\\001\000\069\000\176\005\000\000\
\\001\000\069\000\177\005\000\000\
\\001\000\071\000\108\003\000\000\
\\001\000\071\000\111\003\000\000\
\\001\000\071\000\128\003\000\000\
\\001\000\071\000\135\003\000\000\
\\001\000\071\000\210\003\000\000\
\\001\000\071\000\230\003\000\000\
\\001\000\071\000\095\004\000\000\
\\001\000\071\000\096\004\000\000\
\\001\000\071\000\167\004\000\000\
\\001\000\071\000\226\004\000\000\
\\001\000\071\000\250\004\000\000\
\\001\000\089\000\151\001\000\000\
\\001\000\097\000\121\003\000\000\
\\001\000\097\000\092\004\000\000\
\\001\000\108\000\119\001\000\000\
\\001\000\108\000\134\001\000\000\
\\001\000\108\000\135\001\000\000\
\\001\000\108\000\146\001\000\000\
\\001\000\108\000\147\001\000\000\
\\001\000\108\000\148\001\000\000\
\\001\000\108\000\149\001\000\000\
\\001\000\108\000\150\001\000\000\
\\001\000\108\000\029\002\000\000\
\\001\000\108\000\209\002\000\000\
\\001\000\108\000\039\003\000\000\
\\001\000\108\000\057\003\000\000\
\\001\000\108\000\105\003\000\000\
\\001\000\108\000\168\003\000\000\
\\001\000\108\000\211\003\000\000\
\\001\000\108\000\106\004\000\000\
\\001\000\108\000\109\004\000\000\
\\001\000\108\000\160\004\000\000\
\\001\000\108\000\212\004\000\000\
\\001\000\108\000\213\004\000\000\
\\001\000\108\000\218\004\000\000\
\\001\000\108\000\042\005\000\000\
\\001\000\108\000\068\005\000\000\
\\001\000\108\000\070\005\000\000\
\\001\000\108\000\097\005\000\000\
\\001\000\108\000\111\005\000\000\
\\001\000\108\000\132\005\000\000\
\\001\000\117\000\153\002\000\000\
\\001\000\118\000\182\004\000\000\
\\001\000\118\000\045\005\000\000\
\\001\000\118\000\056\005\000\000\
\\001\000\127\000\012\002\000\000\
\\001\000\127\000\052\002\000\000\
\\001\000\144\000\234\003\000\000\
\\001\000\170\000\116\001\000\000\
\\001\000\170\000\206\002\000\000\
\\001\000\170\000\136\003\000\000\
\\001\000\170\000\157\003\000\000\
\\001\000\170\000\159\003\000\000\
\\001\000\170\000\212\003\000\000\
\\001\000\170\000\231\003\000\000\
\\001\000\170\000\090\004\000\000\
\\001\000\170\000\252\004\000\000\
\\207\005\000\000\
\\208\005\000\000\
\\209\005\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\012\000\103\000\013\000\102\000\014\000\101\000\
\\015\000\100\000\016\000\099\000\024\000\098\000\025\000\097\000\
\\028\000\096\000\033\000\095\000\034\000\094\000\035\000\093\000\
\\040\000\092\000\041\000\091\000\042\000\090\000\043\000\089\000\
\\044\000\088\000\047\000\087\000\050\000\086\000\051\000\085\000\
\\052\000\084\000\055\000\083\000\056\000\082\000\059\000\081\000\
\\061\000\080\000\062\000\079\000\064\000\078\000\068\000\077\000\
\\070\000\076\000\075\000\075\000\076\000\074\000\077\000\073\000\
\\078\000\072\000\080\000\071\000\081\000\070\000\088\000\069\000\
\\091\000\068\000\092\000\067\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\119\000\062\000\120\000\061\000\
\\121\000\060\000\127\000\059\000\129\000\058\000\131\000\057\000\
\\134\000\056\000\138\000\055\000\139\000\054\000\140\000\053\000\
\\142\000\052\000\143\000\051\000\151\000\050\000\153\000\049\000\
\\157\000\048\000\158\000\047\000\161\000\046\000\162\000\045\000\
\\164\000\044\000\166\000\043\000\167\000\042\000\172\000\041\000\
\\175\000\040\000\177\000\039\000\178\000\038\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\185\000\033\000\
\\186\000\032\000\187\000\031\000\189\000\030\000\000\000\
\\210\005\000\000\
\\211\005\060\000\119\000\000\000\
\\212\005\000\000\
\\213\005\000\000\
\\214\005\000\000\
\\215\005\000\000\
\\216\005\000\000\
\\217\005\000\000\
\\218\005\000\000\
\\219\005\000\000\
\\220\005\000\000\
\\221\005\000\000\
\\222\005\000\000\
\\223\005\000\000\
\\224\005\000\000\
\\225\005\000\000\
\\226\005\000\000\
\\227\005\000\000\
\\228\005\000\000\
\\229\005\000\000\
\\230\005\000\000\
\\231\005\000\000\
\\232\005\000\000\
\\233\005\000\000\
\\234\005\000\000\
\\235\005\000\000\
\\236\005\000\000\
\\237\005\000\000\
\\238\005\000\000\
\\239\005\000\000\
\\240\005\000\000\
\\241\005\000\000\
\\242\005\000\000\
\\243\005\000\000\
\\244\005\000\000\
\\245\005\000\000\
\\246\005\000\000\
\\247\005\000\000\
\\248\005\000\000\
\\249\005\000\000\
\\250\005\000\000\
\\251\005\000\000\
\\252\005\000\000\
\\253\005\000\000\
\\254\005\000\000\
\\255\005\000\000\
\\000\006\000\000\
\\001\006\000\000\
\\002\006\000\000\
\\003\006\000\000\
\\004\006\000\000\
\\005\006\000\000\
\\006\006\000\000\
\\007\006\000\000\
\\008\006\000\000\
\\009\006\000\000\
\\010\006\000\000\
\\011\006\000\000\
\\012\006\000\000\
\\013\006\000\000\
\\014\006\000\000\
\\015\006\000\000\
\\016\006\000\000\
\\017\006\000\000\
\\018\006\000\000\
\\019\006\000\000\
\\020\006\000\000\
\\021\006\000\000\
\\022\006\000\000\
\\023\006\000\000\
\\024\006\000\000\
\\025\006\000\000\
\\026\006\000\000\
\\027\006\000\000\
\\028\006\000\000\
\\029\006\000\000\
\\030\006\000\000\
\\031\006\000\000\
\\032\006\000\000\
\\033\006\000\000\
\\034\006\000\000\
\\035\006\000\000\
\\036\006\000\000\
\\037\006\000\000\
\\038\006\000\000\
\\039\006\000\000\
\\040\006\000\000\
\\041\006\000\000\
\\042\006\000\000\
\\043\006\000\000\
\\044\006\000\000\
\\045\006\000\000\
\\046\006\000\000\
\\047\006\024\000\140\000\000\000\
\\048\006\000\000\
\\049\006\000\000\
\\050\006\013\000\102\000\024\000\131\000\000\000\
\\051\006\000\000\
\\052\006\066\000\048\002\000\000\
\\053\006\000\000\
\\054\006\000\000\
\\055\006\000\000\
\\056\006\000\000\
\\057\006\000\000\
\\058\006\000\000\
\\059\006\000\000\
\\060\006\000\000\
\\061\006\000\000\
\\062\006\000\000\
\\063\006\000\000\
\\064\006\000\000\
\\065\006\000\000\
\\066\006\000\000\
\\067\006\000\000\
\\068\006\000\000\
\\069\006\000\000\
\\070\006\064\000\019\003\000\000\
\\071\006\000\000\
\\072\006\009\000\034\002\000\000\
\\073\006\000\000\
\\074\006\047\000\004\004\064\000\003\004\000\000\
\\075\006\000\000\
\\076\006\000\000\
\\076\006\039\000\050\001\000\000\
\\076\006\039\000\050\001\108\000\142\001\000\000\
\\076\006\039\000\050\001\108\000\147\001\000\000\
\\076\006\039\000\050\001\108\000\035\003\000\000\
\\076\006\039\000\050\001\108\000\104\004\000\000\
\\076\006\039\000\079\001\108\000\078\001\000\000\
\\077\006\000\000\
\\078\006\000\000\
\\079\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\080\006\066\000\152\001\000\000\
\\081\006\000\000\
\\082\006\000\000\
\\083\006\000\000\
\\084\006\000\000\
\\085\006\000\000\
\\086\006\000\000\
\\087\006\000\000\
\\088\006\000\000\
\\089\006\000\000\
\\090\006\000\000\
\\091\006\000\000\
\\092\006\000\000\
\\093\006\000\000\
\\094\006\000\000\
\\095\006\000\000\
\\096\006\000\000\
\\096\006\065\000\245\002\000\000\
\\097\006\000\000\
\\098\006\000\000\
\\098\006\065\000\244\002\000\000\
\\099\006\000\000\
\\100\006\000\000\
\\100\006\065\000\042\004\000\000\
\\101\006\000\000\
\\102\006\000\000\
\\102\006\065\000\242\003\000\000\
\\103\006\000\000\
\\104\006\000\000\
\\104\006\065\000\171\004\000\000\
\\105\006\000\000\
\\106\006\000\000\
\\106\006\065\000\241\003\000\000\
\\107\006\000\000\
\\107\006\065\000\025\005\000\000\
\\108\006\000\000\
\\109\006\000\000\
\\110\006\000\000\
\\111\006\000\000\
\\112\006\000\000\
\\113\006\000\000\
\\114\006\000\000\
\\115\006\000\000\
\\116\006\000\000\
\\117\006\000\000\
\\117\006\065\000\024\005\000\000\
\\118\006\000\000\
\\119\006\000\000\
\\120\006\000\000\
\\121\006\000\000\
\\122\006\000\000\
\\123\006\000\000\
\\124\006\000\000\
\\125\006\000\000\
\\126\006\000\000\
\\127\006\000\000\
\\128\006\000\000\
\\129\006\000\000\
\\130\006\000\000\
\\130\006\065\000\007\004\000\000\
\\131\006\000\000\
\\132\006\000\000\
\\133\006\000\000\
\\133\006\065\000\043\004\000\000\
\\134\006\000\000\
\\135\006\000\000\
\\135\006\065\000\026\005\000\000\
\\136\006\000\000\
\\137\006\000\000\
\\137\006\065\000\030\004\000\000\
\\138\006\000\000\
\\138\006\065\000\028\004\000\000\
\\139\006\000\000\
\\140\006\000\000\
\\141\006\000\000\
\\142\006\000\000\
\\143\006\000\000\
\\144\006\000\000\
\\145\006\000\000\
\\145\006\065\000\062\004\000\000\
\\146\006\000\000\
\\147\006\000\000\
\\148\006\000\000\
\\149\006\000\000\
\\150\006\000\000\
\\151\006\000\000\
\\152\006\000\000\
\\153\006\000\000\
\\154\006\000\000\
\\155\006\000\000\
\\156\006\000\000\
\\157\006\000\000\
\\158\006\000\000\
\\159\006\000\000\
\\160\006\000\000\
\\161\006\000\000\
\\162\006\000\000\
\\163\006\000\000\
\\164\006\000\000\
\\165\006\000\000\
\\166\006\000\000\
\\167\006\000\000\
\\168\006\000\000\
\\169\006\000\000\
\\170\006\000\000\
\\171\006\000\000\
\\172\006\000\000\
\\173\006\000\000\
\\174\006\000\000\
\\175\006\000\000\
\\176\006\000\000\
\\177\006\000\000\
\\178\006\000\000\
\\179\006\000\000\
\\180\006\000\000\
\\180\006\065\000\253\003\000\000\
\\181\006\000\000\
\\182\006\000\000\
\\183\006\000\000\
\\184\006\000\000\
\\185\006\000\000\
\\186\006\000\000\
\\187\006\000\000\
\\188\006\000\000\
\\189\006\000\000\
\\190\006\064\000\039\002\000\000\
\\191\006\000\000\
\\192\006\066\000\113\001\000\000\
\\193\006\000\000\
\\194\006\066\000\053\002\000\000\
\\195\006\000\000\
\\199\006\000\000\
\\200\006\000\000\
\\201\006\000\000\
\\202\006\000\000\
\\203\006\000\000\
\\204\006\000\000\
\\205\006\000\000\
\\206\006\000\000\
\\207\006\000\000\
\\208\006\029\000\075\001\058\000\074\001\097\000\073\001\000\000\
\\209\006\000\000\
\\210\006\000\000\
\\211\006\029\000\075\001\058\000\074\001\097\000\073\001\000\000\
\\212\006\060\000\072\001\132\000\071\001\000\000\
\\213\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\118\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\117\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\173\000\115\000\175\000\040\000\
\\179\000\037\000\180\000\036\000\181\000\035\000\184\000\114\000\000\000\
\\214\006\000\000\
\\215\006\000\000\
\\216\006\000\000\
\\217\006\000\000\
\\218\006\000\000\
\\219\006\024\000\204\002\000\000\
\\220\006\000\000\
\\221\006\000\000\
\\222\006\000\000\
\\225\006\000\000\
\\225\006\030\000\172\001\000\000\
\\225\006\058\000\176\001\000\000\
\\226\006\000\000\
\\227\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\009\000\175\001\010\000\174\001\013\000\102\000\
\\024\000\098\000\025\000\097\000\034\000\094\000\047\000\087\000\
\\050\000\086\000\052\000\084\000\055\000\083\000\056\000\082\000\
\\061\000\080\000\062\000\079\000\064\000\116\000\068\000\077\000\
\\070\000\076\000\075\000\075\000\076\000\074\000\077\000\073\000\
\\078\000\072\000\080\000\071\000\081\000\070\000\088\000\069\000\
\\093\000\066\000\095\000\065\000\099\000\064\000\109\000\063\000\
\\138\000\055\000\139\000\054\000\157\000\048\000\158\000\047\000\
\\162\000\045\000\164\000\044\000\166\000\043\000\167\000\042\000\
\\175\000\040\000\179\000\037\000\180\000\036\000\181\000\035\000\
\\184\000\034\000\000\000\
\\227\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\228\006\000\000\
\\229\006\005\000\127\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\055\000\126\000\
\\062\000\079\000\064\000\125\000\068\000\077\000\070\000\076\000\
\\075\000\075\000\076\000\074\000\077\000\124\000\078\000\123\000\
\\081\000\122\000\088\000\069\000\139\000\054\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\179\000\037\000\180\000\036\000\
\\181\000\035\000\184\000\034\000\000\000\
\\230\006\000\000\
\\231\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\105\000\
\\006\000\104\000\013\000\102\000\024\000\098\000\025\000\097\000\
\\034\000\094\000\047\000\087\000\050\000\086\000\052\000\084\000\
\\055\000\083\000\056\000\082\000\061\000\080\000\062\000\079\000\
\\064\000\116\000\068\000\077\000\070\000\076\000\075\000\075\000\
\\076\000\074\000\077\000\073\000\078\000\072\000\080\000\071\000\
\\081\000\070\000\088\000\069\000\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\139\000\054\000\
\\157\000\048\000\158\000\047\000\162\000\045\000\164\000\044\000\
\\166\000\043\000\167\000\042\000\175\000\040\000\179\000\037\000\
\\180\000\036\000\181\000\035\000\184\000\034\000\000\000\
\\232\006\000\000\
\\233\006\002\000\108\000\003\000\107\000\004\000\106\000\005\000\107\001\
\\006\000\104\000\052\000\084\000\055\000\106\001\056\000\082\000\
\\061\000\080\000\064\000\105\001\077\000\104\001\078\000\103\001\
\\080\000\071\000\081\000\102\001\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\157\000\048\000\
\\158\000\047\000\162\000\045\000\175\000\040\000\000\000\
\\234\006\000\000\
\\235\006\024\000\204\002\000\000\
\\236\006\000\000\
\\237\006\024\000\204\002\000\000\
\\238\006\000\000\
\\239\006\000\000\
\\240\006\000\000\
\\241\006\000\000\
\\242\006\000\000\
\\243\006\000\000\
\\243\006\039\000\205\003\000\000\
\\244\006\000\000\
\\245\006\000\000\
\\246\006\039\000\032\002\000\000\
\\247\006\000\000\
\\248\006\000\000\
\\248\006\108\000\076\001\000\000\
\\248\006\108\000\146\001\000\000\
\\249\006\000\000\
\\250\006\000\000\
\\251\006\000\000\
\\252\006\000\000\
\\253\006\024\000\046\002\050\000\045\002\064\000\044\002\000\000\
\\254\006\000\000\
\\001\007\000\000\
\\002\007\000\000\
\\003\007\000\000\
\\004\007\000\000\
\\005\007\000\000\
\\006\007\000\000\
\\007\007\000\000\
\\008\007\000\000\
\\009\007\000\000\
\\010\007\000\000\
\\011\007\000\000\
\\012\007\000\000\
\\013\007\000\000\
\\014\007\000\000\
\\015\007\064\000\125\005\000\000\
\\016\007\000\000\
\\017\007\000\000\
\\018\007\000\000\
\\019\007\000\000\
\\020\007\000\000\
\\021\007\000\000\
\\022\007\000\000\
\\023\007\000\000\
\\024\007\000\000\
\\025\007\000\000\
\\026\007\000\000\
\\027\007\000\000\
\\028\007\000\000\
\\029\007\000\000\
\\030\007\000\000\
\\031\007\000\000\
\\032\007\000\000\
\\033\007\000\000\
\\034\007\000\000\
\\035\007\068\000\086\005\000\000\
\\036\007\000\000\
\\037\007\000\000\
\\038\007\000\000\
\\039\007\000\000\
\\040\007\000\000\
\\041\007\000\000\
\\042\007\000\000\
\\043\007\000\000\
\\044\007\000\000\
\\045\007\000\000\
\\046\007\000\000\
\\047\007\000\000\
\\048\007\000\000\
\\049\007\000\000\
\\050\007\000\000\
\\051\007\000\000\
\\052\007\000\000\
\\053\007\000\000\
\\054\007\000\000\
\\055\007\000\000\
\\056\007\000\000\
\\057\007\000\000\
\\058\007\000\000\
\\059\007\000\000\
\\060\007\000\000\
\\061\007\024\000\011\004\064\000\010\004\110\000\162\003\000\000\
\\062\007\000\000\
\\063\007\024\000\133\002\064\000\132\002\000\000\
\\064\007\000\000\
\\067\007\000\000\
\\068\007\000\000\
\\069\007\000\000\
\\070\007\000\000\
\\071\007\024\000\138\002\064\000\137\002\000\000\
\\072\007\000\000\
\\073\007\024\000\204\002\000\000\
\\074\007\000\000\
\\075\007\000\000\
\\076\007\000\000\
\\077\007\000\000\
\\078\007\000\000\
\\079\007\000\000\
\\080\007\000\000\
\\081\007\000\000\
\\082\007\064\000\213\001\000\000\
\\083\007\000\000\
\\084\007\009\000\136\001\000\000\
\\085\007\000\000\
\\086\007\000\000\
\\087\007\000\000\
\\088\007\000\000\
\\089\007\000\000\
\\090\007\000\000\
\\091\007\000\000\
\\092\007\000\000\
\\093\007\000\000\
\\094\007\024\000\133\002\064\000\112\004\000\000\
\\095\007\000\000\
\\096\007\024\000\122\004\064\000\112\004\000\000\
\\097\007\000\000\
\\098\007\024\000\133\002\064\000\112\004\000\000\
\\099\007\000\000\
\\102\007\000\000\
\\102\007\024\000\133\002\064\000\112\004\000\000\
\\103\007\000\000\
\\104\007\024\000\140\000\000\000\
\\105\007\000\000\
\\106\007\024\000\063\001\000\000\
\\107\007\000\000\
\\108\007\024\000\140\000\000\000\
\\109\007\000\000\
\\110\007\037\000\197\003\039\000\069\002\000\000\
\\110\007\039\000\069\002\000\000\
\\111\007\000\000\
\\112\007\000\000\
\\113\007\000\000\
\\114\007\000\000\
\\117\007\024\000\068\001\000\000\
\\118\007\000\000\
\\119\007\000\000\
\\120\007\000\000\
\\121\007\000\000\
\\122\007\000\000\
\\123\007\024\000\068\001\037\000\180\002\184\000\124\002\000\000\
\\123\007\024\000\068\001\037\000\021\004\039\000\020\004\184\000\124\002\000\000\
\\123\007\024\000\068\001\039\000\094\003\184\000\124\002\000\000\
\\123\007\024\000\068\001\039\000\020\004\184\000\124\002\000\000\
\\123\007\024\000\068\001\184\000\124\002\000\000\
\\124\007\000\000\
\\125\007\024\000\068\001\184\000\167\001\000\000\
\\126\007\000\000\
\\127\007\066\000\100\001\000\000\
\\128\007\000\000\
\\129\007\024\000\140\000\000\000\
\\130\007\000\000\
\\131\007\024\000\063\001\000\000\
\\132\007\000\000\
\\133\007\000\000\
\\134\007\000\000\
\\141\007\000\000\
\\142\007\000\000\
\\143\007\000\000\
\\144\007\000\000\
\\145\007\000\000\
\\146\007\000\000\
\\147\007\000\000\
\\148\007\000\000\
\\149\007\000\000\
\\150\007\000\000\
\\151\007\000\000\
\\152\007\000\000\
\\153\007\000\000\
\\154\007\000\000\
\\155\007\000\000\
\\156\007\000\000\
\\157\007\000\000\
\\158\007\000\000\
\\159\007\000\000\
\\160\007\000\000\
\\161\007\000\000\
\\162\007\000\000\
\\163\007\000\000\
\\164\007\000\000\
\\165\007\000\000\
\\166\007\000\000\
\\167\007\000\000\
\\168\007\000\000\
\\169\007\000\000\
\\170\007\000\000\
\\171\007\000\000\
\\172\007\000\000\
\\173\007\000\000\
\\174\007\000\000\
\\175\007\000\000\
\\176\007\000\000\
\\177\007\000\000\
\\178\007\000\000\
\\179\007\000\000\
\\180\007\000\000\
\\181\007\000\000\
\\182\007\000\000\
\\183\007\024\000\068\001\025\000\132\001\034\000\131\001\047\000\130\001\
\\048\000\129\001\050\000\128\001\064\000\127\001\068\000\126\001\
\\184\000\125\001\000\000\
\\184\007\000\000\
\\185\007\000\000\
\\186\007\024\000\068\001\025\000\132\001\034\000\131\001\047\000\130\001\
\\048\000\129\001\050\000\128\001\064\000\127\001\068\000\126\001\
\\184\000\125\001\000\000\
\\187\007\000\000\
\\188\007\000\000\
\\189\007\000\000\
\\190\007\000\000\
\\191\007\000\000\
\\192\007\024\000\204\002\000\000\
\\193\007\000\000\
\\194\007\052\000\084\000\064\000\022\002\000\000\
\\194\007\064\000\022\002\000\000\
\\195\007\000\000\
\\196\007\000\000\
\\197\007\000\000\
\\198\007\024\000\204\002\000\000\
\\199\007\000\000\
\\200\007\052\000\084\000\064\000\019\002\000\000\
\\200\007\064\000\019\002\000\000\
\\201\007\000\000\
\\202\007\000\000\
\\203\007\000\000\
\\204\007\000\000\
\\205\007\000\000\
\\206\007\000\000\
\\207\007\000\000\
\\208\007\052\000\084\000\064\000\052\003\138\000\163\001\000\000\
\\208\007\064\000\052\003\000\000\
\\209\007\000\000\
\\210\007\052\000\084\000\064\000\240\002\000\000\
\\210\007\052\000\084\000\064\000\240\002\097\000\239\002\138\000\096\001\000\000\
\\210\007\052\000\084\000\064\000\240\002\138\000\110\001\000\000\
\\210\007\052\000\084\000\064\000\240\002\138\000\112\001\000\000\
\\210\007\064\000\240\002\000\000\
\\210\007\064\000\240\002\097\000\100\004\000\000\
\\211\007\000\000\
\\212\007\024\000\204\002\000\000\
\\213\007\000\000\
\\214\007\024\000\204\002\000\000\
\\215\007\000\000\
\\216\007\024\000\204\002\000\000\
\\217\007\000\000\
\\218\007\000\000\
\\219\007\024\000\204\002\000\000\
\\220\007\000\000\
\\221\007\000\000\
\\222\007\000\000\
\\223\007\000\000\
\\224\007\000\000\
\\224\007\002\000\108\000\003\000\107\000\004\000\106\000\005\000\107\001\
\\006\000\104\000\052\000\084\000\055\000\106\001\056\000\082\000\
\\061\000\080\000\064\000\105\001\077\000\104\001\078\000\103\001\
\\080\000\071\000\081\000\102\001\093\000\066\000\095\000\065\000\
\\099\000\064\000\109\000\063\000\138\000\055\000\157\000\048\000\
\\158\000\047\000\162\000\045\000\175\000\040\000\000\000\
\\225\007\000\000\
\\226\007\060\000\144\001\000\000\
\\227\007\000\000\
\\228\007\064\000\228\001\000\000\
\\229\007\000\000\
\\230\007\060\000\208\002\000\000\
\\231\007\000\000\
\\238\007\000\000\
\\239\007\000\000\
\\240\007\000\000\
\\241\007\000\000\
\\242\007\000\000\
\"
val actionRowNumbers =
"\004\000\011\000\100\002\099\002\
\\232\001\231\001\157\002\248\002\
\\092\002\245\002\229\001\230\001\
\\228\001\227\001\226\001\225\001\
\\221\001\220\001\222\001\219\001\
\\218\001\217\001\233\001\215\001\
\\213\001\224\001\223\001\211\001\
\\026\000\036\000\036\000\037\000\
\\016\003\026\000\026\000\026\000\
\\153\000\042\000\008\000\042\000\
\\026\000\008\000\042\000\026\000\
\\154\000\008\000\008\000\026\000\
\\026\000\042\000\045\000\044\002\
\\008\000\011\000\042\000\046\000\
\\047\000\048\000\049\000\047\000\
\\047\000\008\000\008\000\012\000\
\\013\000\029\000\029\000\089\002\
\\144\000\138\000\138\000\008\000\
\\155\000\156\000\026\000\250\002\
\\021\000\026\000\030\000\013\002\
\\138\000\138\000\068\002\001\002\
\\050\000\051\000\157\000\158\000\
\\042\000\008\000\009\000\026\000\
\\097\002\008\000\003\002\098\002\
\\081\002\042\000\036\000\159\000\
\\087\002\008\000\138\000\138\000\
\\052\000\054\000\055\000\150\000\
\\234\002\227\002\226\002\127\000\
\\017\003\224\002\022\000\030\000\
\\086\002\216\001\214\001\253\001\
\\138\000\138\000\008\000\018\000\
\\138\000\138\000\012\002\054\002\
\\053\002\080\002\010\002\026\000\
\\036\000\026\000\026\000\008\000\
\\042\000\042\000\122\003\143\000\
\\125\000\109\002\106\002\128\000\
\\151\003\020\000\059\000\145\000\
\\146\000\249\001\026\002\217\002\
\\031\003\026\000\008\000\202\001\
\\134\000\060\000\026\003\168\001\
\\103\003\061\000\089\003\204\003\
\\062\000\169\001\170\001\110\003\
\\106\003\102\003\129\000\138\000\
\\020\000\082\002\020\000\253\003\
\\020\000\018\003\083\002\022\002\
\\024\002\173\001\001\000\023\002\
\\174\001\175\001\165\001\090\002\
\\008\000\020\000\057\000\057\000\
\\147\000\149\003\149\003\008\000\
\\130\001\250\002\246\002\249\002\
\\247\002\026\000\036\000\036\000\
\\038\000\026\000\026\000\026\000\
\\160\000\042\000\008\000\042\000\
\\042\000\042\000\026\000\008\000\
\\026\000\043\000\026\000\161\000\
\\008\000\008\000\026\000\026\000\
\\026\000\042\000\063\000\175\000\
\\008\000\044\000\064\000\162\000\
\\047\000\065\000\066\000\162\000\
\\047\000\067\000\068\000\008\000\
\\163\000\012\000\163\000\014\000\
\\029\000\029\000\020\000\008\000\
\\026\000\020\000\024\000\139\000\
\\140\000\008\000\165\000\166\000\
\\026\000\096\002\030\000\176\000\
\\141\000\142\000\177\000\026\000\
\\042\000\009\000\009\000\026\000\
\\008\000\178\000\042\000\036\000\
\\199\001\168\000\026\000\008\000\
\\008\000\219\003\212\003\053\000\
\\069\000\055\000\152\000\252\002\
\\020\000\176\001\002\000\057\000\
\\057\000\008\003\007\003\014\003\
\\070\000\047\002\076\002\071\000\
\\138\000\008\000\246\001\215\002\
\\008\000\022\000\252\001\008\000\
\\072\000\138\000\016\002\056\002\
\\075\000\200\001\219\002\008\000\
\\003\000\003\000\130\000\158\003\
\\155\003\124\003\131\000\020\000\
\\137\003\136\003\132\003\244\002\
\\069\002\148\000\235\002\008\000\
\\026\000\008\000\010\000\019\000\
\\010\000\073\000\026\000\057\000\
\\138\000\057\000\003\000\055\002\
\\007\002\179\000\008\000\121\002\
\\115\002\180\000\157\003\153\003\
\\033\003\076\000\076\000\026\000\
\\251\001\026\000\042\000\204\002\
\\144\000\138\000\008\000\023\000\
\\138\000\138\000\147\003\076\000\
\\076\000\076\000\076\000\026\000\
\\004\004\148\002\243\002\087\003\
\\042\000\080\000\042\000\165\003\
\\131\001\204\003\162\003\159\003\
\\204\003\031\000\081\000\026\000\
\\082\000\169\003\163\003\143\003\
\\008\000\008\000\047\000\029\000\
\\029\000\026\000\076\000\160\002\
\\008\000\162\002\083\000\158\002\
\\008\000\008\000\026\000\026\000\
\\008\000\132\002\089\002\150\000\
\\150\000\002\003\004\003\203\001\
\\150\000\001\004\177\001\150\000\
\\076\000\076\000\141\003\181\000\
\\149\003\142\003\182\000\112\002\
\\129\002\251\002\057\000\183\000\
\\008\000\008\000\020\000\184\000\
\\185\000\186\000\026\000\036\000\
\\026\000\026\000\008\000\042\000\
\\042\000\232\003\126\000\187\000\
\\188\000\110\002\107\002\008\000\
\\129\003\020\000\084\000\233\003\
\\234\003\189\000\190\000\191\000\
\\192\000\085\000\027\000\045\002\
\\008\000\077\000\042\000\086\000\
\\193\000\194\000\104\003\047\000\
\\080\000\195\000\196\000\074\002\
\\204\003\087\000\008\000\008\000\
\\197\000\198\000\135\000\199\000\
\\231\003\020\000\057\000\020\000\
\\020\000\020\000\084\002\200\000\
\\201\000\202\000\178\001\203\000\
\\000\003\254\002\204\000\250\002\
\\205\000\206\000\255\003\255\003\
\\228\003\149\003\149\003\008\000\
\\020\000\179\001\004\002\255\003\
\\255\003\000\002\250\002\004\000\
\\207\000\008\000\208\000\008\000\
\\209\000\008\000\002\002\004\000\
\\210\000\039\000\088\000\008\000\
\\211\000\212\000\213\000\214\000\
\\220\003\003\000\215\000\213\003\
\\003\000\052\000\005\000\020\000\
\\093\002\253\002\152\002\026\000\
\\150\000\150\000\072\000\147\003\
\\158\000\145\003\004\000\243\001\
\\216\002\008\000\242\001\249\002\
\\239\001\095\002\089\000\090\000\
\\020\003\004\000\036\000\204\003\
\\091\000\180\001\170\000\008\000\
\\237\001\154\001\150\000\217\003\
\\206\003\207\003\155\001\150\000\
\\150\000\210\003\008\000\156\003\
\\008\000\168\002\138\003\074\000\
\\011\000\011\000\238\002\225\002\
\\166\001\221\002\229\002\233\002\
\\026\000\228\002\230\002\032\000\
\\150\000\076\000\150\000\156\001\
\\026\000\118\002\042\000\154\003\
\\057\000\150\000\246\003\240\003\
\\245\003\157\001\040\000\204\001\
\\138\000\026\000\152\003\020\000\
\\057\000\147\000\151\000\008\000\
\\026\000\008\000\008\000\008\000\
\\008\000\015\000\164\000\030\000\
\\167\000\220\003\169\000\092\000\
\\055\000\057\000\003\000\139\003\
\\216\000\147\003\140\003\150\000\
\\205\001\150\000\206\001\218\002\
\\121\001\080\003\093\000\111\003\
\\217\000\098\003\095\003\094\000\
\\091\003\218\000\181\001\205\003\
\\132\001\056\000\057\000\057\000\
\\058\000\058\000\058\000\058\000\
\\058\000\058\000\058\000\095\000\
\\096\000\058\000\097\000\058\000\
\\058\000\058\000\161\003\057\000\
\\058\000\058\000\058\000\098\000\
\\058\000\058\000\131\003\057\000\
\\057\000\057\000\057\000\057\000\
\\057\000\057\000\168\003\160\003\
\\011\003\219\000\122\001\038\002\
\\028\002\107\003\150\000\241\002\
\\158\001\182\001\207\001\149\000\
\\150\000\020\000\254\003\171\001\
\\172\001\252\003\250\003\051\002\
\\021\002\088\002\091\002\137\002\
\\194\002\020\000\212\001\026\000\
\\201\002\020\000\057\000\008\000\
\\008\000\057\000\150\000\150\000\
\\243\003\238\003\242\003\159\001\
\\208\001\020\000\150\003\026\000\
\\201\001\128\002\220\000\221\000\
\\222\000\235\001\011\002\009\002\
\\223\000\224\000\008\000\122\002\
\\116\002\225\000\226\000\227\000\
\\235\003\026\000\057\000\228\000\
\\255\001\254\001\108\002\105\002\
\\020\000\229\000\129\003\205\002\
\\147\003\231\000\232\000\248\001\
\\247\001\025\002\030\003\137\000\
\\233\000\016\000\149\002\234\000\
\\085\003\235\000\042\000\100\000\
\\025\003\108\003\105\003\236\000\
\\097\003\093\003\100\003\046\002\
\\075\002\101\000\133\001\144\003\
\\237\000\238\000\109\003\101\003\
\\012\003\072\000\006\003\239\000\
\\240\000\008\000\161\002\242\000\
\\159\002\008\000\019\002\018\002\
\\017\002\026\000\202\002\001\003\
\\255\002\146\002\244\000\200\002\
\\136\002\245\000\255\003\246\000\
\\247\000\229\003\057\000\248\000\
\\249\000\113\002\153\002\026\000\
\\251\000\252\000\253\000\254\000\
\\245\001\255\000\244\001\000\001\
\\234\001\001\001\002\001\015\002\
\\014\002\204\003\102\000\008\000\
\\003\001\094\002\103\002\102\002\
\\184\002\221\003\020\000\138\002\
\\214\003\026\000\004\001\127\003\
\\169\002\020\000\020\000\008\000\
\\015\003\006\001\077\002\007\001\
\\171\000\150\000\008\000\006\000\
\\072\000\072\000\019\003\150\000\
\\057\002\134\001\132\000\008\000\
\\009\001\220\002\020\000\199\002\
\\003\000\008\000\198\002\139\002\
\\003\000\127\003\125\003\133\003\
\\033\000\150\000\209\001\008\000\
\\167\001\103\000\026\000\057\000\
\\160\001\026\000\026\000\008\002\
\\035\003\161\001\177\002\241\003\
\\247\003\020\000\176\002\076\000\
\\127\002\150\000\076\000\236\003\
\\020\000\235\003\235\003\235\003\
\\020\000\020\000\085\002\020\000\
\\183\001\008\000\020\000\150\000\
\\184\001\148\003\175\002\174\002\
\\173\002\172\002\116\003\010\001\
\\078\000\123\003\029\003\080\000\
\\118\003\090\003\008\000\164\003\
\\011\001\201\003\026\000\012\001\
\\057\000\013\001\014\001\015\001\
\\016\001\017\001\018\001\019\001\
\\020\001\021\001\022\001\023\001\
\\024\001\025\001\026\001\027\001\
\\057\000\028\001\029\001\030\001\
\\057\000\031\001\032\001\057\000\
\\057\000\104\000\033\001\034\001\
\\035\001\036\001\037\001\072\000\
\\185\001\204\003\165\002\029\000\
\\020\000\026\000\164\002\029\000\
\\029\000\197\002\163\002\052\002\
\\003\003\005\003\191\002\002\004\
\\249\003\190\002\142\002\162\001\
\\196\002\140\002\239\003\244\003\
\\008\000\195\002\134\002\123\002\
\\026\000\104\002\101\002\150\002\
\\005\002\026\000\119\002\120\002\
\\114\002\042\000\032\003\212\002\
\\237\003\231\003\020\000\250\001\
\\038\001\026\000\130\003\203\002\
\\039\001\211\002\210\002\040\001\
\\078\002\195\001\105\000\003\004\
\\137\000\147\002\081\003\196\001\
\\042\000\078\000\079\000\041\001\
\\042\001\099\003\094\003\146\003\
\\008\000\043\001\172\000\123\001\
\\029\002\027\002\044\001\187\002\
\\183\002\045\001\182\002\181\002\
\\180\002\251\003\046\001\186\002\
\\020\000\000\004\026\000\141\002\
\\230\003\026\000\020\000\026\000\
\\111\002\151\002\020\000\020\000\
\\026\000\185\002\070\002\241\001\
\\240\001\238\001\072\002\135\001\
\\133\000\047\001\008\000\048\001\
\\049\001\008\000\020\000\128\003\
\\206\002\155\002\193\002\192\002\
\\143\002\186\001\187\001\034\000\
\\071\002\008\001\214\002\050\001\
\\023\003\051\001\073\002\188\001\
\\124\001\039\002\048\002\216\003\
\\218\003\209\003\211\003\020\000\
\\020\000\126\003\106\000\236\002\
\\237\002\222\002\008\000\107\000\
\\163\001\026\000\020\000\224\003\
\\150\000\020\000\026\000\230\000\
\\241\000\243\000\008\000\250\000\
\\026\000\005\001\020\000\026\000\
\\136\001\116\003\099\000\088\003\
\\052\001\120\003\053\001\096\003\
\\136\000\054\001\118\003\114\003\
\\041\000\040\002\198\003\202\003\
\\055\001\186\003\056\001\175\003\
\\174\003\184\003\183\003\182\003\
\\195\003\194\003\009\003\170\003\
\\181\003\167\003\172\003\171\003\
\\173\003\187\003\203\003\178\003\
\\177\003\176\003\057\001\180\003\
\\179\003\058\001\059\001\060\001\
\\191\003\189\003\190\003\188\003\
\\197\003\166\003\008\000\137\001\
\\242\002\239\002\164\001\150\000\
\\210\001\008\000\225\003\138\001\
\\061\001\117\002\062\001\063\001\
\\064\001\207\002\026\000\026\000\
\\028\000\079\002\010\003\026\000\
\\173\000\065\001\066\001\085\003\
\\067\001\027\003\068\001\007\000\
\\035\000\204\003\013\003\248\003\
\\069\001\020\002\070\001\071\001\
\\072\001\135\002\124\002\156\002\
\\074\001\075\001\008\000\125\001\
\\030\002\076\001\215\003\208\003\
\\127\003\077\001\026\000\008\000\
\\108\000\022\003\024\003\021\003\
\\008\000\204\003\171\002\170\002\
\\109\000\223\002\189\001\078\001\
\\026\000\227\003\178\002\235\003\
\\020\000\020\000\050\002\197\001\
\\117\003\112\003\121\003\113\003\
\\078\000\092\003\119\003\196\003\
\\185\003\199\003\200\003\192\003\
\\193\003\032\002\031\002\079\001\
\\020\000\167\002\166\002\226\003\
\\026\000\130\002\006\002\034\003\
\\213\002\223\003\080\001\081\001\
\\082\001\017\000\083\001\116\003\
\\086\003\079\003\198\001\028\003\
\\034\002\063\002\058\002\026\000\
\\110\000\139\001\179\002\188\002\
\\144\002\222\003\133\002\125\002\
\\154\002\189\002\145\002\084\001\
\\204\003\236\001\020\000\208\002\
\\033\002\067\002\064\002\111\000\
\\042\002\140\001\134\003\085\001\
\\026\000\190\001\073\001\078\000\
\\115\003\191\001\240\002\141\001\
\\126\002\049\002\007\004\137\000\
\\086\001\087\001\174\000\059\002\
\\112\000\088\001\036\002\142\001\
\\089\001\147\003\090\001\091\001\
\\135\003\231\002\026\000\059\003\
\\008\000\131\002\026\000\005\004\
\\078\000\116\003\147\003\092\001\
\\008\000\093\001\209\002\094\001\
\\147\003\192\001\232\002\083\003\
\\113\000\041\002\095\001\096\001\
\\097\001\098\001\147\003\099\001\
\\008\000\193\001\100\001\008\000\
\\114\000\143\001\037\003\036\003\
\\026\000\115\000\101\001\039\003\
\\078\000\025\000\102\001\035\002\
\\103\001\026\000\194\001\043\002\
\\144\001\063\003\116\000\060\003\
\\145\001\117\000\146\001\061\003\
\\118\000\006\004\104\001\119\000\
\\105\001\060\002\026\000\026\000\
\\037\002\065\002\026\000\064\003\
\\147\001\069\003\126\001\038\003\
\\148\001\067\003\127\001\062\003\
\\128\001\149\001\065\003\129\001\
\\084\003\120\000\106\001\121\000\
\\039\003\061\002\062\002\066\002\
\\070\003\150\001\073\003\068\003\
\\151\001\075\003\152\001\077\003\
\\066\003\153\001\071\003\107\001\
\\043\003\122\000\040\003\123\000\
\\108\001\041\003\124\000\109\001\
\\074\003\076\003\078\003\072\003\
\\044\003\110\001\049\003\111\001\
\\112\001\047\003\113\001\042\003\
\\114\001\115\001\045\003\116\001\
\\082\003\050\003\117\001\053\003\
\\048\003\118\001\055\003\119\001\
\\057\003\046\003\120\001\052\003\
\\054\003\056\003\058\003\051\003\
\\000\000"
val gotoT =
"\
\\001\000\204\005\002\000\027\000\003\000\026\000\004\000\025\000\
\\005\000\024\000\006\000\023\000\007\000\022\000\008\000\021\000\
\\009\000\020\000\010\000\019\000\012\000\018\000\013\000\017\000\
\\014\000\016\000\021\000\015\000\022\000\014\000\023\000\013\000\
\\024\000\012\000\025\000\011\000\026\000\010\000\064\000\009\000\
\\065\000\008\000\071\000\007\000\075\000\006\000\082\000\005\000\
\\125\000\004\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\107\000\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\119\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\128\000\133\000\127\000\134\000\126\000\000\000\
\\065\000\128\000\133\000\127\000\134\000\130\000\000\000\
\\065\000\128\000\133\000\131\000\000\000\
\\000\000\
\\064\000\133\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\134\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\135\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\137\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\139\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\140\000\000\000\
\\064\000\141\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\142\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\144\000\059\000\143\000\000\000\
\\064\000\145\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\147\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\148\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\149\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\151\000\065\000\008\000\067\000\150\000\127\000\003\000\
\\128\000\002\000\000\000\
\\039\000\144\000\059\000\152\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\154\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\155\000\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\144\000\059\000\156\000\000\000\
\\000\000\
\\016\000\160\000\020\000\159\000\000\000\
\\000\000\
\\000\000\
\\016\000\168\000\019\000\167\000\020\000\159\000\000\000\
\\016\000\169\000\020\000\159\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\170\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\171\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\172\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\176\000\123\000\175\000\124\000\174\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\181\000\064\000\151\000\065\000\008\000\067\000\180\000\
\\127\000\003\000\128\000\002\000\141\000\179\000\000\000\
\\039\000\184\000\064\000\151\000\065\000\008\000\067\000\183\000\
\\127\000\003\000\128\000\002\000\000\000\
\\041\000\187\000\042\000\186\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\185\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\139\000\188\000\000\000\
\\139\000\190\000\000\000\
\\139\000\191\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\192\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\195\000\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\198\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\196\000\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\200\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\199\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\027\001\065\000\008\000\066\000\026\001\127\000\003\000\
\\128\000\002\000\000\000\
\\040\000\029\001\064\000\028\001\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\139\000\031\001\000\000\
\\139\000\032\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\084\000\038\001\085\000\037\001\000\000\
\\039\000\040\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\041\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\044\001\127\000\003\000\128\000\002\000\137\000\043\001\
\\138\000\042\001\139\000\001\000\000\000\
\\064\000\046\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\047\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\049\001\000\000\
\\065\000\128\000\133\000\051\001\135\000\050\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\068\000\055\001\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\139\000\056\001\000\000\
\\139\000\057\001\000\000\
\\040\000\060\001\056\000\059\001\058\000\058\001\000\000\
\\000\000\
\\048\000\065\001\049\000\064\001\051\000\063\001\000\000\
\\140\000\067\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\200\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\199\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\040\000\029\001\064\000\075\001\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\078\001\000\000\
\\139\000\079\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\080\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\199\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\139\000\081\001\000\000\
\\139\000\082\001\000\000\
\\000\000\
\\065\000\128\000\133\000\127\000\134\000\083\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\084\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\128\000\133\000\127\000\134\000\085\001\000\000\
\\064\000\086\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\087\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\088\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\091\001\055\000\090\001\057\000\089\001\000\000\
\\039\000\092\001\000\000\
\\000\000\
\\139\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\099\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\139\000\107\001\000\000\
\\139\000\109\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\112\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\113\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\120\001\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\135\001\000\000\
\\139\000\138\001\000\000\
\\071\000\139\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\141\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\143\001\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\154\001\065\000\008\000\071\000\153\001\075\000\006\000\
\\079\000\152\001\080\000\151\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\071\000\153\001\075\000\006\000\079\000\155\001\139\000\001\000\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\156\001\
\\126\000\119\001\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\159\001\
\\126\000\119\001\000\000\
\\139\000\160\001\000\000\
\\045\000\164\001\047\000\163\001\048\000\065\001\049\000\162\001\000\000\
\\045\000\164\001\047\000\166\001\048\000\065\001\049\000\162\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\167\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\169\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\171\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\175\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\128\000\133\000\127\000\134\000\176\001\000\000\
\\065\000\128\000\133\000\127\000\134\000\177\001\000\000\
\\065\000\128\000\133\000\178\001\000\000\
\\064\000\180\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\181\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\182\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\184\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\185\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\186\001\000\000\
\\039\000\187\001\000\000\
\\039\000\188\001\000\000\
\\064\000\189\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\190\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\191\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\144\000\059\000\143\000\000\000\
\\064\000\193\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\195\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\196\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\027\001\065\000\008\000\066\000\197\001\127\000\003\000\
\\128\000\002\000\000\000\
\\064\000\198\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\027\001\065\000\008\000\066\000\199\001\127\000\003\000\
\\128\000\002\000\000\000\
\\039\000\091\001\055\000\090\001\057\000\200\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\204\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\205\001\000\000\
\\000\000\
\\017\000\210\001\018\000\209\001\000\000\
\\015\000\213\001\020\000\212\001\000\000\
\\086\000\215\001\087\000\214\001\000\000\
\\000\000\
\\017\000\210\001\018\000\220\001\000\000\
\\015\000\221\001\020\000\212\001\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\224\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\116\000\225\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\227\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\116\000\228\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\229\001\123\000\175\000\124\000\174\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\039\000\181\000\064\000\027\001\065\000\008\000\066\000\232\001\
\\127\000\003\000\128\000\002\000\141\000\231\001\000\000\
\\039\000\234\001\064\000\027\001\065\000\008\000\066\000\233\001\
\\127\000\003\000\128\000\002\000\000\000\
\\071\000\236\001\075\000\006\000\081\000\235\001\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\238\001\071\000\007\000\
\\075\000\006\000\082\000\237\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\239\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\236\001\075\000\006\000\081\000\240\001\139\000\001\000\000\000\
\\064\000\027\001\065\000\008\000\066\000\241\001\127\000\003\000\
\\128\000\002\000\139\000\188\000\000\000\
\\139\000\190\000\000\000\
\\139\000\191\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\244\001\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\247\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\040\000\249\001\064\000\248\001\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\139\000\031\001\000\000\
\\139\000\032\001\000\000\
\\000\000\
\\064\000\254\001\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\255\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\001\002\127\000\003\000\128\000\002\000\137\000\043\001\
\\138\000\000\002\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\003\002\127\000\003\000\128\000\002\000\137\000\043\001\
\\138\000\002\002\139\000\001\000\000\000\
\\064\000\004\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\005\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\039\000\007\002\000\000\
\\065\000\128\000\133\000\009\002\134\000\008\002\000\000\
\\000\000\
\\000\000\
\\064\000\012\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\013\002\071\000\007\000\
\\075\000\006\000\082\000\237\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\014\002\071\000\007\000\
\\075\000\006\000\082\000\237\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\097\000\016\002\100\000\015\002\139\000\056\001\000\000\
\\093\000\019\002\096\000\018\002\139\000\057\001\000\000\
\\040\000\060\001\056\000\059\001\058\000\058\001\000\000\
\\000\000\
\\048\000\065\001\049\000\064\001\051\000\023\002\000\000\
\\000\000\
\\064\000\027\001\065\000\008\000\066\000\025\002\127\000\003\000\
\\128\000\002\000\000\000\
\\071\000\026\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\028\002\
\\126\000\119\001\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\029\002\
\\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\034\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\035\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\137\000\043\001\138\000\036\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\038\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\200\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\039\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\040\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\032\000\041\002\000\000\
\\139\000\045\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\052\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\098\000\055\002\099\000\054\002\101\000\053\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\094\000\061\002\095\000\060\002\098\000\055\002\
\\099\000\059\002\101\000\058\002\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\040\000\060\001\056\000\063\002\000\000\
\\000\000\
\\000\000\
\\071\000\065\002\075\000\006\000\139\000\001\000\000\000\
\\048\000\065\001\049\000\064\001\051\000\066\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\068\002\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\070\002\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\068\000\071\002\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\072\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\068\000\073\002\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\064\000\075\002\065\000\008\000\071\000\110\000\072\000\074\002\
\\075\000\006\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\026\002\075\000\006\000\139\000\001\000\000\000\
\\064\000\078\002\065\000\008\000\071\000\110\000\072\000\077\002\
\\075\000\006\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\032\000\041\002\000\000\
\\064\000\154\001\065\000\008\000\080\000\151\001\127\000\003\000\
\\128\000\002\000\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\080\002\
\\126\000\119\001\000\000\
\\139\000\081\002\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\082\002\
\\126\000\119\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\094\000\061\002\095\000\060\002\101\000\083\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\085\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\091\001\055\000\087\002\000\000\
\\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\089\002\126\000\119\001\136\000\088\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\095\002\126\000\119\001\136\000\088\002\000\000\
\\064\000\096\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\097\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\039\000\144\000\059\000\098\002\000\000\
\\000\000\
\\139\000\099\002\000\000\
\\139\000\100\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\101\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\102\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\139\000\117\002\000\000\
\\139\000\118\002\000\000\
\\044\000\121\002\046\000\120\002\048\000\119\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\123\002\126\000\119\001\136\000\088\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\124\002\126\000\119\001\136\000\088\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\125\002\126\000\119\001\136\000\088\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\126\002\126\000\119\001\136\000\088\002\000\000\
\\064\000\151\000\065\000\008\000\067\000\127\002\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\129\002\060\000\128\002\000\000\
\\039\000\091\001\055\000\090\001\057\000\132\002\000\000\
\\027\000\134\002\029\000\133\002\000\000\
\\039\000\091\001\055\000\090\001\057\000\137\002\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\139\002\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\140\002\126\000\119\001\000\000\
\\048\000\122\001\089\000\141\002\126\000\119\001\000\000\
\\000\000\
\\064\000\175\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\177\002\048\000\119\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\179\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\180\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\016\000\168\000\019\000\181\002\020\000\159\000\000\000\
\\039\000\185\002\064\000\184\002\065\000\008\000\076\000\183\002\
\\077\000\182\002\127\000\003\000\128\000\002\000\000\000\
\\039\000\185\002\064\000\184\002\065\000\008\000\076\000\183\002\
\\077\000\186\002\127\000\003\000\128\000\002\000\000\000\
\\064\000\151\000\065\000\008\000\067\000\187\002\127\000\003\000\
\\128\000\002\000\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\188\002\126\000\119\001\136\000\088\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\189\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\123\000\175\000\124\000\190\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\193\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\194\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\195\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\196\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\041\000\187\000\042\000\198\002\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\185\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\140\000\199\002\000\000\
\\140\000\200\002\000\000\
\\136\000\201\002\000\000\
\\136\000\203\002\000\000\
\\000\000\
\\140\000\205\002\000\000\
\\000\000\
\\000\000\
\\140\000\208\002\000\000\
\\048\000\122\001\089\000\215\002\107\000\092\002\108\000\214\002\
\\109\000\213\002\110\000\091\002\111\000\212\002\112\000\090\002\
\\113\000\211\002\115\000\210\002\126\000\119\001\136\000\209\002\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\216\002\126\000\119\001\136\000\088\002\000\000\
\\000\000\
\\000\000\
\\045\000\164\001\047\000\218\002\048\000\065\001\049\000\162\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\220\002\126\000\119\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\222\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\223\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\224\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\228\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\065\000\128\000\133\000\127\000\134\000\229\002\000\000\
\\064\000\230\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\231\002\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\232\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\091\001\055\000\090\001\057\000\233\002\000\000\
\\039\000\234\002\000\000\
\\106\000\236\002\114\000\235\002\139\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\244\002\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\039\000\246\002\054\000\245\002\000\000\
\\071\000\247\002\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\106\000\236\002\114\000\249\002\139\000\107\001\000\000\
\\106\000\236\002\114\000\250\002\139\000\109\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\000\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\002\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\031\000\003\003\000\000\
\\039\000\091\001\055\000\090\001\057\000\005\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\017\000\210\001\018\000\010\003\000\000\
\\015\000\011\003\020\000\212\001\000\000\
\\027\000\013\003\028\000\012\003\000\000\
\\000\000\
\\000\000\
\\086\000\215\001\087\000\016\003\000\000\
\\048\000\122\001\089\000\121\001\091\000\018\003\126\000\119\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\020\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\021\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\236\002\114\000\027\003\139\000\138\001\000\000\
\\071\000\028\003\075\000\006\000\139\000\001\000\000\000\
\\048\000\122\001\089\000\029\003\126\000\119\001\000\000\
\\071\000\030\003\075\000\006\000\139\000\001\000\000\000\
\\071\000\031\003\075\000\006\000\139\000\001\000\000\000\
\\071\000\032\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\236\001\075\000\006\000\081\000\039\003\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\070\000\040\003\071\000\007\000\
\\075\000\006\000\082\000\237\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\042\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\116\000\046\003\118\000\045\003\000\000\
\\116\000\046\003\118\000\047\003\000\000\
\\104\000\049\003\105\000\048\003\139\000\160\001\000\000\
\\045\000\164\001\047\000\051\003\048\000\065\001\049\000\162\001\000\000\
\\045\000\164\001\047\000\052\003\048\000\065\001\049\000\162\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\053\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\054\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\116\000\046\003\118\000\056\003\000\000\
\\116\000\046\003\118\000\057\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\058\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\002\000\059\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\061\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\063\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\065\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\002\000\066\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\065\000\128\000\133\000\127\000\134\000\083\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\070\000\072\003\071\000\007\000\
\\075\000\006\000\082\000\237\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\097\000\016\002\100\000\077\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\101\000\078\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\093\000\019\002\096\000\080\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\101\000\081\003\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\040\000\060\001\056\000\059\001\058\000\082\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\083\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\084\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\085\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\140\000\086\003\000\000\
\\140\000\087\003\000\000\
\\032\000\088\003\000\000\
\\044\000\121\002\046\000\089\003\048\000\119\002\000\000\
\\084\000\038\001\085\000\090\003\000\000\
\\044\000\121\002\046\000\091\003\048\000\119\002\000\000\
\\002\000\093\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\094\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\095\003\083\000\171\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\099\003\003\000\026\000\004\000\025\000\005\000\024\000\
\\006\000\023\000\007\000\022\000\008\000\021\000\009\000\020\000\
\\010\000\019\000\012\000\018\000\013\000\017\000\014\000\016\000\
\\021\000\015\000\022\000\014\000\023\000\013\000\024\000\012\000\
\\025\000\011\000\026\000\010\000\064\000\009\000\065\000\008\000\
\\071\000\007\000\075\000\006\000\082\000\005\000\125\000\004\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\065\000\128\000\133\000\051\001\135\000\100\003\000\000\
\\048\000\122\001\089\000\121\001\091\000\101\003\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\086\000\215\001\087\000\104\003\000\000\
\\064\000\009\000\065\000\008\000\068\000\105\003\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\140\000\107\003\000\000\
\\136\000\108\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\110\003\000\000\
\\140\000\111\003\000\000\
\\136\000\112\003\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\113\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\114\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\032\000\115\003\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\117\003\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\064\000\111\000\065\000\008\000\071\000\110\000\072\000\109\000\
\\073\000\108\000\074\000\118\003\075\000\006\000\127\000\003\000\
\\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\120\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\122\003\000\000\
\\048\000\122\001\089\000\124\003\108\000\214\002\109\000\213\002\
\\111\000\212\002\113\000\211\002\126\000\119\001\136\000\123\003\000\000\
\\140\000\125\003\000\000\
\\000\000\
\\064\000\127\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\128\003\000\000\
\\000\000\
\\048\000\122\001\089\000\129\003\126\000\119\001\000\000\
\\140\000\130\003\000\000\
\\000\000\
\\110\000\091\002\112\000\131\003\136\000\088\002\000\000\
\\110\000\091\002\112\000\132\003\136\000\088\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\135\003\000\000\
\\064\000\136\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\071\000\153\001\075\000\006\000\079\000\152\001\139\000\001\000\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\137\003\
\\126\000\119\001\000\000\
\\139\000\138\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\139\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\140\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\141\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\142\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\143\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\144\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\145\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\040\000\148\003\064\000\147\003\065\000\008\000\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\097\000\016\002\100\000\015\002\000\000\
\\000\000\
\\000\000\
\\048\000\065\001\049\000\064\001\051\000\150\003\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\151\003\
\\126\000\119\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\098\000\055\002\099\000\059\002\101\000\053\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\153\003\048\000\119\002\000\000\
\\000\000\
\\140\000\154\003\000\000\
\\000\000\
\\140\000\156\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\144\000\059\000\159\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\136\000\163\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\169\003\102\000\168\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\171\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\172\003\126\000\119\001\000\000\
\\044\000\173\003\048\000\119\002\000\000\
\\044\000\174\003\048\000\119\002\000\000\
\\044\000\175\003\048\000\119\002\000\000\
\\044\000\176\003\048\000\119\002\000\000\
\\044\000\177\003\048\000\119\002\000\000\
\\044\000\178\003\048\000\119\002\000\000\
\\044\000\179\003\048\000\119\002\000\000\
\\000\000\
\\000\000\
\\044\000\182\003\048\000\119\002\000\000\
\\000\000\
\\044\000\184\003\048\000\119\002\000\000\
\\044\000\185\003\048\000\119\002\000\000\
\\044\000\186\003\048\000\119\002\000\000\
\\000\000\
\\048\000\122\001\089\000\188\003\103\000\187\003\126\000\119\001\000\000\
\\044\000\189\003\048\000\119\002\000\000\
\\044\000\190\003\048\000\119\002\000\000\
\\044\000\191\003\048\000\119\002\000\000\
\\000\000\
\\044\000\193\003\048\000\119\002\000\000\
\\044\000\194\003\048\000\119\002\000\000\
\\000\000\
\\048\000\122\001\089\000\196\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\197\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\198\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\199\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\200\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\201\003\126\000\119\001\000\000\
\\048\000\122\001\089\000\169\003\102\000\202\003\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\206\003\000\000\
\\136\000\207\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\139\000\211\003\000\000\
\\140\000\213\003\000\000\
\\071\000\214\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\181\000\141\000\215\003\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\153\001\075\000\006\000\079\000\216\003\139\000\001\000\000\000\
\\000\000\
\\064\000\154\001\065\000\008\000\080\000\217\003\127\000\003\000\
\\128\000\002\000\000\000\
\\000\000\
\\071\000\218\003\075\000\006\000\139\000\001\000\000\000\
\\048\000\122\001\089\000\158\001\117\000\157\001\119\000\219\003\
\\126\000\119\001\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\220\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\222\003\065\000\008\000\071\000\221\003\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\048\000\122\001\089\000\223\003\126\000\119\001\000\000\
\\140\000\224\003\000\000\
\\140\000\225\003\000\000\
\\000\000\
\\109\000\213\002\111\000\226\003\136\000\123\003\000\000\
\\109\000\213\002\111\000\227\003\136\000\123\003\000\000\
\\000\000\
\\000\000\
\\071\000\230\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\231\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\238\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\236\002\114\000\244\003\000\000\
\\064\000\245\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\048\000\122\001\089\000\246\003\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\248\003\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\039\000\246\002\054\000\250\003\000\000\
\\000\000\
\\044\000\121\002\046\000\252\003\048\000\119\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\000\004\129\000\255\003\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\199\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\061\000\007\004\000\000\
\\000\000\
\\039\000\091\001\055\000\090\001\057\000\011\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\027\000\013\003\028\000\014\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\017\004\048\000\119\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\022\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\025\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\029\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\030\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\116\000\046\003\118\000\033\004\000\000\
\\000\000\
\\000\000\
\\104\000\049\003\105\000\036\004\000\000\
\\048\000\122\001\089\000\037\004\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\042\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\051\004\126\000\119\001\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\053\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\055\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\056\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\040\000\059\004\053\000\058\004\000\000\
\\000\000\
\\071\000\061\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\062\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\064\004\065\000\008\000\071\000\063\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\068\004\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\069\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\197\000\083\000\169\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\032\000\072\004\033\000\071\004\000\000\
\\032\000\072\004\033\000\073\004\000\000\
\\000\000\
\\140\000\074\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\077\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\071\000\079\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\098\000\055\002\099\000\080\004\101\000\053\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\064\000\081\004\065\000\008\000\071\000\079\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\056\002\094\000\061\002\095\000\082\004\101\000\083\002\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\040\000\059\004\053\000\083\004\000\000\
\\039\000\085\004\052\000\084\004\000\000\
\\000\000\
\\000\000\
\\140\000\087\004\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\068\000\089\004\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\222\003\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\048\000\122\001\089\000\092\004\126\000\119\001\000\000\
\\000\000\
\\064\000\064\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\081\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\095\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\096\004\126\000\119\001\136\000\088\002\000\000\
\\000\000\
\\140\000\097\004\000\000\
\\048\000\122\001\089\000\093\002\107\000\092\002\110\000\091\002\
\\112\000\090\002\115\000\210\002\126\000\119\001\136\000\088\002\000\000\
\\106\000\236\002\114\000\235\002\000\000\
\\071\000\099\004\075\000\006\000\139\000\001\000\000\000\
\\106\000\236\002\114\000\249\002\000\000\
\\106\000\236\002\114\000\250\002\000\000\
\\106\000\236\002\114\000\027\003\000\000\
\\071\000\100\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\101\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\071\000\103\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\083\003\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\105\004\075\000\006\000\139\000\001\000\000\000\
\\140\000\106\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\109\004\037\000\108\004\000\000\
\\000\000\
\\031\000\113\004\035\000\112\004\000\000\
\\031\000\113\004\035\000\114\004\000\000\
\\000\000\
\\027\000\134\002\029\000\115\004\000\000\
\\031\000\119\004\034\000\118\004\038\000\117\004\039\000\116\004\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\121\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\169\003\102\000\123\004\126\000\119\001\000\000\
\\064\000\124\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\048\000\122\001\089\000\126\004\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\169\003\102\000\142\004\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\146\004\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\149\004\126\000\119\001\000\000\
\\048\000\122\001\089\000\150\004\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\157\004\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\159\004\126\000\119\001\000\000\
\\000\000\
\\039\000\185\002\064\000\184\002\065\000\008\000\076\000\183\002\
\\077\000\160\004\127\000\003\000\128\000\002\000\000\000\
\\071\000\161\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\162\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\039\000\185\002\064\000\184\002\065\000\008\000\076\000\183\002\
\\077\000\163\004\127\000\003\000\128\000\002\000\000\000\
\\039\000\185\002\064\000\184\002\065\000\008\000\076\000\183\002\
\\077\000\164\004\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\166\004\065\000\008\000\071\000\095\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\167\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\168\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\170\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\106\000\236\002\114\000\171\004\139\000\135\003\000\000\
\\071\000\172\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\174\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\000\004\129\000\177\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\179\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\039\000\091\001\055\000\090\001\057\000\181\004\000\000\
\\031\000\113\004\035\000\114\004\000\000\
\\031\000\182\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\017\004\048\000\119\002\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\186\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\192\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\071\000\194\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\064\000\195\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\196\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\197\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\198\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\071\000\199\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\200\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\201\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\205\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\208\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\071\000\209\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\032\000\072\004\033\000\214\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\218\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\219\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\068\000\221\004\071\000\007\000\
\\075\000\006\000\082\000\054\001\127\000\003\000\128\000\002\000\
\\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\166\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\071\000\225\004\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\140\000\226\004\000\000\
\\071\000\221\003\075\000\006\000\139\000\001\000\000\000\
\\064\000\227\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\228\004\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\229\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\071\000\063\004\075\000\006\000\139\000\001\000\000\000\
\\064\000\230\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\031\000\109\004\037\000\232\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\113\004\035\000\234\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\119\004\034\000\118\004\038\000\238\004\039\000\116\004\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\246\004\065\000\008\000\071\000\245\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\140\000\249\004\000\000\
\\000\000\
\\064\000\251\004\065\000\008\000\071\000\225\004\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\002\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\003\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\004\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\006\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\061\000\010\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\014\005\065\000\008\000\071\000\013\005\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\017\005\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\027\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\040\000\059\004\053\000\030\005\000\000\
\\000\000\
\\064\000\032\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\034\005\065\000\008\000\071\000\033\005\075\000\006\000\
\\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\036\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\048\000\122\001\089\000\121\001\091\000\037\005\126\000\119\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\251\004\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\106\000\236\002\114\000\171\004\000\000\
\\071\000\192\004\075\000\006\000\139\000\001\000\000\000\
\\071\000\042\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\031\000\044\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\071\000\046\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\047\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\199\000\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\031\000\109\004\037\000\053\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\055\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\048\000\122\001\089\000\121\001\091\000\059\005\126\000\119\001\000\000\
\\000\000\
\\071\000\060\005\075\000\006\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\065\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\031\000\067\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\126\000\070\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\079\005\048\000\119\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\082\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\131\000\083\005\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\085\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\064\000\086\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\031\000\087\005\000\000\
\\031\000\109\004\037\000\088\005\000\000\
\\044\000\121\002\046\000\089\005\048\000\119\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\091\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\094\005\048\000\119\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\097\005\132\000\096\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\044\000\121\002\046\000\106\005\048\000\119\002\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\108\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\000\000\
\\000\000\
\\064\000\009\000\065\000\008\000\071\000\007\000\075\000\006\000\
\\082\000\111\005\127\000\003\000\128\000\002\000\139\000\001\000\000\000\
\\043\000\112\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\027\001\065\000\008\000\066\000\116\005\127\000\003\000\
\\128\000\002\000\000\000\
\\043\000\118\005\132\000\117\005\000\000\
\\000\000\
\\130\000\122\005\000\000\
\\031\000\124\005\000\000\
\\064\000\125\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\064\000\129\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\132\005\000\000\
\\000\000\
\\000\000\
\\043\000\136\005\000\000\
\\000\000\
\\000\000\
\\043\000\141\005\132\000\140\005\000\000\
\\000\000\
\\000\000\
\\043\000\146\005\132\000\145\005\000\000\
\\000\000\
\\000\000\
\\064\000\149\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\064\000\150\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\064\000\151\005\065\000\008\000\127\000\003\000\128\000\002\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\153\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\156\005\000\000\
\\000\000\
\\043\000\158\005\000\000\
\\000\000\
\\000\000\
\\043\000\161\005\000\000\
\\000\000\
\\043\000\163\005\000\000\
\\000\000\
\\043\000\168\005\132\000\167\005\000\000\
\\130\000\171\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\177\005\000\000\
\\000\000\
\\043\000\180\005\000\000\
\\000\000\
\\000\000\
\\043\000\185\005\132\000\184\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\190\005\000\000\
\\000\000\
\\000\000\
\\043\000\193\005\000\000\
\\000\000\
\\043\000\195\005\000\000\
\\000\000\
\\000\000\
\\043\000\198\005\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 1485
val numrules = 548
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle General.Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(List.map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int*int
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | CHARACTER of unit ->  (int) | STRING of unit ->  (int list)
 | ID of unit ->  (string) | ANY_ID of unit ->  (string)
 | PRIVATE_ID of unit ->  (string)
 | param_asgn_exp_list of unit ->  ( ( A.param * A.expression )  list)
 | rcb of unit ->  (unit) | lcb of unit ->  (unit)
 | phrase_pair_list of unit ->  ( ( A.phrase * A.phrase * A.pos * A.pos * A.pos )  list)
 | phrase_pair of unit ->  ( ( A.phrase * A.phrase * A.pos * A.pos * A.pos ) )
 | single_logical_or of unit ->  (unit)
 | one_or_more_mod_symbols_infix of unit ->  ( ( A.mod_symbol * A.pos )  list)
 | one_or_more_mod_symbols of unit ->  ( ( A.mod_symbol * A.pos )  list)
 | one_mod_symbol of unit ->  (A.mod_symbol*A.pos)
 | associativity of unit ->  (bool)
 | sb_declaration_prec_assoc of unit ->  ({ overload_sym:A.param option,precedence:int option,assoc:bool option,input_transformer:A.expression list option } )
 | declaration_prec_assoc of unit ->  ({ overload_sym:A.param option,precedence:int option,assoc:bool option,input_transformer:A.expression list option } )
 | one_or_more_athena_vars of unit ->  (AthTermVar.ath_term_var list)
 | athena_meta_id of unit ->  (A.expression)
 | ath_var of unit ->  (A.expression)
 | athena_var of unit ->  (AthTermVar.ath_term_var)
 | symbol_definition of unit ->  (A.absyn_symbol_definition)
 | assignments of unit ->  (A.binding list)
 | assignment of unit ->  (A.binding)
 | semicolon_separated_expressions of unit ->  (A.expression list)
 | semicolon_separated_deductions of unit ->  (A.deduction list)
 | semicolon_separated_phrases of unit ->  (A.phrase list)
 | semicolon_separated_bindings of unit ->  (A.binding list)
 | bindings of unit ->  (A.binding list)
 | binding_assignment of unit ->  (A.binding)
 | binding of unit ->  (A.binding)
 | infix_dmatch_clauses of unit ->  (A.dmatch_clause list)
 | dmatch_clauses of unit ->  (A.dmatch_clause list)
 | infix_match_clauses of unit ->  (A.match_clause list)
 | sep_infix_dmatch_clauses of unit ->  (A.dmatch_clause list)
 | sep_infix_match_clauses of unit ->  (A.match_clause list)
 | sep_infix_dmatch_clause of unit ->  (A.dmatch_clause)
 | sep_infix_match_clause of unit ->  (A.match_clause)
 | infix_match_clause of unit ->  (A.match_clause)
 | infix_dmatch_clause of unit ->  (A.dmatch_clause)
 | dmatch_clause of unit ->  (A.dmatch_clause)
 | match_clauses of unit ->  (A.match_clause list)
 | match_clause of unit ->  (A.match_clause)
 | two_or_more_patterns of unit ->  (A.pattern list)
 | one_or_more_patterns of unit ->  (A.pattern list)
 | condition of unit ->  (A.condition)
 | dcheck_clauses of unit ->  (A.dcheck_clause list)
 | infix_dcheck_clauses of unit ->  (A.dcheck_clause list)
 | infix_dcheck_clause of unit ->  (A.dcheck_clause)
 | dcheck_clause of unit ->  (A.dcheck_clause)
 | check_clauses of unit ->  (A.check_clause list)
 | infix_check_clauses of unit ->  (A.check_clause list)
 | infix_check_clause of unit ->  (A.check_clause)
 | check_clause of unit ->  (A.check_clause)
 | struc_patterns of unit ->  (A.pattern list)
 | patterns of unit ->  (A.pattern list)
 | struc_pattern of unit ->  (A.pattern)
 | pattern of unit ->  (A.pattern)
 | definitions of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | def_blocks of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | def_block of unit ->  (A.possibly_typed_param*A.expression)
 | infix_def_blocks of unit ->  ( ( A.possibly_typed_param * A.expression )  list)
 | infix_def_block of unit ->  (A.possibly_typed_param*A.expression)
 | phrases of unit ->  (A.phrase list) | phrase of unit ->  (A.phrase)
 | one_or_more_deductions of unit ->  (A.deduction list)
 | one_or_more_separated_expressions of unit ->  (A.expression list)
 | one_or_more_separated_deductions of unit ->  (A.deduction list)
 | deductions of unit ->  (A.deduction list)
 | case_clauses of unit ->  (A.case_clause list)
 | case_clause of unit ->  (A.case_clause)
 | inference_block of unit ->  (A.deduction)
 | inference_list of unit ->  (A.optBinding list)
 | possibly_named_inference of unit ->  (A.optBinding)
 | inference of unit ->  (A.deduction)
 | deduction of unit ->  (A.deduction)
 | one_or_more_phrases of unit ->  (A.phrase list)
 | opt_comma_separated_phrase_list of unit ->  (A.phrase list)
 | comma_separated_phrase_list of unit ->  (A.phrase list)
 | comma_separated_expression_list of unit ->  (A.expression list)
 | one_or_more_expressions of unit ->  (A.expression list)
 | any_id of unit ->  (string) | expression of unit ->  (A.expression)
 | one_or_more_ids of unit ->  (string list)
 | bracket_enclosed_possible_obtype_params of unit ->  (A.param list)
 | possible_obtype_params of unit ->  (A.param list)
 | comma_separated_possible_obtype_params of unit ->  (A.param list)
 | one_or_more_comma_separated_params of unit ->  (A.param list)
 | one_or_more_params_no_dots of unit ->  (A.param list)
 | one_or_more_params of unit ->  (A.param list)
 | one_or_more_params_maybe_with_reps_no_dots of unit ->  (A.param list)
 | one_or_more_params_maybe_with_reps of unit ->  (A.param list)
 | params of unit ->  (A.param list)
 | param_option_no_dots of unit ->  (S.symbol option)
 | param_option of unit ->  (S.symbol option)
 | possibly_typed_params_no_dots of unit ->  (A.possibly_typed_param list)
 | possibly_typed_params of unit ->  (A.possibly_typed_param list)
 | possibly_typed_param_no_dots of unit ->  (A.possibly_typed_param)
 | possibly_typed_param of unit ->  (A.possibly_typed_param)
 | possibly_wildcard_param_list_no_dots of unit ->  (A.possibly_wildcard_param list)
 | possibly_wildcard_param_list of unit ->  (A.possibly_wildcard_param list)
 | possibly_wildcard_param_no_dots of unit ->  (A.possibly_wildcard_param)
 | possibly_wildcard_param of unit ->  (A.possibly_wildcard_param)
 | input_transformer_declaration of unit ->  (A.expression list)
 | map_bindings of unit ->  (A.phrase list)
 | map_binding of unit ->  (A.phrase)
 | param_no_dots of unit ->  (A.param) | param of unit ->  (A.param)
 | selector_tagged_athena_object_type_list of unit ->  ( ( A.param option * A.absyn_term )  list)
 | athena_object_type_list of unit ->  (A.absyn_term list)
 | one_or_more_selector_tagged_athena_object_types of unit ->  ( ( A.param option * A.absyn_term )  list)
 | one_or_more_athena_object_types of unit ->  (A.absyn_term list)
 | selector_tagged_athena_object_type of unit ->  ( ( A.param option * A.absyn_term ) )
 | one_or_more_user_sorts of unit ->  (A.absyn_term list)
 | user_sort of unit ->  (A.absyn_term)
 | athena_object_type of unit ->  (A.absyn_term)
 | one_or_more_type_vars of unit ->  (A.param list)
 | infix_one_or_more_ath_structure_constructors of unit ->  (A.absyn_structure_constructor list)
 | one_or_more_ath_structure_constructors of unit ->  (A.absyn_structure_constructor list)
 | ath_structure_constructor of unit ->  (A.absyn_structure_constructor)
 | ath_fsym of unit ->  (A.absyn_fsym list)
 | ath_constant_sym of unit ->  (A.absyn_fsym list)
 | subsorts of unit ->  ( ( A.mod_symbol * A.pos )  list* ( A.mod_symbol * A.pos ) )
 | subsort of unit ->  (A.mod_symbol*A.pos*A.mod_symbol*A.pos)
 | ath_domains of unit ->  (A.absyn_domain list)
 | ath_domain of unit ->  (A.absyn_domain)
 | ath_structure_profile of unit ->  (A.absyn_structure_profile)
 | one_or_more_rec_ath_datatype_clauses of unit ->  (A.absyn_structure list)
 | one_or_more_rec_ath_struc_clauses of unit ->  (A.absyn_structure list)
 | rec_ath_struc_clause of unit ->  (A.absyn_structure)
 | infix_ath_struc_clause of unit ->  (A.absyn_structure)
 | ath_struc_clause of unit ->  (A.absyn_structure)
 | infix_ath_datatypes of unit ->  (A.absyn_structure list)
 | ath_datatypes of unit ->  (A.absyn_structure list)
 | ath_structures of unit ->  (A.absyn_structure list)
 | infix_ath_structure of unit ->  (A.absyn_structure)
 | infix_ath_datatype of unit ->  (A.absyn_structure)
 | ath_datatype of unit ->  (A.absyn_structure)
 | ath_structure of unit ->  (A.absyn_structure)
 | directive of unit ->  (A.directive)
 | core_user_input of unit ->  (A.user_input)
 | user_input of unit ->  (A.user_input)
 | moduleExtension of unit ->  (A.module_entry)
 | module of unit ->  (A.module_entry)
 | input_list of unit ->  (A.user_input list)
 | input_stream of unit ->  (A.user_input list)
end
type svalue = MlyValue.svalue
type result = A.user_input list
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn (T 92) => true | (T 94) => true | (T 76) => true | (T 98) => true
 | (T 99) => true | (T 74) => true | (T 75) => true | _ => false
val preferred_change : (term list * term list) list = 
(nil
,nil
 $$ (T 63))::
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "PICK_ANY"
  | (T 2) => "PICK_WITNESS"
  | (T 3) => "PICK_WITNESSES"
  | (T 4) => "CHECK"
  | (T 5) => "DCHECK"
  | (T 6) => "ELSE"
  | (T 7) => "THEN"
  | (T 8) => "LOGICAL_AND"
  | (T 9) => "LOGICAL_OR"
  | (T 10) => "OP"
  | (T 11) => "EXPAND_INPUT"
  | (T 12) => "PRIVATE_ID"
  | (T 13) => "PRIVATE"
  | (T 14) => "OPEN_MODULE"
  | (T 15) => "EXTEND_MODULE"
  | (T 16) => "ANY_ID"
  | (T 17) => "RE_STAR"
  | (T 18) => "RE_PLUS"
  | (T 19) => "RE_OPTIONAL"
  | (T 20) => "RE_LIT"
  | (T 21) => "RE_REP"
  | (T 22) => "RE_RANGE"
  | (T 23) => "ID"
  | (T 24) => "STRING"
  | (T 25) => "SOME_FUNCTION"
  | (T 26) => "SOME_METHOD"
  | (T 27) => "EXIT_ATHENA"
  | (T 28) => "FROM"
  | (T 29) => "FOR"
  | (T 30) => "START_LOAD"
  | (T 31) => "END_LOAD"
  | (T 32) => "TRANSFORM_OUTPUT"
  | (T 33) => "CHARACTER"
  | (T 34) => "LOAD_FILE"
  | (T 35) => "DIF_ELSE"
  | (T 36) => "NAME"
  | (T 37) => "SOME_TERM"
  | (T 38) => "COLON"
  | (T 39) => "OVERLOAD"
  | (T 40) => "OVERLOAD_INV"
  | (T 41) => "MODULE"
  | (T 42) => "DEFINE_STAR"
  | (T 43) => "DEFINE_MEMOIZED"
  | (T 44) => "SOME_ATOM"
  | (T 45) => "SOME_PROP"
  | (T 46) => "QMARK"
  | (T 47) => "EXCL_MARK"
  | (T 48) => "QUOTE_WORD"
  | (T 49) => "QUOTE_SYMBOL"
  | (T 50) => "EXPAND_NEXT_PROOF"
  | (T 51) => "LEFT_CURLY_BRACE"
  | (T 52) => "RIGHT_CURLY_BRACE"
  | (T 53) => "BACK_QUOTE_SYMBOL"
  | (T 54) => "LETREC"
  | (T 55) => "DLETREC"
  | (T 56) => "SPLIT_PAT"
  | (T 57) => "BY"
  | (T 58) => "PRINT_STACK_TRACE"
  | (T 59) => "SEMI_COLON"
  | (T 60) => "CONCLUDE"
  | (T 61) => "DOUBLE_LEFT_CURLY_BRACE"
  | (T 62) => "DOUBLE_RIGHT_CURLY_BRACE"
  | (T 63) => "LPAREN"
  | (T 64) => "RPAREN"
  | (T 65) => "COMMA"
  | (T 66) => "CLAIM"
  | (T 67) => "LEFT_BRACKET"
  | (T 68) => "RIGHT_BRACKET"
  | (T 69) => "SET"
  | (T 70) => "ARROW"
  | (T 71) => "WILDCARD"
  | (T 72) => "SOME_CHAR"
  | (T 73) => "APPLYING"
  | (T 74) => "FUNCTION"
  | (T 75) => "METHOD"
  | (T 76) => "MATCH"
  | (T 77) => "LET"
  | (T 78) => "LET_UPPER"
  | (T 79) => "DLET"
  | (T 80) => "TRY"
  | (T 81) => "DTRY"
  | (T 82) => "APPLY_METHOD"
  | (T 83) => "SOME_VAR"
  | (T 84) => "SEQ"
  | (T 85) => "DSEQ"
  | (T 86) => "SOME_VECTOR"
  | (T 87) => "MAP_BEGIN"
  | (T 88) => "MAP_END"
  | (T 89) => "EQUAL_SIGN"
  | (T 90) => "ASSERT"
  | (T 91) => "ASSERT_CLOSE"
  | (T 92) => "ASSUME"
  | (T 93) => "ASSUME_LET"
  | (T 94) => "SUPPOSE_ABSURD"
  | (T 95) => "SUPPOSE_ABSURD_LET"
  | (T 96) => "ON"
  | (T 97) => "PROVE"
  | (T 98) => "DMATCH"
  | (T 99) => "EITHER"
  | (T 100) => "ABSURD"
  | (T 101) => "MP"
  | (T 102) => "DN"
  | (T 103) => "EQUIV"
  | (T 104) => "LEFT_IFF"
  | (T 105) => "RIGHT_IFF"
  | (T 106) => "BOTH"
  | (T 107) => "ASGN"
  | (T 108) => "BY_CASES"
  | (T 109) => "FUN"
  | (T 110) => "META_ID"
  | (T 111) => "SOME_SYMBOL"
  | (T 112) => "LEFT_AND"
  | (T 113) => "RIGHT_AND"
  | (T 114) => "CD"
  | (T 115) => "VAL_OF"
  | (T 116) => "VAR"
  | (T 117) => "FUN_ARROW"
  | (T 118) => "DATATYPE"
  | (T 119) => "DATATYPES"
  | (T 120) => "DEFINE_SORT"
  | (T 121) => "SOME_LIST"
  | (T 122) => "SOME_CELL"
  | (T 123) => "SOME_SUB"
  | (T 124) => "SOME_TABLE"
  | (T 125) => "SOME_MAP"
  | (T 126) => "DEFINE"
  | (T 127) => "POUND"
  | (T 128) => "STRUCTURE"
  | (T 129) => "STRUCTURES"
  | (T 130) => "DOMAIN"
  | (T 131) => "WHERE"
  | (T 132) => "PROVIDED"
  | (T 133) => "DECLARE"
  | (T 134) => "DDECLARE"
  | (T 135) => "DIRECTIVE_PREFIX"
  | (T 136) => "EGEN"
  | (T 137) => "BEGIN"
  | (T 138) => "WHILE"
  | (T 139) => "CLEAR"
  | (T 140) => "THE"
  | (T 141) => "DEFINE_SYMBOL"
  | (T 142) => "DOMAINS"
  | (T 143) => "OVER"
  | (T 144) => "EGEN_UNIQUE"
  | (T 145) => "LEIBNIZ"
  | (T 146) => "EQ_REFLEX"
  | (T 147) => "SOME_QUANT"
  | (T 148) => "USPEC"
  | (T 149) => "FETCH"
  | (T 150) => "RETRACT"
  | (T 151) => "DEFINE_FUN"
  | (T 152) => "ADD_DEMON"
  | (T 153) => "ADD_DEMONS"
  | (T 154) => "SOME_PROP_CON"
  | (T 155) => "UNEQUAL_TERMS"
  | (T 156) => "INDUCTION"
  | (T 157) => "STRUCTURE_CASES"
  | (T 158) => "LIST"
  | (T 159) => "CELL"
  | (T 160) => "RULE"
  | (T 161) => "GEN_OVER"
  | (T 162) => "WITH_PREDICATE"
  | (T 163) => "WITH_KEYS"
  | (T 164) => "WITH_WITNESS"
  | (T 165) => "MAKE_CELL"
  | (T 166) => "REF"
  | (T 167) => "USE_TERM_PARSER"
  | (T 168) => "USE_PROP_PARSER"
  | (T 169) => "END"
  | (T 170) => "SPECIALIZE"
  | (T 171) => "SET_FLAG"
  | (T 172) => "TRUE_INTRODUCTION"
  | (T 173) => "EX_GENERALIZE"
  | (T 174) => "DATATYPE_CASES"
  | (T 175) => "DATATYPE_CASES_ON_TERM"
  | (T 176) => "SUBSORT"
  | (T 177) => "SUBSORTS"
  | (T 178) => "VECTOR_INIT"
  | (T 179) => "VECTOR_SUB"
  | (T 180) => "VECTOR_SET"
  | (T 181) => "SET_CNF_CONVERTER"
  | (T 182) => "GET_CNF_CONVERTER"
  | (T 183) => "ANY_PAT"
  | (T 184) => "SET_PRECEDENCE"
  | (T 185) => "LEFT_ASSOC"
  | (T 186) => "RIGHT_ASSOC"
  | (T 187) => "BIN_OP"
  | (T 188) => "ADD_PATH"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn (T 23) => MlyValue.ID(fn () => ("bogus")) | 
_ => MlyValue.VOID
end
val terms : term list = nil
 $$ (T 188) $$ (T 187) $$ (T 186) $$ (T 185) $$ (T 184) $$ (T 183) $$ 
(T 182) $$ (T 181) $$ (T 180) $$ (T 179) $$ (T 178) $$ (T 177) $$ (T 
176) $$ (T 175) $$ (T 174) $$ (T 173) $$ (T 172) $$ (T 171) $$ (T 170)
 $$ (T 169) $$ (T 168) $$ (T 167) $$ (T 166) $$ (T 165) $$ (T 164) $$ 
(T 163) $$ (T 162) $$ (T 161) $$ (T 160) $$ (T 159) $$ (T 158) $$ (T 
157) $$ (T 156) $$ (T 155) $$ (T 154) $$ (T 153) $$ (T 152) $$ (T 151)
 $$ (T 150) $$ (T 149) $$ (T 148) $$ (T 147) $$ (T 146) $$ (T 145) $$ 
(T 144) $$ (T 143) $$ (T 142) $$ (T 141) $$ (T 140) $$ (T 139) $$ (T 
138) $$ (T 137) $$ (T 136) $$ (T 135) $$ (T 134) $$ (T 133) $$ (T 132)
 $$ (T 131) $$ (T 130) $$ (T 129) $$ (T 128) $$ (T 127) $$ (T 126) $$ 
(T 125) $$ (T 124) $$ (T 123) $$ (T 122) $$ (T 121) $$ (T 120) $$ (T 
119) $$ (T 118) $$ (T 117) $$ (T 116) $$ (T 115) $$ (T 114) $$ (T 113)
 $$ (T 112) $$ (T 111) $$ (T 110) $$ (T 109) $$ (T 108) $$ (T 107) $$ 
(T 106) $$ (T 105) $$ (T 104) $$ (T 103) $$ (T 102) $$ (T 101) $$ (T 
100) $$ (T 99) $$ (T 98) $$ (T 97) $$ (T 96) $$ (T 95) $$ (T 94) $$ 
(T 93) $$ (T 92) $$ (T 91) $$ (T 90) $$ (T 89) $$ (T 88) $$ (T 87) $$ 
(T 86) $$ (T 85) $$ (T 84) $$ (T 83) $$ (T 82) $$ (T 81) $$ (T 80) $$ 
(T 79) $$ (T 78) $$ (T 77) $$ (T 76) $$ (T 75) $$ (T 74) $$ (T 73) $$ 
(T 72) $$ (T 71) $$ (T 70) $$ (T 69) $$ (T 68) $$ (T 67) $$ (T 66) $$ 
(T 65) $$ (T 64) $$ (T 63) $$ (T 62) $$ (T 61) $$ (T 60) $$ (T 59) $$ 
(T 58) $$ (T 57) $$ (T 56) $$ (T 55) $$ (T 54) $$ (T 53) $$ (T 52) $$ 
(T 51) $$ (T 50) $$ (T 49) $$ (T 48) $$ (T 47) $$ (T 46) $$ (T 45) $$ 
(T 44) $$ (T 43) $$ (T 42) $$ (T 41) $$ (T 40) $$ (T 39) $$ (T 38) $$ 
(T 37) $$ (T 36) $$ (T 35) $$ (T 34) $$ (T 32) $$ (T 31) $$ (T 30) $$ 
(T 29) $$ (T 28) $$ (T 27) $$ (T 26) $$ (T 25) $$ (T 22) $$ (T 21) $$ 
(T 20) $$ (T 19) $$ (T 18) $$ (T 17) $$ (T 15) $$ (T 14) $$ (T 13) $$ 
(T 11) $$ (T 10) $$ (T 9) $$ (T 8) $$ (T 7) $$ (T 6) $$ (T 5) $$ (T 4)
 $$ (T 3) $$ (T 2) $$ (T 1) $$ (T 0)end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.input_list input_list1, input_list1left, 
input_list1right)) :: rest671)) => let val  result = 
MlyValue.input_stream (fn _ => let val  (input_list as input_list1) = 
input_list1 ()
 in (input_list)
end)
 in ( LrTable.NT 0, ( result, input_list1left, input_list1right), 
rest671)
end
|  ( 1, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) :: 
rest671)) => let val  result = MlyValue.single_logical_or (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
let val res = if ID = "|" then () else raise  
                                     A.SyntaxError("the character | was expected here",SOME(getPos IDleft))
                       in res end
)
end)
 in ( LrTable.NT 135, ( result, ID1left, ID1right), rest671)
end
|  ( 2, ( ( _, ( MlyValue.user_input user_input1, user_input1left, 
user_input1right)) :: rest671)) => let val  result = 
MlyValue.input_list (fn _ => let val  (user_input as user_input1) = 
user_input1 ()
 in ([user_input])
end)
 in ( LrTable.NT 1, ( result, user_input1left, user_input1right), 
rest671)
end
|  ( 3, ( ( _, ( MlyValue.input_list input_list1, _, input_list1right)
) :: ( _, ( MlyValue.user_input user_input1, user_input1left, _)) :: 
rest671)) => let val  result = MlyValue.input_list (fn _ => let val  (
user_input as user_input1) = user_input1 ()
 val  (input_list as input_list1) = input_list1 ()
 in (user_input::input_list)
end)
 in ( LrTable.NT 1, ( result, user_input1left, input_list1right), 
rest671)
end
|  ( 4, ( ( _, ( MlyValue.core_user_input core_user_input1, 
core_user_input1left, core_user_input1right)) :: rest671)) => let val 
 result = MlyValue.user_input (fn _ => let val  (core_user_input as 
core_user_input1) = core_user_input1 ()
 in (core_user_input)
end)
 in ( LrTable.NT 4, ( result, core_user_input1left, 
core_user_input1right), rest671)
end
|  ( 5, ( ( _, ( _, _, SEMI_COLON1right)) :: ( _, ( 
MlyValue.core_user_input core_user_input1, core_user_input1left, _))
 :: rest671)) => let val  result = MlyValue.user_input (fn _ => let
 val  (core_user_input as core_user_input1) = core_user_input1 ()
 in (core_user_input)
end)
 in ( LrTable.NT 4, ( result, core_user_input1left, SEMI_COLON1right),
 rest671)
end
|  ( 6, ( ( _, ( MlyValue.ath_structure ath_structure1, 
ath_structure1left, ath_structure1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_structure as 
ath_structure1) = ath_structure1 ()
 in (A.structureInput(ath_structure))
end)
 in ( LrTable.NT 5, ( result, ath_structure1left, ath_structure1right)
, rest671)
end
|  ( 7, ( ( _, ( MlyValue.ath_datatype ath_datatype1, 
ath_datatype1left, ath_datatype1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_datatype as 
ath_datatype1) = ath_datatype1 ()
 in (A.structureInput(ath_datatype))
end)
 in ( LrTable.NT 5, ( result, ath_datatype1left, ath_datatype1right), 
rest671)
end
|  ( 8, ( ( _, ( MlyValue.infix_ath_datatype infix_ath_datatype1, 
infix_ath_datatype1left, infix_ath_datatype1right)) :: rest671)) =>
 let val  result = MlyValue.core_user_input (fn _ => let val  (
infix_ath_datatype as infix_ath_datatype1) = infix_ath_datatype1 ()
 in (A.structureInput(infix_ath_datatype))
end)
 in ( LrTable.NT 5, ( result, infix_ath_datatype1left, 
infix_ath_datatype1right), rest671)
end
|  ( 9, ( ( _, ( MlyValue.ath_datatypes ath_datatypes1, 
ath_datatypes1left, ath_datatypes1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_datatypes as 
ath_datatypes1) = ath_datatypes1 ()
 in (A.structuresInput(ath_datatypes))
end)
 in ( LrTable.NT 5, ( result, ath_datatypes1left, ath_datatypes1right)
, rest671)
end
|  ( 10, ( ( _, ( MlyValue.infix_ath_datatypes infix_ath_datatypes1, 
infix_ath_datatypes1left, infix_ath_datatypes1right)) :: rest671)) =>
 let val  result = MlyValue.core_user_input (fn _ => let val  (
infix_ath_datatypes as infix_ath_datatypes1) = infix_ath_datatypes1 ()
 in (A.structuresInput(infix_ath_datatypes))
end)
 in ( LrTable.NT 5, ( result, infix_ath_datatypes1left, 
infix_ath_datatypes1right), rest671)
end
|  ( 11, ( ( _, ( MlyValue.ath_structures ath_structures1, 
ath_structures1left, ath_structures1right)) :: rest671)) => let val  
result = MlyValue.core_user_input (fn _ => let val  (ath_structures
 as ath_structures1) = ath_structures1 ()
 in (A.structuresInput(ath_structures))
end)
 in ( LrTable.NT 5, ( result, ath_structures1left, 
ath_structures1right), rest671)
end
|  ( 12, ( ( _, ( MlyValue.module module1, module1left, module1right))
 :: rest671)) => let val  result = MlyValue.core_user_input (fn _ =>
 let val  (module as module1) = module1 ()
 in (A.moduleInput(module))
end)
 in ( LrTable.NT 5, ( result, module1left, module1right), rest671)
end
|  ( 13, ( ( _, ( MlyValue.moduleExtension moduleExtension1, 
moduleExtension1left, moduleExtension1right)) :: rest671)) => let val 
 result = MlyValue.core_user_input (fn _ => let val  (moduleExtension
 as moduleExtension1) = moduleExtension1 ()
 in (A.moduleExtension(moduleExtension))
end)
 in ( LrTable.NT 5, ( result, moduleExtension1left, 
moduleExtension1right), rest671)
end
|  ( 14, ( ( _, ( MlyValue.ath_domain ath_domain1, ath_domain1left, 
ath_domain1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_domain as ath_domain1)
 = ath_domain1 ()
 in (A.domainInput(ath_domain))
end)
 in ( LrTable.NT 5, ( result, ath_domain1left, ath_domain1right), 
rest671)
end
|  ( 15, ( ( _, ( MlyValue.ath_domains ath_domains1, ath_domains1left,
 ath_domains1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_domains as 
ath_domains1) = ath_domains1 ()
 in (A.domainsInput(ath_domains))
end)
 in ( LrTable.NT 5, ( result, ath_domains1left, ath_domains1right), 
rest671)
end
|  ( 16, ( ( _, ( MlyValue.subsort subsort1, subsort1left, 
subsort1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (subsort as subsort1) = 
subsort1 ()
 in (A.subSortDeclaration(subsort))
end)
 in ( LrTable.NT 5, ( result, subsort1left, subsort1right), rest671)

end
|  ( 17, ( ( _, ( MlyValue.subsorts subsorts1, subsorts1left, 
subsorts1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (subsorts as subsorts1) = 
subsorts1 ()
 in (A.subSortsDeclaration(subsorts))
end)
 in ( LrTable.NT 5, ( result, subsorts1left, subsorts1right), rest671)

end
|  ( 18, ( ( _, ( MlyValue.ath_fsym ath_fsym1, ath_fsym1left, 
ath_fsym1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (ath_fsym as ath_fsym1) = 
ath_fsym1 ()
 in (A.functionSymbolInput(ath_fsym))
end)
 in ( LrTable.NT 5, ( result, ath_fsym1left, ath_fsym1right), rest671)

end
|  ( 19, ( ( _, ( MlyValue.ath_constant_sym ath_constant_sym1, 
ath_constant_sym1left, ath_constant_sym1right)) :: rest671)) => let
 val  result = MlyValue.core_user_input (fn _ => let val  (
ath_constant_sym as ath_constant_sym1) = ath_constant_sym1 ()
 in (A.constantSymbolInput(ath_constant_sym))
end)
 in ( LrTable.NT 5, ( result, ath_constant_sym1left, 
ath_constant_sym1right), rest671)
end
|  ( 20, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right))
 :: rest671)) => let val  result = MlyValue.core_user_input (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 in (A.phraseInput(phrase))
end)
 in ( LrTable.NT 5, ( result, phrase1left, phrase1right), rest671)
end
|  ( 21, ( ( _, ( MlyValue.symbol_definition symbol_definition1, 
symbol_definition1left, symbol_definition1right)) :: rest671)) => let
 val  result = MlyValue.core_user_input (fn _ => let val  (
symbol_definition as symbol_definition1) = symbol_definition1 ()
 in (A.symbolDefinitionInput(symbol_definition))
end)
 in ( LrTable.NT 5, ( result, symbol_definition1left, 
symbol_definition1right), rest671)
end
|  ( 22, ( ( _, ( MlyValue.directive directive1, directive1left, 
directive1right)) :: rest671)) => let val  result = 
MlyValue.core_user_input (fn _ => let val  (directive as directive1) =
 directive1 ()
 in (A.direcInput(directive))
end)
 in ( LrTable.NT 5, ( result, directive1left, directive1right), 
rest671)
end
|  ( 23, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LOAD_FILEleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.loadFile(expression,getPos(LOAD_FILEleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 24, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, ADD_PATHleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.addPath(expression, getPos(ADD_PATHleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 25, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_phrases 
one_or_more_phrases1, _, _)) :: _ :: ( _, ( _, EXPAND_INPUTleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_phrases as 
one_or_more_phrases1) = one_or_more_phrases1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.expandInput(one_or_more_phrases,phrase,getPos(EXPAND_INPUTleft)))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 26, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, (
 MlyValue.comma_separated_phrase_list comma_separated_phrase_list1, _,
 _)) :: ( _, ( _, (EXPAND_INPUTleft as EXPAND_INPUT1left), _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.expandInput(comma_separated_phrase_list,phrase,getPos(EXPAND_INPUTleft))
)
end)
 in ( LrTable.NT 6, ( result, EXPAND_INPUT1left, phrase1right), 
rest671)
end
|  ( 27, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) ::
 rest671)) => let val  result = MlyValue.directive (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.transformOutput(phrase1,phrase2,{first_arg_pos=getPos(phrase1left),second_arg_pos=getPos(phrase2left),
                                                    overall_pos=getPos(LPARENleft)})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 28, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
TRANSFORM_OUTPUTleft as TRANSFORM_OUTPUT1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  phrase1 = 
phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.transformOutput(phrase1,phrase2,{first_arg_pos=getPos(phrase1left),second_arg_pos=getPos(phrase2left),
                                                    overall_pos=getPos(TRANSFORM_OUTPUTleft)})
)
end)
 in ( LrTable.NT 6, ( result, TRANSFORM_OUTPUT1left, phrase2right), 
rest671)
end
|  ( 29, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, OVERLOADleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(LPARENleft),
                                                            getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOADleft),{inverted=false})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 30, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, OVERLOAD_INVleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(LPARENleft),
                                                                 getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOAD_INVleft),{inverted=true})
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 31, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
OVERLOADleft as OVERLOAD1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(OVERLOADleft),
                                                getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOADleft),{inverted=false})
)
end)
 in ( LrTable.NT 6, ( result, OVERLOAD1left, phrase2right), rest671)

end
|  ( 32, ( ( _, ( MlyValue.phrase phrase2, phrase2left, phrase2right))
 :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: ( _, ( _, (
OVERLOAD_INVleft as OVERLOAD_INV1left), _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.overload([(phrase1,phrase2,getPos(OVERLOAD_INVleft),
                                                    getPos(phrase1left),getPos(phrase2left))],getPos(OVERLOAD_INVleft),{inverted=true})
)
end)
 in ( LrTable.NT 6, ( result, OVERLOAD_INV1left, phrase2right), 
rest671)
end
|  ( 33, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.phrase_pair_list phrase_pair_list1, _, _)) :: ( _, ( _, 
OVERLOADleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (phrase_pair_list
 as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOADleft),{inverted=false}))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 34, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.phrase_pair_list phrase_pair_list1, _, _)) :: ( _, ( _, 
OVERLOAD_INVleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (
phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOAD_INVleft),{inverted=true}))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 35, ( ( _, ( MlyValue.phrase_pair_list phrase_pair_list1, _, 
phrase_pair_list1right)) :: ( _, ( _, (OVERLOADleft as OVERLOAD1left),
 _)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (
A.overload(phrase_pair_list,getPos(OVERLOADleft),{inverted=false}))

end)
 in ( LrTable.NT 6, ( result, OVERLOAD1left, phrase_pair_list1right), 
rest671)
end
|  ( 36, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, ADD_DEMONleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.addDemon(expression,getPos(ADD_DEMONleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 37, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, ADD_DEMONSleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.directive (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (A.addDemons(one_or_more_expressions,getPos(ADD_DEMONSleft)))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 38, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (ADD_DEMONleft as ADD_DEMON1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.addDemon(expression,getPos(ADD_DEMONleft)))
end)
 in ( LrTable.NT 6, ( result, ADD_DEMON1left, expression1right), 
rest671)
end
|  ( 39, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.STRING 
STRING1, STRINGleft, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param as param1) = param1 ()
 val  (STRING as STRING1) = STRING1 ()
 in (
let val str = String.implode(map (Char.chr) STRING)
             in
               A.setFlag(param,(str,getPos(STRINGleft)))
             end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 40, ( ( _, ( MlyValue.STRING STRING1, STRINGleft, STRING1right))
 :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, SET_FLAG1left, _
)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (param as param1) = param1 ()
 val  (STRING as STRING1) = STRING1 ()
 in (
let val str = String.implode(map (Char.chr) STRING)
             in
               A.setFlag(param,(str,getPos(STRINGleft)))
             end
)
end)
 in ( LrTable.NT 6, ( result, SET_FLAG1left, STRING1right), rest671)

end
|  ( 41, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (LOAD_FILEleft as LOAD_FILE1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.loadFile(expression,getPos(LOAD_FILEleft)))
end)
 in ( LrTable.NT 6, ( result, LOAD_FILE1left, expression1right), 
rest671)
end
|  ( 42, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( _, (ADD_PATHleft as ADD_PATH1left), _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (expression
 as expression1) = expression1 ()
 in (A.addPath(expression, getPos(ADD_PATHleft)))
end)
 in ( LrTable.NT 6, ( result, ADD_PATH1left, expression1right), 
rest671)
end
|  ( 43, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param param1
, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (param as param1) = 
param1 ()
 in (A.useTermParser({tp_name=param,file=(!Paths.current_file)}))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 44, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param param1
, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (param as param1) = 
param1 ()
 in (A.usePropParser({pp_name=param,file=(!Paths.current_file)}))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 45, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.expandNextProof(getPos(LPARENleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 46, ( ( _, ( _, (EXPAND_NEXT_PROOFleft as EXPAND_NEXT_PROOF1left)
, EXPAND_NEXT_PROOF1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (
A.expandNextProof(getPos(EXPAND_NEXT_PROOFleft))))
 in ( LrTable.NT 6, ( result, EXPAND_NEXT_PROOF1left, 
EXPAND_NEXT_PROOF1right), rest671)
end
|  ( 47, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, (LPARENleft
 as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.exitAthena(getPos(LPARENleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 48, ( ( _, ( _, (EXIT_ATHENAleft as EXIT_ATHENA1left), 
EXIT_ATHENA1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (A.exitAthena(getPos(EXIT_ATHENAleft))))
 in ( LrTable.NT 6, ( result, EXIT_ATHENA1left, EXIT_ATHENA1right), 
rest671)
end
|  ( 49, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, 
PRINT_STACK_TRACEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => (
A.printStackTrace(getPos(PRINT_STACK_TRACEleft))))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 50, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1,
 _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (one_mod_symbol as 
one_mod_symbol1) = one_mod_symbol1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence([one_mod_symbol],expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 51, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _
)) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence(one_or_more_mod_symbols,expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 52, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, _, _)) :: ( _, (
 _, SET_PRECEDENCE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_mod_symbol as 
one_mod_symbol1) = one_mod_symbol1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence([one_mod_symbol],expression))
end)
 in ( LrTable.NT 6, ( result, SET_PRECEDENCE1left, expression1right), 
rest671)
end
|  ( 53, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, _)) :: _ :: ( _, ( _, SET_PRECEDENCE1left
, _)) :: rest671)) => let val  result = MlyValue.directive (fn _ =>
 let val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 val  (expression as expression1) = expression1 ()
 in (A.setPrecedence(one_or_more_mod_symbols,expression))
end)
 in ( LrTable.NT 6, ( result, SET_PRECEDENCE1left, expression1right), 
rest671)
end
|  ( 54, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,true))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 55, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 _, LEFT_ASSOC1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,true))
end)
 in ( LrTable.NT 6, ( result, LEFT_ASSOC1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 56, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,false))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 57, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 _, RIGHT_ASSOC1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.setAssoc(one_or_more_mod_symbols,false))
end)
 in ( LrTable.NT 6, ( result, RIGHT_ASSOC1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 58, ( ( _, ( _, (PRINT_STACK_TRACEleft as PRINT_STACK_TRACE1left)
, PRINT_STACK_TRACE1right)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => (
A.printStackTrace(getPos(PRINT_STACK_TRACEleft))))
 in ( LrTable.NT 6, ( result, PRINT_STACK_TRACE1left, 
PRINT_STACK_TRACE1right), rest671)
end
|  ( 59, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_mod_symbol one_mod_symbol1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (one_mod_symbol as one_mod_symbol1) = 
one_mod_symbol1 ()
 in (A.openModule([one_mod_symbol]))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 60, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_mod_symbols one_or_more_mod_symbols1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols as 
one_or_more_mod_symbols1) = one_or_more_mod_symbols1 ()
 in (A.openModule(one_or_more_mod_symbols))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 61, ( ( _, ( MlyValue.one_or_more_mod_symbols_infix 
one_or_more_mod_symbols_infix1, _, one_or_more_mod_symbols_infix1right
)) :: ( _, ( _, OPEN_MODULE1left, _)) :: rest671)) => let val  result
 = MlyValue.directive (fn _ => let val  (one_or_more_mod_symbols_infix
 as one_or_more_mod_symbols_infix1) = one_or_more_mod_symbols_infix1
 ()
 in (A.openModule(one_or_more_mod_symbols_infix))
end)
 in ( LrTable.NT 6, ( result, OPEN_MODULE1left, 
one_or_more_mod_symbols_infix1right), rest671)
end
|  ( 62, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.assert(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 63, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.assertClose(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 64, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.param_asgn_exp_list param_asgn_exp_list1, _, _)) :: _ :: ( _,
 ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param_asgn_exp_list as 
param_asgn_exp_list1) = param_asgn_exp_list1 ()
 in (A.assertCloseAsgn(param_asgn_exp_list))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 65, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.param param1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in (A.assertAsgn(param,expression))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 66, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, 
ASSERT1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in (A.assertAsgn(param,expression))
end)
 in ( LrTable.NT 6, ( result, ASSERT1left, expression1right), rest671)

end
|  ( 67, ( ( _, ( MlyValue.param_asgn_exp_list param_asgn_exp_list1, _
, param_asgn_exp_list1right)) :: ( _, ( _, ASSERT_CLOSE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
param_asgn_exp_list as param_asgn_exp_list1) = param_asgn_exp_list1 ()
 in (A.assertCloseAsgn(param_asgn_exp_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT_CLOSE1left, 
param_asgn_exp_list1right), rest671)
end
|  ( 68, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, ASSERT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.assert(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, ASSERT_CLOSE1left
, _)) :: rest671)) => let val  result = MlyValue.directive (fn _ =>
 let val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.assertClose(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, ASSERT_CLOSE1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 70, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: _
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (one_or_more_expressions as 
one_or_more_expressions1) = one_or_more_expressions1 ()
 in (A.retract(one_or_more_expressions))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: ( _, ( _, RETRACT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (A.retract(comma_separated_expression_list))
end)
 in ( LrTable.NT 6, ( result, RETRACT1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 72, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val sym = S.symbol(ID)
                                                    val _ = A.checkNoDots(ID,getPos IDleft)
                                                in
                                                   A.sortDefinition(sym,phrase,false)
                                                end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 73, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, DEFINE_SORT1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val sym = S.symbol(ID)
                                                    val _ = A.checkNoDots(ID,getPos IDleft)
                                                in
                                                   A.sortDefinition(sym,phrase,false)
                                                end
)
end)
 in ( LrTable.NT 6, ( result, DEFINE_SORT1left, phrase1right), rest671
)
end
|  ( 74, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let 
                                               val sym = S.symbol(ID)
                                               val _ = A.checkNoDots(ID,getPos IDleft)

                                           in
                                              A.definition(sym,phrase,false)
                                           end
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 75, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,true)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 76, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.definitions([A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})],false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, expression1right), rest671)

end
|  ( 77, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos 
	      IDleft);
	      A.definitions([A.makeMethodDefinition({meth_name={name=S.symbol(ID),
	                                                       pos=getPos IDleft,
						     	       sort_as_sym_term=NONE,
                                               	     	       sort_as_fterm=NONE,
						     	       sort_as_exp=NONE,
						     	       op_tag=NONE},
					             meth_params=possibly_wildcard_param_list,	
						     meth_body=deduction,
						     pos=getPos IDleft,
						     file=(!Paths.current_file)})],false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, deduction1right), rest671)

end
|  ( 78, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, DEFINE_MEMOIZED1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => let val  (ID as ID1)
 = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
	        if (length(possibly_wildcard_param_list) < 1)
		   then raise A.SyntaxError("Procedures of zero arguments cannot be memoized",SOME (A.posOfExp(expression)))
                else ();
	        let val p:A.phrase = A.makeMemoizedFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                                                  fun_params=possibly_wildcard_param_list,
 		                                                  fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
                    val _ = print("\nThe memoized definition was desugared into this: " ^ (A.unparsePhrase p))								   
                in
                    A.definition(Symbol.symbol(ID),p,false)
                end
)
end)
 in ( LrTable.NT 6, ( result, DEFINE_MEMOIZED1left, expression1right),
 rest671)
end
|  ( 79, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: 
( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,false))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 80, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)
) :: ( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _
, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,false)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 81, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: 
( _, ( _, LEFT_BRACKETleft, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)
) :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,true))

end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 82, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: _ :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)
) :: ( _, ( _, LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _
, _)) :: _ :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,true)
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 83, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, DEFINE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 84, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _, ( _, PRIVATE1left, _))
 :: rest671)) => let val  result = MlyValue.directive (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.checkNoDots(ID,getPos IDleft);A.definition(S.symbol(ID),phrase,true)
)
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 85, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: ( _, ( _, DEFINE1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (patterns as 
patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,false))

end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 86, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: (
 _, ( _, DEFINE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),
                                                                                                           phrase,getPos LEFT_BRACKETleft,false)
)
end)
 in ( LrTable.NT 6, ( result, DEFINE1left, phrase1right), rest671)
end
|  ( 87, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( _, PRIVATE1left, _)) :: rest671))
 => let val  result = MlyValue.directive (fn _ => let val  (patterns
 as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,NONE,phrase,getPos LEFT_BRACKETleft,true))

end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 88, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: _
 :: _ :: ( _, ( MlyValue.patterns patterns1, _, _)) :: ( _, ( _, 
LEFT_BRACKETleft, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: _
 :: ( _, ( _, PRIVATE1left, _)) :: rest671)) => let val  result = 
MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (patterns as patterns1) = patterns1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.definitionLst(patterns,SOME(Symbol.symbol ID),phrase,getPos LEFT_BRACKETleft,true)
)
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, phrase1right), rest671)

end
|  ( 89, ( ( _, ( _, CLEAR1left, CLEAR1right)) :: rest671)) => let
 val  result = MlyValue.directive (fn _ => (A.clear_assum_base))
 in ( LrTable.NT 6, ( result, CLEAR1left, CLEAR1right), rest671)
end
|  ( 90, ( ( _, ( _, _, RPAREN1right)) :: _ :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.directive (fn _ => (
A.clear_assum_base))
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 91, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.def_blocks 
def_blocks1, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.directive (fn _ => let val  (def_blocks
 as def_blocks1) = def_blocks1 ()
 in (A.definitions(def_blocks,false))
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 92, ( ( _, ( MlyValue.infix_def_blocks infix_def_blocks1, _, 
infix_def_blocks1right)) :: ( _, ( _, DEFINE_STAR1left, _)) :: rest671
)) => let val  result = MlyValue.directive (fn _ => let val  (
infix_def_blocks as infix_def_blocks1) = infix_def_blocks1 ()
 in (A.definitions(infix_def_blocks,false))
end)
 in ( LrTable.NT 6, ( result, DEFINE_STAR1left, infix_def_blocks1right
), rest671)
end
|  ( 93, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.def_blocks 
def_blocks1, _, _)) :: _ :: _ :: ( _, ( _, PRIVATE1left, _)) :: 
rest671)) => let val  result = MlyValue.directive (fn _ => let val  (
def_blocks as def_blocks1) = def_blocks1 ()
 in (A.definitions(def_blocks,true))
end)
 in ( LrTable.NT 6, ( result, PRIVATE1left, RPAREN1right), rest671)

end
|  ( 94, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.directive
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.ruleDefinition(S.symbol(ID),A.functionExp({params=possibly_wildcard_param_list,
	       body=expression,pos=getPos IDleft}))
)
end)
 in ( LrTable.NT 6, ( result, LPAREN1left, RPAREN2right), rest671)
end
|  ( 95, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: _ :: ( _, ( _, RULE1left, _)) :: rest671)) => let val  
result = MlyValue.directive (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.ruleDefinition(S.symbol(ID),A.functionExp({params=possibly_wildcard_param_list,
	       body=expression,pos=getPos IDleft}))
)
end)
 in ( LrTable.NT 6, ( result, RULE1left, expression1right), rest671)

end
|  ( 96, ( ( _, ( MlyValue.expression expression1, _, expression1right
)) :: _ :: ( _, ( MlyValue.param param1, param1left, _)) :: rest671))
 => let val  result = MlyValue.param_asgn_exp_list (fn _ => let val  (
param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 in ([(param,expression)])
end)
 in ( LrTable.NT 140, ( result, param1left, expression1right), rest671
)
end
|  ( 97, ( ( _, ( MlyValue.param_asgn_exp_list param_asgn_exp_list1, _
, param_asgn_exp_list1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.param param1, param1left,
 _)) :: rest671)) => let val  result = MlyValue.param_asgn_exp_list
 (fn _ => let val  (param as param1) = param1 ()
 val  (expression as expression1) = expression1 ()
 val  (param_asgn_exp_list as param_asgn_exp_list1) = 
param_asgn_exp_list1 ()
 in ((param,expression)::param_asgn_exp_list)
end)
 in ( LrTable.NT 140, ( result, param1left, param_asgn_exp_list1right)
, rest671)
end
|  ( 98, ( ( _, ( MlyValue.any_id any_id1, (any_idleft as any_id1left)
, any_id1right)) :: rest671)) => let val  result = 
MlyValue.one_mod_symbol (fn _ => let val  (any_id as any_id1) = 
any_id1 ()
 in (
let val id_pos = getPos(any_idleft)
                        in
                          (A.makeMS(any_id,SOME id_pos),id_pos)
                        end
)
end)
 in ( LrTable.NT 132, ( result, any_id1left, any_id1right), rest671)

end
|  ( 99, ( ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, one_mod_symbol1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_mod_symbols (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 in ([one_mod_symbol])
end)
 in ( LrTable.NT 133, ( result, one_mod_symbol1left, 
one_mod_symbol1right), rest671)
end
|  ( 100, ( ( _, ( MlyValue.one_or_more_mod_symbols 
one_or_more_mod_symbols1, _, one_or_more_mod_symbols1right)) :: ( _, (
 MlyValue.one_mod_symbol one_mod_symbol1, one_mod_symbol1left, _)) :: 
rest671)) => let val  result = MlyValue.one_or_more_mod_symbols (fn _
 => let val  (one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 val  (one_or_more_mod_symbols as one_or_more_mod_symbols1) = 
one_or_more_mod_symbols1 ()
 in (one_mod_symbol::one_or_more_mod_symbols)
end)
 in ( LrTable.NT 133, ( result, one_mod_symbol1left, 
one_or_more_mod_symbols1right), rest671)
end
|  ( 101, ( ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, one_mod_symbol1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_mod_symbols_infix (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 in ([one_mod_symbol])
end)
 in ( LrTable.NT 134, ( result, one_mod_symbol1left, 
one_mod_symbol1right), rest671)
end
|  ( 102, ( ( _, ( MlyValue.one_or_more_mod_symbols_infix 
one_or_more_mod_symbols_infix1, _, one_or_more_mod_symbols_infix1right
)) :: _ :: ( _, ( MlyValue.one_mod_symbol one_mod_symbol1, 
one_mod_symbol1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_mod_symbols_infix (fn _ => let val  (
one_mod_symbol as one_mod_symbol1) = one_mod_symbol1 ()
 val  (one_or_more_mod_symbols_infix as one_or_more_mod_symbols_infix1
) = one_or_more_mod_symbols_infix1 ()
 in (one_mod_symbol::one_or_more_mod_symbols_infix)
end)
 in ( LrTable.NT 134, ( result, one_mod_symbol1left, 
one_or_more_mod_symbols_infix1right), rest671)
end
|  ( 103, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 104, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 105, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.def_block (fn _ => let val  (
ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 106, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.def_block (fn _ => let val  (
ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 107, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _, ( MlyValue.ID ID2
, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as 
ID1left), _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.def_block (fn _ => let val  (ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID1,getPos ID1left);
            (case (Int.fromString(ID2),Int.fromString(ID3)) of
             (SOME(i),SOME(j)) => 
               (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,j)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
            | _ => Data.genEx("Operator annotation error",
                              SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 108, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.def_block (fn _ => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeMethodDefinition({meth_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                        meth_params=possibly_wildcard_param_list,
                                        meth_body=deduction,pos= getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, deduction1right), rest671)

end
|  ( 109, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.infix_def_block (fn _
 => let val  (ID as ID1) = ID1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 110, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_def_block (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  ID2 = ID2 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
             case Int.fromString(ID2) of
               SOME(i) => 
                   (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                  sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,~1)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
             | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 111, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list possibly_wildcard_param_list1, _
, _)) :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _, ( MlyValue.ID ID2
, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as 
ID1left), _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_block (fn _ => let val  (ID as ID1) = ID1
 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.checkNoDots(ID1,getPos ID1left);
            (case (Int.fromString(ID2),Int.fromString(ID3)) of
             (SOME(i),SOME(j)) => 
               (A.makeFunDefinition({fun_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=SOME(i,j)},
                 fun_params=possibly_wildcard_param_list,
		 fun_body=expression,pos=getPos IDleft,file=(!Paths.current_file)}))
            | _ => Data.genEx("Operator annotation error",
                              SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, expression1right), rest671
)
end
|  ( 112, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_block (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                A.makeMethodDefinition({meth_name={name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,
                                               sort_as_fterm=NONE,sort_as_exp=NONE,op_tag=NONE},
                                        meth_params=possibly_wildcard_param_list,
                                        meth_body=deduction,pos= getPos IDleft,file=(!Paths.current_file)})
)
end)
 in ( LrTable.NT 83, ( result, LPAREN1left, deduction1right), rest671)

end
|  ( 113, ( ( _, ( _, LEFT_CURLY_BRACE1left, LEFT_CURLY_BRACE1right))
 :: rest671)) => let val  result = MlyValue.lcb (fn _ => ())
 in ( LrTable.NT 138, ( result, LEFT_CURLY_BRACE1left, 
LEFT_CURLY_BRACE1right), rest671)
end
|  ( 114, ( ( _, ( _, RIGHT_CURLY_BRACE1left, RIGHT_CURLY_BRACE1right)
) :: rest671)) => let val  result = MlyValue.rcb (fn _ => ())
 in ( LrTable.NT 139, ( result, RIGHT_CURLY_BRACE1left, 
RIGHT_CURLY_BRACE1right), rest671)
end
|  ( 115, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.input_list 
input_list1, _, _)) :: ( _, ( MlyValue.param param1, paramleft, _)) ::
 _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.module (fn _ => let val  (param as param1) = param1 ()
 val  (input_list as input_list1) = input_list1 ()
 in (
if Symbol.symEq(#name(param),Names.top_module_symbol) then 
                                                  raise A.SyntaxError("The name Top cannot be used for a module",SOME(getPos paramleft))
                                               else
                                                   {module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 2, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 116, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.input_list input_list1, _, _)) :: ( _, ( MlyValue.lcb lcb1, _
, _)) :: ( _, ( MlyValue.param param1, paramleft, _)) :: ( _, ( _, 
MODULE1left, _)) :: rest671)) => let val  result = MlyValue.module (fn
 _ => let val  (param as param1) = param1 ()
 val  lcb1 = lcb1 ()
 val  (input_list as input_list1) = input_list1 ()
 val  rcb1 = rcb1 ()
 in (
if Symbol.symEq(#name(param),Names.top_module_symbol) then 
                                                  raise A.SyntaxError("The name Top cannot be used for a module",SOME(getPos paramleft))
                                         else {module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 2, ( result, MODULE1left, rcb1right), rest671)
end
|  ( 117, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.input_list 
input_list1, _, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.moduleExtension (fn _ => let val  (param as param1) = param1
 ()
 val  (input_list as input_list1) = input_list1 ()
 in (
{module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 3, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 118, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.input_list input_list1, _, _)) :: ( _, ( MlyValue.lcb lcb1, _
, _)) :: ( _, ( MlyValue.param param1, _, _)) :: ( _, ( _, 
EXTEND_MODULE1left, _)) :: rest671)) => let val  result = 
MlyValue.moduleExtension (fn _ => let val  (param as param1) = param1
 ()
 val  lcb1 = lcb1 ()
 val  (input_list as input_list1) = input_list1 ()
 val  rcb1 = rcb1 ()
 in (
{module_name=param,module_file=ref(!Paths.current_file),module_contents=input_list}:A.module_entry
)
end)
 in ( LrTable.NT 3, ( result, EXTEND_MODULE1left, rcb1right), rest671)

end
|  ( 119, ( ( _, ( MlyValue.def_block def_block1, def_block1left, 
def_block1right)) :: rest671)) => let val  result = 
MlyValue.def_blocks (fn _ => let val  (def_block as def_block1) = 
def_block1 ()
 in ([def_block])
end)
 in ( LrTable.NT 86, ( result, def_block1left, def_block1right), 
rest671)
end
|  ( 120, ( ( _, ( MlyValue.def_blocks def_blocks1, _, 
def_blocks1right)) :: ( _, ( MlyValue.def_block def_block1, 
def_block1left, _)) :: rest671)) => let val  result = 
MlyValue.def_blocks (fn _ => let val  (def_block as def_block1) = 
def_block1 ()
 val  (def_blocks as def_blocks1) = def_blocks1 ()
 in (def_block::def_blocks)
end)
 in ( LrTable.NT 86, ( result, def_block1left, def_blocks1right), 
rest671)
end
|  ( 121, ( ( _, ( MlyValue.infix_def_block infix_def_block1, 
infix_def_block1left, infix_def_block1right)) :: rest671)) => let val 
 result = MlyValue.infix_def_blocks (fn _ => let val  (infix_def_block
 as infix_def_block1) = infix_def_block1 ()
 in ([infix_def_block])
end)
 in ( LrTable.NT 84, ( result, infix_def_block1left, 
infix_def_block1right), rest671)
end
|  ( 122, ( ( _, ( MlyValue.infix_def_blocks infix_def_blocks1, _, 
infix_def_blocks1right)) :: _ :: ( _, ( MlyValue.infix_def_block 
infix_def_block1, infix_def_block1left, _)) :: rest671)) => let val  
result = MlyValue.infix_def_blocks (fn _ => let val  (infix_def_block
 as infix_def_block1) = infix_def_block1 ()
 val  (infix_def_blocks as infix_def_blocks1) = infix_def_blocks1 ()
 in (infix_def_block::infix_def_blocks)
end)
 in ( LrTable.NT 84, ( result, infix_def_block1left, 
infix_def_blocks1right), rest671)
end
|  ( 123, ( ( _, ( MlyValue.athena_var athena_var1, athena_var1left, 
athena_var1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_athena_vars (fn _ => let val  (athena_var as 
athena_var1) = athena_var1 ()
 in ([athena_var])
end)
 in ( LrTable.NT 128, ( result, athena_var1left, athena_var1right), 
rest671)
end
|  ( 124, ( ( _, ( MlyValue.one_or_more_athena_vars 
one_or_more_athena_vars1, _, one_or_more_athena_vars1right)) :: ( _, (
 MlyValue.athena_var athena_var1, athena_var1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_athena_vars (fn _ => let val 
 (athena_var as athena_var1) = athena_var1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 in (athena_var::one_or_more_athena_vars)
end)
 in ( LrTable.NT 128, ( result, athena_var1left, 
one_or_more_athena_vars1right), rest671)
end
|  ( 125, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.any_id (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 64, ( result, ID1left, ID1right), rest671)
end
|  ( 126, ( ( _, ( MlyValue.PRIVATE_ID PRIVATE_ID1, PRIVATE_ID1left, 
PRIVATE_ID1right)) :: rest671)) => let val  result = MlyValue.any_id
 (fn _ => let val  (PRIVATE_ID as PRIVATE_ID1) = PRIVATE_ID1 ()
 in (PRIVATE_ID)
end)
 in ( LrTable.NT 64, ( result, PRIVATE_ID1left, PRIVATE_ID1right), 
rest671)
end
|  ( 127, ( ( _, ( MlyValue.phrase phrase2, _, phrase2right)) :: _ :: 
( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671)) => let
 val  result = MlyValue.map_binding (fn _ => let val  phrase1 = 
phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.exp(A.listExp({members=[phrase1,phrase2],pos=getPos(phrase1left)})))

end)
 in ( LrTable.NT 40, ( result, phrase1left, phrase2right), rest671)

end
|  ( 128, ( rest671)) => let val  result = MlyValue.map_bindings (fn _
 => ([]))
 in ( LrTable.NT 41, ( result, defaultPos, defaultPos), rest671)
end
|  ( 129, ( ( _, ( MlyValue.map_binding map_binding1, map_binding1left
, map_binding1right)) :: rest671)) => let val  result = 
MlyValue.map_bindings (fn _ => let val  (map_binding as map_binding1)
 = map_binding1 ()
 in ([map_binding])
end)
 in ( LrTable.NT 41, ( result, map_binding1left, map_binding1right), 
rest671)
end
|  ( 130, ( ( _, ( MlyValue.map_bindings map_bindings1, _, 
map_bindings1right)) :: _ :: ( _, ( MlyValue.map_binding map_binding1,
 map_binding1left, _)) :: rest671)) => let val  result = 
MlyValue.map_bindings (fn _ => let val  (map_binding as map_binding1)
 = map_binding1 ()
 val  (map_bindings as map_bindings1) = map_bindings1 ()
 in (map_binding::map_bindings)
end)
 in ( LrTable.NT 41, ( result, map_binding1left, map_bindings1right), 
rest671)
end
|  ( 131, ( ( _, ( MlyValue.any_id any_id1, (any_idleft as any_id1left
), any_id1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (any_id as any_id1) = any_id1 ()
 in (
let val id_pos = getPos(any_idleft) 
                        val mod_sym = A.makeMS(any_id,SOME id_pos)
                        val (mods,s) = MS.split(mod_sym)
                    in
                       A.idExp({msym=mod_sym,mods=mods,sym=s,no_mods=null(mods),pos=id_pos})
                    end
)
end)
 in ( LrTable.NT 63, ( result, any_id1left, any_id1right), rest671)

end
|  ( 132, ( ( _, ( _, _, DOUBLE_RIGHT_CURLY_BRACE1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, DOUBLE_LEFT_CURLY_BRACE1left, _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (hd one_or_more_expressions)
end)
 in ( LrTable.NT 63, ( result, DOUBLE_LEFT_CURLY_BRACE1left, 
DOUBLE_RIGHT_CURLY_BRACE1right), rest671)
end
|  ( 133, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.expression (fn _ => let
 val  (expression as expression1) = expression1 ()
 in (A.opExp({op_exp=expression,pos=getPos LPARENleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 134, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  (ID as ID1
) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
let val id_pos = getPos(IDleft)
                                in
                                   A.taggedConSym({name=A.makeMS(ID,SOME id_pos),pos=id_pos,sort_as_tagged_symterm=user_sort,sort_as_fterm=NONE})
                                end
)
end)
 in ( LrTable.NT 63, ( result, ID1left, user_sort1right), rest671)
end
|  ( 135, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => (A.unitExp({pos=getPos LPARENleft})))
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 136, ( ( _, ( MlyValue.CHARACTER CHARACTER1, (CHARACTERleft as 
CHARACTER1left), CHARACTER1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (CHARACTER as CHARACTER1) = 
CHARACTER1 ()
 in (A.charExp({code=CHARACTER,pos=getPos CHARACTERleft}))
end)
 in ( LrTable.NT 63, ( result, CHARACTER1left, CHARACTER1right), 
rest671)
end
|  ( 137, ( ( _, ( MlyValue.STRING STRING1, (STRINGleft as STRING1left
), STRING1right)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (A.stringExp({str=STRING,pos=getPos STRINGleft,mem_index=(~1)}))

end)
 in ( LrTable.NT 63, ( result, STRING1left, STRING1right), rest671)

end
|  ( 138, ( ( _, ( MlyValue.ath_var ath_var1, ath_var1left, 
ath_var1right)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (ath_var as ath_var1) = ath_var1 ()
 in (ath_var)
end)
 in ( LrTable.NT 63, ( result, ath_var1left, ath_var1right), rest671)

end
|  ( 139, ( ( _, ( MlyValue.athena_meta_id athena_meta_id1, 
athena_meta_id1left, athena_meta_id1right)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (athena_meta_id as 
athena_meta_id1) = athena_meta_id1 ()
 in (athena_meta_id)
end)
 in ( LrTable.NT 63, ( result, athena_meta_id1left, 
athena_meta_id1right), rest671)
end
|  ( 140, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( _, LOGICAL_ANDleft, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.logicalAndExp({args=[phrase1,phrase2],pos=getPos LOGICAL_ANDleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 141, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 LOGICAL_ANDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (
one_or_more_phrases as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (
A.logicalAndExp({args=one_or_more_phrases,pos=getPos LOGICAL_ANDleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 142, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 LOGICAL_ORleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (
one_or_more_phrases as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (
A.logicalOrExp({args=one_or_more_phrases,pos=getPos LOGICAL_ORleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 143, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( _, LOGICAL_ORleft, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
A.logicalOrExp({args=[phrase1,phrase2],pos=getPos LOGICAL_ORleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 144, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( _, MAKE_CELLleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 in (A.cellExp({contents=phrase,pos=getPos MAKE_CELLleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 145, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( _, (MAKE_CELLleft as MAKE_CELL1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 in (A.cellExp({contents=phrase,pos=getPos MAKE_CELLleft}))
end)
 in ( LrTable.NT 63, ( result, MAKE_CELL1left, phrase1right), rest671)

end
|  ( 146, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, REFleft, _)) :: ( _, ( _, LPAREN1left
, _)) :: rest671)) => let val  result = MlyValue.expression (fn _ =>
 let val  (expression as expression1) = expression1 ()
 in (A.refExp({cell_exp=expression,pos=getPos REFleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 147, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( _, (REFleft as REF1left), _)) :: rest671)
) => let val  result = MlyValue.expression (fn _ => let val  (
expression as expression1) = expression1 ()
 in (A.refExp({cell_exp=expression,pos=getPos REFleft}))
end)
 in ( LrTable.NT 63, ( result, REF1left, expression1right), rest671)

end
|  ( 148, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) :: (
 _, ( _, SETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.setCellExp({cell_exp=expression,
                                                               set_phrase=phrase,pos=getPos SETleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 149, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression1, _, _)) :: ( _, ( _, (SETleft as 
SET1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  (expression as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.setCellExp({cell_exp=expression,
                                                               set_phrase=phrase,pos=getPos SETleft})
)
end)
 in ( LrTable.NT 63, ( result, SET1left, phrase1right), rest671)
end
|  ( 150, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) :: (
 _, ( _, VECTOR_INITleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.expression (fn _ => let val  (
expression as expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorInitExp({length_exp=expression,
                                                               init_val=phrase,pos=getPos VECTOR_INITleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 151, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
VECTOR_INITleft as VECTOR_INIT1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorInitExp({length_exp=expression,
                                                               init_val=phrase,pos=getPos VECTOR_INITleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_INIT1left, phrase1right), 
rest671)
end
|  ( 152, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.expression expression2, _, _)) :: (
 _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, 
VECTOR_SETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  expression1 = 
expression1 ()
 val  expression2 = expression2 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorSetExp({vector_exp=expression1,
									index_exp=expression2,
                                                               new_val=phrase,pos=getPos VECTOR_SETleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 153, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( MlyValue.expression expression2, _, _)) :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( _, (VECTOR_SETleft
 as VECTOR_SET1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
A.vectorSetExp({vector_exp=expression1,
									index_exp=expression2,
                                                               new_val=phrase,pos=getPos VECTOR_SETleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_SET1left, phrase1right), rest671
)
end
|  ( 154, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression2, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, VECTOR_SUBleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.vectorSubExp({vector_exp=expression1,
									    index_exp=expression2,
                                                                            pos=getPos VECTOR_SUBleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 155, ( ( _, ( MlyValue.expression expression2, _, 
expression2right)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, (VECTOR_SUBleft as VECTOR_SUB1left), _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  expression1 =
 expression1 ()
 val  expression2 = expression2 ()
 in (
A.vectorSubExp({vector_exp=expression1,
									    index_exp=expression2,
                                                                            pos=getPos VECTOR_SUBleft})
)
end)
 in ( LrTable.NT 63, ( result, VECTOR_SUB1left, expression2right), 
rest671)
end
|  ( 156, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, (
FUNCTIONleft as FUNCTION1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val infix_flag = (length(possibly_wildcard_param_list_no_dots) = 2)
                 in A.functionExp({params=possibly_wildcard_param_list_no_dots,body=expression,
                      pos=getPos FUNCTIONleft})
                 end
)
end)
 in ( LrTable.NT 63, ( result, FUNCTION1left, expression1right), 
rest671)
end
|  ( 157, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, 
FUNCTIONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val infix_flag = (length(possibly_wildcard_param_list_no_dots) = 2)
                 in A.functionExp({params=possibly_wildcard_param_list_no_dots,body=expression,
                      pos=getPos FUNCTIONleft})
                 end
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 158, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression2, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.params params1, _, _)) :: _ :: ( _, ( _, 
WITH_KEYSleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  (params as 
params1) = params1 ()
 val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.desugarWithKeys(params,expression1,expression2,getPos WITH_KEYSleft)
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 159, ( ( _, ( MlyValue.expression expression2, _, 
expression2right)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, (
WITH_KEYSleft as WITH_KEYS1left), _)) :: rest671)) => let val  result
 = MlyValue.expression (fn _ => let val  (
one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  expression1 = expression1 ()
 val  expression2 = expression2 ()
 in (
A.desugarWithKeys(one_or_more_comma_separated_params,expression1,expression2,getPos WITH_KEYSleft)
)
end)
 in ( LrTable.NT 63, ( result, WITH_KEYS1left, expression2right), 
rest671)
end
|  ( 160, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _
, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
A.appExp({proc=phrase,args=phrases,alt_exp=ref(NONE),pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 161, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.phrases phrases1, _, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrases as phrases1) = phrases1
 ()
 in (A.listExp({members=phrases,pos=getPos LEFT_BRACKETleft}))
end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 162, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.expression expression2, _, _)) :: _ :: ( _, ( 
MlyValue.pattern pattern1, _, _)) :: _ :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  expression2 = expression2 ()
 in (A.desugarListComprehension(expression1,pattern,expression2,NONE))

end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 163, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.expression expression3, _, _)) :: _ :: ( _, ( 
MlyValue.expression expression2, _, _)) :: _ :: ( _, ( 
MlyValue.pattern pattern1, _, _)) :: _ :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671))
 => let val  result = MlyValue.expression (fn _ => let val  
expression1 = expression1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  expression2 = expression2 ()
 val  expression3 = expression3 ()
 in (
A.desugarListComprehension(expression1,pattern,expression2,SOME(expression3))
)
end)
 in ( LrTable.NT 63, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 164, ( ( _, ( _, _, MAP_END1right)) :: ( _, ( 
MlyValue.map_bindings map_bindings1, _, _)) :: ( _, ( _, (
MAP_BEGINleft as MAP_BEGIN1left), _)) :: rest671)) => let val  result
 = MlyValue.expression (fn _ => let val  (map_bindings as 
map_bindings1) = map_bindings1 ()
 in (A.makeMapExp(map_bindings,getPos(MAP_BEGINleft)))
end)
 in ( LrTable.NT 63, ( result, MAP_BEGIN1left, MAP_END1right), rest671
)
end
|  ( 165, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( 
MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, 
METHODleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.methodExp({params=possibly_wildcard_param_list_no_dots,body=deduction,pos=getPos METHODleft,
                     name=ref("")})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 166, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, _)) :: _ :: ( _, ( _, (
METHODleft as METHOD1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (
possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.methodExp({params=possibly_wildcard_param_list_no_dots,body=deduction,pos=getPos METHODleft,
                     name=ref("")})
)
end)
 in ( LrTable.NT 63, ( result, METHOD1left, deduction1right), rest671)

end
|  ( 167, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, TRYleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.expression (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (A.tryExp({choices=one_or_more_expressions,pos=getPos TRYleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 168, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.one_or_more_separated_expressions 
one_or_more_separated_expressions1, _, _)) :: ( _, ( MlyValue.lcb lcb1
, _, _)) :: ( _, ( _, (TRYleft as TRY1left), _)) :: rest671)) => let
 val  result = MlyValue.expression (fn _ => let val  lcb1 = lcb1 ()
 val  (one_or_more_separated_expressions as 
one_or_more_separated_expressions1) = 
one_or_more_separated_expressions1 ()
 val  rcb1 = rcb1 ()
 in (
A.tryExp({choices=one_or_more_separated_expressions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 63, ( result, TRY1left, rcb1right), rest671)
end
|  ( 169, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.check_clauses check_clauses1, _, _)) :: ( _, ( _, CHECKleft,
 _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (check_clauses as check_clauses1
) = check_clauses1 ()
 in (A.checkExp({clauses=check_clauses,pos=getPos CHECKleft}))
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 170, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_check_clauses infix_check_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (CHECKleft as CHECK1left), _))
 :: rest671)) => let val  result = MlyValue.expression (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_check_clauses as infix_check_clauses1) = 
infix_check_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkExp({clauses=infix_check_clauses,pos=getPos CHECKleft}))

end)
 in ( LrTable.NT 63, ( result, CHECK1left, rcb1right), rest671)
end
|  ( 171, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_match_clauses infix_match_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (MATCHleft as MATCH1left), _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_match_clauses as infix_match_clauses1) = 
infix_match_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchExp({discriminant=phrase,clauses=infix_match_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 63, ( result, MATCH1left, rcb1right), rest671)
end
|  ( 172, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.match_clauses match_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, MATCHleft, _)) :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (match_clauses as match_clauses1) = match_clauses1 ()
 in (
A.matchExp({discriminant=phrase,clauses=match_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 173, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETleft as 
LET1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letExp({bindings=semicolon_separated_bindings,body=expression,pos=getPos LETleft})
)
end)
 in ( LrTable.NT 63, ( result, LET1left, expression1right), rest671)

end
|  ( 174, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETRECleft as 
LETREC1left), _)) :: rest671)) => let val  result = 
MlyValue.expression (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letRecExp({bindings=semicolon_separated_bindings,body=expression,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 63, ( result, LETREC1left, expression1right), rest671
)
end
|  ( 175, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (expression as expression1) = expression1 ()
 in (A.letExp({bindings=bindings,body=expression,pos=getPos LETleft}))

end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 176, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, LETRECleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.expression (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (expression as expression1) = expression1 ()
 in (
A.letRecExp({bindings=bindings,body=expression,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 177, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_phrases one_or_more_phrases1, _, _)) :: ( _, ( _,
 SEQleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.expression (fn _ => let val  (one_or_more_phrases
 as one_or_more_phrases1) = one_or_more_phrases1 ()
 in (A.beginExp({members=one_or_more_phrases,pos=getPos SEQleft}))
end
)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 178, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _,
 WHILEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.expression (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (A.whileExp({test=phrase1,body=phrase2,pos=getPos WHILEleft}))
end
)
 in ( LrTable.NT 63, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 179, ( ( _, ( MlyValue.phrase phrase2, _, phrase2right)) :: ( _, 
( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (WHILEleft as 
WHILE1left), _)) :: rest671)) => let val  result = MlyValue.expression
 (fn _ => let val  phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (A.whileExp({test=phrase1,body=phrase2,pos=getPos WHILEleft}))
end
)
 in ( LrTable.NT 63, ( result, WHILE1left, phrase2right), rest671)
end
|  ( 180, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.expression expression1, _,
 _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                   pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 181, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                            pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 182, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
CONCLUDEleft as CONCLUDE1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=NONE,
                                                    pos=getPos CONCLUDEleft})
)
end)
 in ( LrTable.NT 70, ( result, CONCLUDE1left, deduction1right), 
rest671)
end
|  ( 183, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: _ :: ( _, ( MlyValue.param_no_dots param_no_dots1, _, _)) :: _ :: 
( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (param_no_dots as 
param_no_dots1) = param_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=SOME param_no_dots,
                                                                              pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 184, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: _ :: ( _, ( 
MlyValue.param_no_dots param_no_dots1, _, _)) :: ( _, ( _, (
CONCLUDEleft as CONCLUDE1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (param_no_dots as param_no_dots1)
 = param_no_dots1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.byDed({wanted_res=expression,body=deduction,conc_name=SOME param_no_dots,
                                                                              pos=getPos CONCLUDEleft})
)
end)
 in ( LrTable.NT 70, ( result, CONCLUDE1left, deduction1right), 
rest671)
end
|  ( 185, ( ( _, ( MlyValue.inference_block inference_block1, 
inference_block1left, inference_block1right)) :: rest671)) => let val 
 result = MlyValue.deduction (fn _ => let val  (inference_block as 
inference_block1) = inference_block1 ()
 in (inference_block)
end)
 in ( LrTable.NT 70, ( result, inference_block1left, 
inference_block1right), rest671)
end
|  ( 186, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (ASSUMEleft
 as ASSUME1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeDed({assumption=phrase,body=deduction,pos=getPos ASSUMEleft}))

end)
 in ( LrTable.NT 70, ( result, ASSUME1left, deduction1right), rest671)

end
|  ( 187, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
SUPPOSE_ABSURDleft as SUPPOSE_ABSURD1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdDed({hyp=phrase,body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, SUPPOSE_ABSURD1left, deduction1right), 
rest671)
end
|  ( 188, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.assignments assignments1, _, _)) :: ( _, ( _, (
ASSUMEleft as ASSUME1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (assignments as assignments1) = 
assignments1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.infixAssumeDed({bindings=assignments,body=deduction,pos=getPos ASSUMEleft})
)
end)
 in ( LrTable.NT 70, ( result, ASSUME1left, deduction1right), rest671)

end
|  ( 189, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( _, (SUPPOSE_ABSURDleft as 
SUPPOSE_ABSURD1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                      A.absurdLetDed({named_hyp={bpat=A.idPat({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                                sort_as_fterm=NONE,sort_as_exp=NONE}),
                                                  def=phrase,pos=getPos IDleft},
                                      body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, SUPPOSE_ABSURD1left, deduction1right), 
rest671)
end
|  ( 190, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.case_clauses 
case_clauses1, _, _)) :: _ :: ( _, ( MlyValue.phrase phrase1, _, _))
 :: ( _, ( _, (BY_CASESleft as BY_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=NONE,
                               arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, END1right), rest671)
end
|  ( 191, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.case_clauses case_clauses1, _, _)) :: ( _, ( MlyValue.lcb 
lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
BY_CASESleft as BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=NONE,
                               arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, rcb1right), rest671)
end
|  ( 192, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.case_clauses 
case_clauses1, _, _)) :: _ :: ( _, ( 
MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, _)) :: _ :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (BY_CASESleft as 
BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=SOME(comma_separated_expression_list),
                             arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, END1right), rest671)
end
|  ( 193, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.case_clauses case_clauses1, _, _)) :: ( _, ( MlyValue.lcb 
lcb1, _, _)) :: ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, _)) :: _ :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (BY_CASESleft as 
BY_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 val  lcb1 = lcb1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.byCasesDed({disj=phrase,from_exps=SOME(comma_separated_expression_list),
                             arms=case_clauses,pos=getPos BY_CASESleft})
)
end)
 in ( LrTable.NT 70, ( result, BY_CASES1left, rcb1right), rest671)
end
|  ( 194, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, _)) :: ( _, ( _, (PICK_ANYleft as 
PICK_ANY1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (possibly_typed_params_no_dots
 as possibly_typed_params_no_dots1) = possibly_typed_params_no_dots1
 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickAnyDed({eigenvars=A.checkForDuplicateParams(possibly_typed_params_no_dots),
	 		   body=deduction,pos=getPos PICK_ANYleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_ANY1left, deduction1right), 
rest671)
end
|  ( 195, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.param_option param_option1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( MlyValue.ID ID1, IDleft
, _)) :: ( _, ( _, (PICK_WITNESSleft as PICK_WITNESS1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option as param_option1) = param_option1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                 A.pickWitnessDed({ex_gen=phrase,var_id=S.symbol(ID),inst_id=param_option,body=deduction,
                                    pos=getPos PICK_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_WITNESS1left, deduction1right), 
rest671)
end
|  ( 196, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.param_option_no_dots param_option_no_dots1, _, _))
 :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: ( _, ( 
MlyValue.one_or_more_params_no_dots one_or_more_params_no_dots1, _, _)
) :: ( _, ( _, (PICK_WITNESSESleft as PICK_WITNESSES1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_params_no_dots as one_or_more_params_no_dots1) = 
one_or_more_params_no_dots1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickWitnessesDed({ex_gen=phrase,var_ids=A.getParamNames(one_or_more_params_no_dots),
                                         inst_id=param_option_no_dots,body=deduction,
                                          pos=getPos PICK_WITNESSESleft})
)
end)
 in ( LrTable.NT 70, ( result, PICK_WITNESSES1left, deduction1right), 
rest671)
end
|  ( 197, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (INDUCTIONleft as 
INDUCTION1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=infix_dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                         res
                     end
)
end)
 in ( LrTable.NT 70, ( result, INDUCTION1left, END1right), rest671)

end
|  ( 198, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (INDUCTIONleft as INDUCTION1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=infix_dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                         res
                     end
)
end)
 in ( LrTable.NT 70, ( result, INDUCTION1left, rcb1right), rest671)

end
|  ( 199, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
STRUCTURE_CASESleft as STRUCTURE_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=infix_dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, STRUCTURE_CASES1left, END1right), 
rest671)
end
|  ( 200, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (STRUCTURE_CASESleft as STRUCTURE_CASES1left), _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
phrase as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=infix_dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, STRUCTURE_CASES1left, rcb1right), 
rest671)
end
|  ( 201, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (DATATYPE_CASESleft
 as DATATYPE_CASES1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                        clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, END1right), 
rest671)
end
|  ( 202, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (DATATYPE_CASESleft as DATATYPE_CASES1left), _)) :: rest671
)) => let val  result = MlyValue.deduction (fn _ => let val  (phrase
 as phrase1) = phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                        clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, rcb1right), 
rest671)
end
|  ( 203, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.expression expression1, _
, _)) :: _ :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (
DATATYPE_CASESleft as DATATYPE_CASES1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (expression as expression1) = expression1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=SOME(expression),
                                                       clauses=infix_dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                      in
                         res
                      end
)
end)
 in ( LrTable.NT 70, ( result, DATATYPE_CASES1left, rcb1right), 
rest671)
end
|  ( 204, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: _ :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, ASSUMEleft, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                      A.assumeLetDed({bindings=[({bpat=A.idPat({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                                sort_as_fterm=NONE,sort_as_exp=NONE}),
                                                  def=phrase,pos=getPos IDleft})],body=deduction,
                      pos=getPos ASSUMEleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 205, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 _, ASSUMEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (phrase as phrase1
) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeDed({assumption=phrase,body=deduction,pos=getPos ASSUMEleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 206, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.binding binding1, _, _)) :: ( _,
 ( _, ASSUME_LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.deduction (fn _ => let val  (binding
 as binding1) = binding1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.assumeLetDed({bindings=[binding],body=deduction,
                      pos=getPos ASSUME_LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 207, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 _, SUPPOSE_ABSURDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.deduction (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdDed({hyp=phrase,body=deduction,pos=getPos SUPPOSE_ABSURDleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 208, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.binding binding1, _, _)) :: ( _,
 ( _, SUPPOSE_ABSURD_LETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
binding as binding1) = binding1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.absurdLetDed({named_hyp=binding,body=deduction,pos=getPos SUPPOSE_ABSURD_LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 209, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dcheck_clauses dcheck_clauses1, _, _)) :: ( _, ( _, 
DCHECKleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.deduction (fn _ => let val  (dcheck_clauses as 
dcheck_clauses1) = dcheck_clauses1 ()
 in (A.checkDed({clauses=dcheck_clauses,pos=getPos DCHECKleft}))
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 210, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _)) ::
 _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (expression as 
expression1) = expression1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
case expression of
                    A.idExp({msym,...}) => 
                      if Basic.isMember(MS.name(msym),["prim-mp", "prim-both"]) andalso length(phrases) = 2 then 
                         (A.BMethAppDed({method=expression,arg1=hd phrases, arg2 = hd(tl(phrases)), pos=getPos LPARENleft}))
                      else
                           if Basic.isMember(MS.name(msym),["prim-conj-intro"]) andalso length(phrases) = 1 then 
                             (A.UMethAppDed({method=expression,arg=hd phrases, pos=getPos LPARENleft}))                   
                          else
                         (A.methodAppDed({method=expression,args=phrases,pos=getPos LPARENleft}))
                  | _ => (A.methodAppDed({method=expression,args=phrases,pos=getPos LPARENleft}))
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 211, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrases 
phrases1, _, _)) :: ( _, ( MlyValue.expression expression1, 
expressionleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (expression
 as expression1) = expression1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (
A.methodAppDed({method=expression,args=phrases,pos=getPos expressionleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 212, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, DMATCHleft, _)) :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
A.matchDed({discriminant=phrase,clauses=dmatch_clauses,pos=getPos DMATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 213, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, DLETleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (A.letDed({bindings=bindings,body=deduction,pos=getPos DLETleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 214, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: _ :: ( _, ( MlyValue.bindings bindings1, _, _))
 :: _ :: ( _, ( _, DLETRECleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
bindings as bindings1) = bindings1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=bindings,body=deduction,pos=getPos DLETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 215, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETleft as 
LET1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos LETleft})
)
end)
 in ( LrTable.NT 70, ( result, LET1left, deduction1right), rest671)

end
|  ( 216, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DLETleft as 
DLET1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos DLETleft})
)
end)
 in ( LrTable.NT 70, ( result, DLET1left, deduction1right), rest671)

end
|  ( 217, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (LETRECleft as 
LETREC1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos LETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, LETREC1left, deduction1right), rest671)

end
|  ( 218, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.rcb rcb1, _, _)) :: ( _, ( 
MlyValue.semicolon_separated_bindings semicolon_separated_bindings1, _
, _)) :: ( _, ( MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DLETRECleft
 as DLETREC1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  lcb1 = lcb1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 val  rcb1 = rcb1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.letRecDed({bindings=semicolon_separated_bindings,body=deduction,pos=getPos DLETRECleft})
)
end)
 in ( LrTable.NT 70, ( result, DLETREC1left, deduction1right), rest671
)
end
|  ( 219, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, _)) :: ( _, ( MlyValue.lcb lcb1,
 _, _)) :: ( _, ( _, (TRYleft as TRY1left), _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  lcb1 = lcb1 ()
 val  (one_or_more_separated_deductions as 
one_or_more_separated_deductions1) = one_or_more_separated_deductions1
 ()
 val  rcb1 = rcb1 ()
 in (
A.tryDed({choices=one_or_more_separated_deductions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 70, ( result, TRY1left, rcb1right), rest671)
end
|  ( 220, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: _ :: (
 _, ( MlyValue.phrase phrase1, _, _)) :: ( _, ( _, (MATCHleft as 
MATCH1left), _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, MATCH1left, END1right), rest671)
end
|  ( 221, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (MATCHleft as MATCH1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos MATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, MATCH1left, rcb1right), rest671)
end
|  ( 222, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dmatch_clauses infix_dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) ::
 ( _, ( _, (DMATCHleft as DMATCH1left), _)) :: rest671)) => let val  
result = MlyValue.deduction (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  lcb1 = lcb1 ()
 val  (infix_dmatch_clauses as infix_dmatch_clauses1) = 
infix_dmatch_clauses1 ()
 val  rcb1 = rcb1 ()
 in (
A.matchDed({discriminant=phrase,clauses=infix_dmatch_clauses,pos=getPos DMATCHleft})
)
end)
 in ( LrTable.NT 70, ( result, DMATCH1left, rcb1right), rest671)
end
|  ( 223, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dcheck_clauses infix_dcheck_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (CHECKleft as CHECK1left), _))
 :: rest671)) => let val  result = MlyValue.deduction (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkDed({clauses=infix_dcheck_clauses,pos=getPos CHECKleft}))

end)
 in ( LrTable.NT 70, ( result, CHECK1left, rcb1right), rest671)
end
|  ( 224, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.infix_dcheck_clauses infix_dcheck_clauses1, _, _)) :: ( _, ( 
MlyValue.lcb lcb1, _, _)) :: ( _, ( _, (DCHECKleft as DCHECK1left), _)
) :: rest671)) => let val  result = MlyValue.deduction (fn _ => let
 val  lcb1 = lcb1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 val  rcb1 = rcb1 ()
 in (A.checkDed({clauses=infix_dcheck_clauses,pos=getPos DCHECKleft}))

end)
 in ( LrTable.NT 70, ( result, DCHECK1left, rcb1right), rest671)
end
|  ( 225, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_deductions one_or_more_deductions1, _, _)) :: ( _
, ( _, DTRYleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (A.tryDed({choices=one_or_more_deductions,pos=getPos DTRYleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 226, ( ( _, ( _, _, END1right)) :: ( _, ( 
MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, _)) :: _ :: ( _, ( _, (TRYleft
 as TRY1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (one_or_more_separated_deductions
 as one_or_more_separated_deductions1) = 
one_or_more_separated_deductions1 ()
 in (
A.tryDed({choices=one_or_more_separated_deductions,pos=getPos TRYleft})
)
end)
 in ( LrTable.NT 70, ( result, TRY1left, END1right), rest671)
end
|  ( 227, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_deductions one_or_more_deductions1, _, _)) :: ( _
, ( _, DSEQleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (A.beginDed({members=one_or_more_deductions,pos=getPos DSEQleft}))

end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 228, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.expression expression1, _, _))
 :: ( _, ( _, GEN_OVERleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.deduction (fn _ => let val  (
expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.genOverDed({eigenvar_exp=expression,body=deduction,pos=getPos GEN_OVERleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 229, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: ( _, ( MlyValue.expression expression1, _, _)) :: ( _, ( _, (
GEN_OVERleft as GEN_OVER1left), _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.genOverDed({eigenvar_exp=expression,body=deduction,pos=getPos GEN_OVERleft})
)
end)
 in ( LrTable.NT 70, ( result, GEN_OVER1left, deduction1right), 
rest671)
end
|  ( 230, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, _)) :: ( _, ( _, PICK_ANYleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (possibly_typed_params_no_dots
 as possibly_typed_params_no_dots1) = possibly_typed_params_no_dots1
 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickAnyDed({eigenvars=A.checkForDuplicateParams(possibly_typed_params_no_dots),
				   body=deduction,pos=getPos PICK_ANYleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 231, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)) :: ( _, (
 MlyValue.expression expression1, _, _)) :: ( _, ( _, WITH_WITNESSleft
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.withWitnessDed({eigenvar_exp=expression,ex_gen=phrase,body=deduction,
                                       pos=getPos WITH_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 232, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.param_option_no_dots 
param_option_no_dots1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)
) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, PICK_WITNESSleft
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (ID as ID1) = ID1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.checkNoDots(ID,getPos IDleft);
                     A.pickWitnessDed({ex_gen=phrase,var_id=S.symbol(ID),inst_id=param_option_no_dots,body=deduction,
                                       pos=getPos PICK_WITNESSleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 233, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.param_option_no_dots 
param_option_no_dots1, _, _)) :: ( _, ( MlyValue.phrase phrase1, _, _)
) :: _ :: ( _, ( MlyValue.one_or_more_params_no_dots 
one_or_more_params_no_dots1, _, _)) :: _ :: ( _, ( _, 
PICK_WITNESSESleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.deduction (fn _ => let val  (
one_or_more_params_no_dots as one_or_more_params_no_dots1) = 
one_or_more_params_no_dots1 ()
 val  (phrase as phrase1) = phrase1 ()
 val  (param_option_no_dots as param_option_no_dots1) = 
param_option_no_dots1 ()
 val  (deduction as deduction1) = deduction1 ()
 in (
A.pickWitnessesDed({ex_gen=phrase,var_ids=A.getParamNames(one_or_more_params_no_dots),
                                        inst_id=param_option_no_dots,body=deduction,
                                         pos=getPos PICK_WITNESSESleft})
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 234, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, INDUCTIONleft, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.inductionDed({prop=phrase,
                                                   clauses=dmatch_clauses,pos=getPos INDUCTIONleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 235, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, STRUCTURE_CASESleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=dmatch_clauses,pos=getPos STRUCTURE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 236, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.phrase phrase1, _, _)) :: ( _, ( _, DATATYPE_CASESleft, _))
 :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.deduction (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=NONE,
                                                       clauses=dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 237, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.dmatch_clauses dmatch_clauses1, _, _)) :: ( _, ( 
MlyValue.expression expression1, _, _)) :: _ :: ( _, ( MlyValue.phrase
 phrase1, _, _)) :: ( _, ( _, DATATYPE_CASESleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.deduction
 (fn _ => let val  (phrase as phrase1) = phrase1 ()
 val  (expression as expression1) = expression1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (
let val res = A.structureCasesDed({prop=phrase,term=SOME(expression),
                                                       clauses=dmatch_clauses,pos=getPos DATATYPE_CASESleft})
                     in
                        res
                     end
)
end)
 in ( LrTable.NT 70, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 238, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase2, phrase2left, _)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: 
rest671)) => let val  result = MlyValue.phrase_pair (fn _ => let val  
phrase1 = phrase1 ()
 val  phrase2 = phrase2 ()
 in (
(phrase1,phrase2,getPos(LPARENleft), getPos(phrase1left), getPos(phrase2left))
)
end)
 in ( LrTable.NT 136, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 239, ( ( _, ( MlyValue.phrase_pair phrase_pair1, phrase_pair1left
, phrase_pair1right)) :: rest671)) => let val  result = 
MlyValue.phrase_pair_list (fn _ => let val  (phrase_pair as 
phrase_pair1) = phrase_pair1 ()
 in ([phrase_pair])
end)
 in ( LrTable.NT 137, ( result, phrase_pair1left, phrase_pair1right), 
rest671)
end
|  ( 240, ( ( _, ( MlyValue.phrase_pair_list phrase_pair_list1, _, 
phrase_pair_list1right)) :: ( _, ( MlyValue.phrase_pair phrase_pair1, 
phrase_pair1left, _)) :: rest671)) => let val  result = 
MlyValue.phrase_pair_list (fn _ => let val  (phrase_pair as 
phrase_pair1) = phrase_pair1 ()
 val  (phrase_pair_list as phrase_pair_list1) = phrase_pair_list1 ()
 in (phrase_pair::phrase_pair_list)
end)
 in ( LrTable.NT 137, ( result, phrase_pair1left, 
phrase_pair_list1right), rest671)
end
|  ( 241, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.comma_separated_expression_list (fn _ => let val  (expression
 as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 66, ( result, expression1left, expression1right), 
rest671)
end
|  ( 242, ( ( _, ( MlyValue.comma_separated_expression_list 
comma_separated_expression_list1, _, 
comma_separated_expression_list1right)) :: _ :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.comma_separated_expression_list (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  (comma_separated_expression_list as 
comma_separated_expression_list1) = comma_separated_expression_list1
 ()
 in (expression::comma_separated_expression_list)
end)
 in ( LrTable.NT 66, ( result, expression1left, 
comma_separated_expression_list1right), rest671)
end
|  ( 243, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 67, ( result, phrase1left, phrase1right), rest671)

end
|  ( 244, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671))
 => let val  result = MlyValue.comma_separated_phrase_list (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (phrase::comma_separated_phrase_list)
end)
 in ( LrTable.NT 67, ( result, phrase1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 245, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 68, ( result, phrase1left, phrase1right), rest671)

end
|  ( 246, ( ( _, ( MlyValue.opt_comma_separated_phrase_list 
opt_comma_separated_phrase_list1, _, 
opt_comma_separated_phrase_list1right)) :: _ :: ( _, ( MlyValue.phrase
 phrase1, phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (opt_comma_separated_phrase_list as 
opt_comma_separated_phrase_list1) = opt_comma_separated_phrase_list1
 ()
 in (phrase::opt_comma_separated_phrase_list)
end)
 in ( LrTable.NT 68, ( result, phrase1left, 
opt_comma_separated_phrase_list1right), rest671)
end
|  ( 247, ( ( _, ( MlyValue.opt_comma_separated_phrase_list 
opt_comma_separated_phrase_list1, _, 
opt_comma_separated_phrase_list1right)) :: ( _, ( MlyValue.phrase 
phrase1, phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.opt_comma_separated_phrase_list (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 val  (opt_comma_separated_phrase_list as 
opt_comma_separated_phrase_list1) = opt_comma_separated_phrase_list1
 ()
 in (phrase::opt_comma_separated_phrase_list)
end)
 in ( LrTable.NT 68, ( result, phrase1left, 
opt_comma_separated_phrase_list1right), rest671)
end
|  ( 248, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: ( _, ( _, FROMleft, FROMright)) :: ( _, ( MlyValue.expression 
expression1, expression1left, _)) :: rest671)) => let val  result = 
MlyValue.inference (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.methodAppDed({method=A.idExp({msym=A.mSym N.spfPrimMethod_symbol,mods=[],sym=N.spfPrimMethod_symbol,no_mods=true,pos=getPos FROMleft}),
                                           args=[A.exp(expression),
                                                 A.exp(A.listExp({members=comma_separated_phrase_list,pos=getPos FROMright}))],
                                                 pos=A.posOfExp(expression)})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 249, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.expression expression2, _, _)) :: ( _, ( _, 
BYleft, _)) :: ( _, ( MlyValue.expression expression1, expression1left
, _)) :: rest671)) => let val  result = MlyValue.inference (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  expression2 = expression2 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.byDed({wanted_res=expression1,conc_name=NONE,body=A.methodAppDed({method=expression2,
                         args=comma_separated_phrase_list,pos=A.posOfExp(expression)}),pos=getPos BYleft})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 250, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.expression expression2, _, _)) :: ( _, ( _, 
BYleft, _)) :: ( _, ( MlyValue.expression expression1, _, _)) :: ( _, 
( _, CONCLUDE1left, _)) :: rest671)) => let val  result = 
MlyValue.inference (fn _ => let val  (expression as expression1) = 
expression1 ()
 val  expression2 = expression2 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.byDed({wanted_res=expression1,conc_name=NONE,body=A.methodAppDed({method=expression2,
                         args=comma_separated_phrase_list,pos=A.posOfExp(expression)}),pos=getPos BYleft})
)
end)
 in ( LrTable.NT 71, ( result, CONCLUDE1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 251, ( ( _, ( _, (TRUE_INTRODUCTIONleft as TRUE_INTRODUCTION1left
), TRUE_INTRODUCTION1right)) :: rest671)) => let val  result = 
MlyValue.inference (fn _ => (
A.methodAppDed({method=A.makeIdExpSimple("true-intro",getPos TRUE_INTRODUCTIONleft),args=[],pos=getPos TRUE_INTRODUCTIONleft})
))
 in ( LrTable.NT 71, ( result, TRUE_INTRODUCTION1left, 
TRUE_INTRODUCTION1right), rest671)
end
|  ( 252, ( ( _, ( MlyValue.comma_separated_phrase_list 
comma_separated_phrase_list1, _, comma_separated_phrase_list1right))
 :: _ :: ( _, ( MlyValue.expression expression1, expression1left, _))
 :: rest671)) => let val  result = MlyValue.inference (fn _ => let
 val  (expression as expression1) = expression1 ()
 val  (comma_separated_phrase_list as comma_separated_phrase_list1) = 
comma_separated_phrase_list1 ()
 in (
A.methodAppDed({method=expression,args=comma_separated_phrase_list,pos=A.posOfExp(expression)})
)
end)
 in ( LrTable.NT 71, ( result, expression1left, 
comma_separated_phrase_list1right), rest671)
end
|  ( 253, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = MlyValue.inference
 (fn _ => let val  (deduction as deduction1) = deduction1 ()
 in (deduction)
end)
 in ( LrTable.NT 71, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 254, ( ( _, ( MlyValue.inference inference1, inference1left, 
inference1right)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  (inference as 
inference1) = inference1 ()
 in ({param=NONE,def=A.ded(inference),pos=A.posOfDed(inference)})
end)
 in ( LrTable.NT 72, ( result, inference1left, inference1right), 
rest671)
end
|  ( 255, ( ( _, ( MlyValue.inference inference1, _, inference1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.possibly_named_inference (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (inference as inference1) = inference1 ()
 in (
{param=SOME(A.someParam({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                            sort_as_fterm=NONE,sort_as_exp=NONE})),
			    def=A.ded(inference),pos=A.posOfDed(inference)}
)
end)
 in ( LrTable.NT 72, ( result, ID1left, inference1right), rest671)
end
|  ( 256, ( ( _, ( MlyValue.inference inference1, _, inference1right))
 :: _ :: ( _, ( _, (ANY_PATleft as ANY_PAT1left), _)) :: rest671)) =>
 let val  result = MlyValue.possibly_named_inference (fn _ => let val 
 (inference as inference1) = inference1 ()
 in (
{param=SOME(A.wildCard(getPos ANY_PATleft)),
			    def=A.ded(inference),pos=A.posOfDed(inference)}
)
end)
 in ( LrTable.NT 72, ( result, ANY_PAT1left, inference1right), rest671
)
end
|  ( 257, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left)
, _)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (expression as expression1) = expression1 ()
 in (
{param=SOME(A.someParam({name=S.symbol(ID),pos=getPos IDleft,sort_as_sym_term=NONE,op_tag=NONE,
                                                    sort_as_fterm=NONE,sort_as_exp=NONE})),
			    def=A.exp(expression),pos=A.posOfExp(expression)}
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 258, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( MlyValue.ID ID2, ID2left, _))
 :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) ::
 rest671)) => let val  result = MlyValue.possibly_named_inference (fn
 _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (expression as expression1) = expression1 ()
 in (
case Int.fromString(ID2) of
                                  SOME(i) => 
                                     ({param=SOME(A.someParam({name=S.symbol(ID1),pos=getPos IDleft,sort_as_sym_term=NONE,
                                                               op_tag=SOME(i,~1),sort_as_fterm=NONE,sort_as_exp=NONE})),
                                                               
                                      def=A.exp(expression),pos=A.posOfExp(expression)})
                                | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 259, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: _ :: ( _, ( MlyValue.ID ID3, _, _)) :: ( _,
 ( MlyValue.ID ID2, ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_named_inference (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (expression as expression1) = expression1 ()
 in (
case (Int.fromString(ID2),Int.fromString(ID3)) of
                                  (SOME(i),SOME(j)) => 
                                    ({param=SOME(A.someParam({name=S.symbol(ID1),pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,j),
                                                    sort_as_fterm=NONE,sort_as_exp=NONE})),
 			              def=A.exp(expression),pos=A.posOfExp(expression)})
                               | _ => Data.genEx("Operator annotation error",
                                                 SOME(getPos ID2left),(!Paths.current_file))
)
end)
 in ( LrTable.NT 72, ( result, ID1left, expression1right), rest671)

end
|  ( 260, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( _, (ANY_PATleft as ANY_PAT1left), _)
) :: rest671)) => let val  result = MlyValue.possibly_named_inference
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (
{param=SOME(A.wildCard(getPos ANY_PATleft)), 
			    def=A.exp(expression),pos=A.posOfExp(expression)}
)
end)
 in ( LrTable.NT 72, ( result, ANY_PAT1left, expression1right), 
rest671)
end
|  ( 261, ( ( _, ( MlyValue.possibly_named_inference 
possibly_named_inference1, possibly_named_inference1left, 
possibly_named_inference1right)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 in ([possibly_named_inference])
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
possibly_named_inference1right), rest671)
end
|  ( 262, ( ( _, ( _, _, SEMI_COLON1right)) :: ( _, ( 
MlyValue.possibly_named_inference possibly_named_inference1, 
possibly_named_inference1left, _)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 in ([possibly_named_inference])
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
SEMI_COLON1right), rest671)
end
|  ( 263, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.inference_list inference_list1, _, _)) :: ( _, ( MlyValue.lcb
 lcb1, _, _)) :: _ :: ( _, ( MlyValue.possibly_named_inference 
possibly_named_inference1, possibly_named_inference1left, _)) :: 
rest671)) => let val  result = MlyValue.inference_list (fn _ => let
 val  (possibly_named_inference as possibly_named_inference1) = 
possibly_named_inference1 ()
 val  lcb1 = lcb1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 val  rcb1 = rcb1 ()
 in (inference_list@[possibly_named_inference])
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
rcb1right), rest671)
end
|  ( 264, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.inference_list
 inference_list1, _, _)) :: _ :: _ :: ( _, ( 
MlyValue.possibly_named_inference possibly_named_inference1, 
possibly_named_inference1left, _)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 in (inference_list@[possibly_named_inference])
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
END1right), rest671)
end
|  ( 265, ( ( _, ( MlyValue.inference_list inference_list1, _, 
inference_list1right)) :: _ :: ( _, ( 
MlyValue.possibly_named_inference possibly_named_inference1, 
possibly_named_inference1left, _)) :: rest671)) => let val  result = 
MlyValue.inference_list (fn _ => let val  (possibly_named_inference
 as possibly_named_inference1) = possibly_named_inference1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 in (possibly_named_inference::inference_list)
end)
 in ( LrTable.NT 73, ( result, possibly_named_inference1left, 
inference_list1right), rest671)
end
|  ( 266, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.expression expression1, expression1left, _))
 :: rest671)) => let val  result = MlyValue.case_clause (fn _ => let
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({case_name=NONE,alt=expression,proof=deduction})
end)
 in ( LrTable.NT 75, ( result, expression1left, deduction1right), 
rest671)
end
|  ( 267, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.expression expression1, _, _)) :: _ :: ( _, (
 MlyValue.param param1, param1left, _)) :: rest671)) => let val  
result = MlyValue.case_clause (fn _ => let val  (param as param1) = 
param1 ()
 val  (expression as expression1) = expression1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({case_name=SOME(param),alt=expression,proof=deduction})
end)
 in ( LrTable.NT 75, ( result, param1left, deduction1right), rest671)

end
|  ( 268, ( ( _, ( MlyValue.case_clause case_clause1, case_clause1left
, case_clause1right)) :: rest671)) => let val  result = 
MlyValue.case_clauses (fn _ => let val  (case_clause as case_clause1)
 = case_clause1 ()
 in ([case_clause])
end)
 in ( LrTable.NT 76, ( result, case_clause1left, case_clause1right), 
rest671)
end
|  ( 269, ( ( _, ( MlyValue.case_clauses case_clauses1, _, 
case_clauses1right)) :: ( _, ( MlyValue.single_logical_or 
single_logical_or1, _, _)) :: ( _, ( MlyValue.case_clause case_clause1
, case_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.case_clauses (fn _ => let val  (case_clause as case_clause1)
 = case_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (case_clauses as case_clauses1) = case_clauses1 ()
 in (case_clause::case_clauses)
end)
 in ( LrTable.NT 76, ( result, case_clause1left, case_clauses1right), 
rest671)
end
|  ( 270, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.inference_list
 inference_list1, _, _)) :: ( _, ( _, (BEGINleft as BEGIN1left), _))
 :: rest671)) => let val  result = MlyValue.inference_block (fn _ =>
 let val  (inference_list as inference_list1) = inference_list1 ()
 in (
case rev(inference_list) of 
                     (b:A.optBinding as {param,def=A.ded(d),pos})::rest => 
                       A.letDed({bindings=A.getBindings(rev (rest)),body=d,pos=getPos BEGINleft})
                   | (b as {param,def=A.exp(e),pos})::_ => 
                        raise A.SyntaxError("expression found in the tail position of"^
                                            "\na begin-end inference block---a deduction is"^
                                            " required in that position",SOME pos)
)
end)
 in ( LrTable.NT 74, ( result, BEGIN1left, END1right), rest671)
end
|  ( 271, ( ( _, ( MlyValue.rcb rcb1, _, rcb1right)) :: ( _, ( 
MlyValue.inference_list inference_list1, _, _)) :: ( _, ( MlyValue.lcb
 lcb1, (lcbleft as lcb1left), _)) :: rest671)) => let val  result = 
MlyValue.inference_block (fn _ => let val  lcb1 = lcb1 ()
 val  (inference_list as inference_list1) = inference_list1 ()
 val  rcb1 = rcb1 ()
 in (
case rev(inference_list) of 
                     (b:A.optBinding as {param,def=A.ded(d),pos})::rest => 
                       let (**** val _ = print("\nHere's the first binding ded I got after reversing: " ^ (A.unparseDed d) ^ "\n")
                            ****)
                       in
                         A.letDed({bindings=A.getBindings(rev (rest)),body=d,pos=getPos lcbleft})
                       end
                   | (b as {param,def=A.exp(e),pos})::_ => 
                        raise A.SyntaxError("expression found in the tail position of"^
                                            "\na begin-end inference block---a deduction is"^
                                            " required in that position",SOME pos)
)
end)
 in ( LrTable.NT 74, ( result, lcb1left, rcb1right), rest671)
end
|  ( 272, ( rest671)) => let val  result = MlyValue.deductions (fn _
 => ([]))
 in ( LrTable.NT 77, ( result, defaultPos, defaultPos), rest671)
end
|  ( 273, ( ( _, ( MlyValue.deductions deductions1, _, 
deductions1right)) :: ( _, ( MlyValue.deduction deduction1, 
deduction1left, _)) :: rest671)) => let val  result = 
MlyValue.deductions (fn _ => let val  (deduction as deduction1) = 
deduction1 ()
 val  (deductions as deductions1) = deductions1 ()
 in (deduction::deductions)
end)
 in ( LrTable.NT 77, ( result, deduction1left, deductions1right), 
rest671)
end
|  ( 274, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = MlyValue.phrase
 (fn _ => let val  (expression as expression1) = expression1 ()
 in (A.exp(expression))
end)
 in ( LrTable.NT 81, ( result, expression1left, expression1right), 
rest671)
end
|  ( 275, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = MlyValue.phrase
 (fn _ => let val  (deduction as deduction1) = deduction1 ()
 in (A.ded(deduction))
end)
 in ( LrTable.NT 81, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 276, ( rest671)) => let val  result = MlyValue.phrases (fn _ => (
[]))
 in ( LrTable.NT 82, ( result, defaultPos, defaultPos), rest671)
end
|  ( 277, ( ( _, ( MlyValue.phrases phrases1, _, phrases1right)) :: (
 _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671)) => let
 val  result = MlyValue.phrases (fn _ => let val  (phrase as phrase1)
 = phrase1 ()
 val  (phrases as phrases1) = phrases1 ()
 in (phrase::phrases)
end)
 in ( LrTable.NT 82, ( result, phrase1left, phrases1right), rest671)

end
|  ( 278, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_expressions (fn _ => let val  (expression as 
expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 65, ( result, expression1left, expression1right), 
rest671)
end
|  ( 279, ( ( _, ( MlyValue.one_or_more_expressions 
one_or_more_expressions1, _, one_or_more_expressions1right)) :: ( _, (
 MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_expressions (fn _ => let val 
 (expression as expression1) = expression1 ()
 val  (one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (expression::one_or_more_expressions)
end)
 in ( LrTable.NT 65, ( result, expression1left, 
one_or_more_expressions1right), rest671)
end
|  ( 280, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = MlyValue.one_or_more_phrases (fn _
 => let val  (phrase as phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 69, ( result, phrase1left, phrase1right), rest671)

end
|  ( 281, ( ( _, ( MlyValue.one_or_more_phrases one_or_more_phrases1,
 _, one_or_more_phrases1right)) :: ( _, ( MlyValue.phrase phrase1, 
phrase1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_phrases (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 val  (one_or_more_phrases as one_or_more_phrases1) = 
one_or_more_phrases1 ()
 in (phrase::one_or_more_phrases)
end)
 in ( LrTable.NT 69, ( result, phrase1left, one_or_more_phrases1right)
, rest671)
end
|  ( 282, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_deductions (fn _ => let val  (deduction as 
deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 80, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 283, ( ( _, ( MlyValue.one_or_more_deductions 
one_or_more_deductions1, _, one_or_more_deductions1right)) :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_deductions (fn _ => let val  (
deduction as deduction1) = deduction1 ()
 val  (one_or_more_deductions as one_or_more_deductions1) = 
one_or_more_deductions1 ()
 in (deduction::one_or_more_deductions)
end)
 in ( LrTable.NT 80, ( result, deduction1left, 
one_or_more_deductions1right), rest671)
end
|  ( 284, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_separated_deductions (fn _ => let val  (deduction
 as deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 78, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 285, ( ( _, ( MlyValue.one_or_more_separated_deductions 
one_or_more_separated_deductions1, _, 
one_or_more_separated_deductions1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_separated_deductions (fn _ => let
 val  (deduction as deduction1) = deduction1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (one_or_more_separated_deductions as 
one_or_more_separated_deductions1) = one_or_more_separated_deductions1
 ()
 in (deduction::one_or_more_separated_deductions)
end)
 in ( LrTable.NT 78, ( result, deduction1left, 
one_or_more_separated_deductions1right), rest671)
end
|  ( 286, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_separated_expressions (fn _ => let val  (
expression as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 79, ( result, expression1left, expression1right), 
rest671)
end
|  ( 287, ( ( _, ( MlyValue.one_or_more_separated_expressions 
one_or_more_separated_expressions1, _, 
one_or_more_separated_expressions1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_separated_expressions (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (one_or_more_separated_expressions as 
one_or_more_separated_expressions1) = 
one_or_more_separated_expressions1 ()
 in (expression::one_or_more_separated_expressions)
end)
 in ( LrTable.NT 79, ( result, expression1left, 
one_or_more_separated_expressions1right), rest671)
end
|  ( 288, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, META_IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.athena_meta_id (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (A.quotedIdeExp({name=ID,pos=getPos META_IDleft}))
end)
 in ( LrTable.NT 127, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 289, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.athena_meta_id (fn _ => let val  (ID as ID1) = ID1
 ()
 in (A.quotedIdeExp({name=ID,pos=getPos QUOTE_SYMBOLleft}))
end)
 in ( LrTable.NT 127, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 290, ( ( _, ( MlyValue.STRING STRING1, _, STRING1right)) :: ( _, 
( _, (QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let
 val  result = MlyValue.athena_meta_id (fn _ => let val  (STRING as 
STRING1) = STRING1 ()
 in (
let val escape = "\""
                                         val str = implode(map Char.chr STRING)
                                         val str' = escape ^ str ^ escape 
                                     in
                                        A.quotedIdeExp({name=str',pos=getPos QUOTE_SYMBOLleft})
                                     end
)
end)
 in ( LrTable.NT 127, ( result, QUOTE_SYMBOL1left, STRING1right), 
rest671)
end
|  ( 291, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.athena_var (fn _ => let val  (ID as ID1) = ID1 ()
 in (AthTermVar.athTermVar(ID))
end)
 in ( LrTable.NT 125, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 292, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, 
QMARK1left, _)) :: rest671)) => let val  result = MlyValue.athena_var
 (fn _ => let val  (ID as ID1) = ID1 ()
 in (AthTermVar.athTermVar(ID))
end)
 in ( LrTable.NT 125, ( result, QMARK1left, ID1right), rest671)
end
|  ( 293, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: _ :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671))
 => let val  result = MlyValue.ath_var (fn _ => let val  (ID as ID1) =
 ID1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),user_sort=NONE,
				pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 126, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 294, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.user_sort 
user_sort1, _, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: _ :: ( _,
 ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.ath_var (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),
							       user_sort=SOME(user_sort),pos=getPos LPARENleft})
)
end)
 in ( LrTable.NT 126, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 295, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QMARKleft as QMARK1left), _)) :: rest671)) => let val  result = 
MlyValue.ath_var (fn _ => let val  (ID as ID1) = ID1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),user_sort=NONE,pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 126, ( result, QMARK1left, ID1right), rest671)
end
|  ( 296, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, (QMARKleft as 
QMARK1left), _)) :: rest671)) => let val  result = MlyValue.ath_var
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.termVarExp({term_var=AthTermVar.athTermVar(ID),
						   user_sort=SOME(user_sort),pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 126, ( result, QMARK1left, user_sort1right), rest671)

end
|  ( 297, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.ath_var (fn _ => (
A.termVarExp({term_var=AthTermVar.fresh(),
						   user_sort=NONE,pos=getPos ANY_PATleft})
))
 in ( LrTable.NT 126, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 298, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.user_sort (fn _ => let val  (ID as ID1) = ID1 ()
 in (SymTerm.makeTaggedVar(Symbol.symbol(ID),getPos(QUOTE_SYMBOLleft))
)
end)
 in ( LrTable.NT 31, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 299, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.user_sort (fn _ => let val  (
ID as ID1) = ID1 ()
 in (
let val id_pos = getPos(IDleft)
                in
                   SymTerm.makeTaggedConstant(A.makeMS(ID,SOME id_pos),id_pos)
                end
)
end)
 in ( LrTable.NT 31, ( result, ID1left, ID1right), rest671)
end
|  ( 300, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_user_sorts one_or_more_user_sorts1, _, _)) :: ( _
, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.user_sort (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (one_or_more_user_sorts as one_or_more_user_sorts1) = 
one_or_more_user_sorts1 ()
 in (
let val id_pos = getPos(IDleft)
                 in
                   SymTerm.makeTaggedApp(A.makeMS(ID,SOME id_pos),id_pos,one_or_more_user_sorts)
                 end
)
end)
 in ( LrTable.NT 31, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 301, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_user_sorts one_or_more_user_sorts1, _, _)) :: ( _
, ( _, FUNleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.user_sort (fn _ => let val  (
one_or_more_user_sorts as one_or_more_user_sorts1) = 
one_or_more_user_sorts1 ()
 in (
let val id_pos = getPos(FUNleft)
                 in 
                   SymTerm.makeTaggedApp(A.makeMS("Fun",SOME id_pos),id_pos,one_or_more_user_sorts)
                 end
)
end)
 in ( LrTable.NT 31, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 302, ( ( _, ( MlyValue.user_sort user_sort1, user_sort1left, 
user_sort1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_user_sorts (fn _ => let val  (user_sort as 
user_sort1) = user_sort1 ()
 in ([user_sort])
end)
 in ( LrTable.NT 32, ( result, user_sort1left, user_sort1right), 
rest671)
end
|  ( 303, ( ( _, ( MlyValue.one_or_more_user_sorts 
one_or_more_user_sorts1, _, one_or_more_user_sorts1right)) :: ( _, ( 
MlyValue.user_sort user_sort1, user_sort1left, _)) :: rest671)) => let
 val  result = MlyValue.one_or_more_user_sorts (fn _ => let val  (
user_sort as user_sort1) = user_sort1 ()
 val  (one_or_more_user_sorts as one_or_more_user_sorts1) = 
one_or_more_user_sorts1 ()
 in (user_sort::one_or_more_user_sorts)
end)
 in ( LrTable.NT 32, ( result, user_sort1left, 
one_or_more_user_sorts1right), rest671)
end
|  ( 304, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.one_or_more_ids (fn _ => let val  (ID
 as ID1) = ID1 ()
 in ([ID])
end)
 in ( LrTable.NT 62, ( result, ID1left, ID1right), rest671)
end
|  ( 305, ( ( _, ( MlyValue.one_or_more_ids one_or_more_ids1, _, 
one_or_more_ids1right)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: 
rest671)) => let val  result = MlyValue.one_or_more_ids (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (one_or_more_ids as one_or_more_ids1) = one_or_more_ids1 ()
 in (ID::one_or_more_ids)
end)
 in ( LrTable.NT 62, ( result, ID1left, one_or_more_ids1right), 
rest671)
end
|  ( 306, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, DOMAINleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.ath_domain (fn _ => let val  (
ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,arity=0,sort_predicate=NONE,pos=getPos DOMAINleft})

end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 307, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
DOMAINleft as DOMAIN1left), _)) :: rest671)) => let val  result = 
MlyValue.ath_domain (fn _ => let val  (ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,arity=0,sort_predicate=NONE,pos=getPos DOMAINleft})

end)
 in ( LrTable.NT 20, ( result, DOMAIN1left, ID1right), rest671)
end
|  ( 308, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, _,
 _)) :: _ :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, 
DOMAINleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.ath_domain (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
 let val msym = A.makeMS(ID2,SOME (IDleft))
                 in
                    {name=S.symbol ID1,arity=0,sort_predicate=SOME(msym),pos=getPos DOMAINleft}
                 end
)
end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 309, ( ( _, ( _, _, RPAREN2right)) :: _ :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, _, _)) :: _ :: ( _, ( _, DOMAINleft, _)) :: ( _, ( _,
 LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_domain (fn _ => let val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,arity=length(one_or_more_params),sort_predicate=NONE,pos=getPos DOMAINleft}
)
end)
 in ( LrTable.NT 20, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 310, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, _, _)) :: _ :: ( _, ( _, (DOMAINleft as DOMAIN1left),
 _)) :: rest671)) => let val  result = MlyValue.ath_domain (fn _ =>
 let val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,arity=length(one_or_more_params),sort_predicate=NONE,pos=getPos DOMAINleft}
)
end)
 in ( LrTable.NT 20, ( result, DOMAIN1left, RPAREN1right), rest671)

end
|  ( 311, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_domains (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 in (
List.map (fn {name=n,pos=p} => {name=n,arity=0,sort_predicate=NONE,pos=p})
			  one_or_more_params
)
end)
 in ( LrTable.NT 21, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 312, ( ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, 
one_or_more_comma_separated_params1right)) :: ( _, ( _, DOMAINS1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_domains (fn _ =>
 let val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (
List.map (fn {name=n,pos=p} => {name=n,arity=0,sort_predicate=NONE,pos=p})
			  one_or_more_comma_separated_params
)
end)
 in ( LrTable.NT 21, ( result, DOMAINS1left, 
one_or_more_comma_separated_params1right), rest671)
end
|  ( 313, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.param 
param2, _, _)) :: ( _, ( MlyValue.param param1, _, _)) :: _ :: ( _, (
 _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.subsort (fn _ => let val  param1 = param1 ()
 val  param2 = param2 ()
 in (
let val (pos1,pos2) = (#pos(param1),#pos(param2))
                val (name1,name2) = (#name(param1),#name(param2))
                val (msym1,msym2) = (A.makeMS(Symbol.name(name1),SOME pos1),A.makeMS(Symbol.name name2,SOME pos2))
            in
               (msym1,pos1,msym2,pos2)
            end
)
end)
 in ( LrTable.NT 22, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 314, ( ( _, ( MlyValue.param param2, param2left, param2right)) ::
 ( _, ( MlyValue.param param1, param1left, _)) :: ( _, ( _, 
SUBSORT1left, _)) :: rest671)) => let val  result = MlyValue.subsort
 (fn _ => let val  param1 = param1 ()
 val  param2 = param2 ()
 in (
let val (pos1,pos2) = (getPos(param1left),getPos(param2left))
                val (name1,name2) = (#name(param1),#name(param2))
                val (msym1,msym2) = (A.makeMS(Symbol.name name1,SOME pos1),A.makeMS(Symbol.name name2,SOME pos2))
            in
               (msym1,pos1,msym2,pos2)
            end
)
end)
 in ( LrTable.NT 22, ( result, SUBSORT1left, param2right), rest671)

end
|  ( 315, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.param 
param1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_params 
one_or_more_params1, _, _)) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) ::
 rest671)) => let val  result = MlyValue.subsorts (fn _ => let val  (
one_or_more_params as one_or_more_params1) = one_or_more_params1 ()
 val  (param as param1) = param1 ()
 in (
let val mod_sym_and_pos_list = map (fn {name,pos,...}:A.param => (A.makeMS(Symbol.name name,SOME pos),pos)) one_or_more_params
                val (mod_sym,pos) = let val (name,pos) = (#name(param),#pos(param))
                                    in 
                                       (A.makeMS(Symbol.name name,SOME pos),pos)
                                    end
            in
              (mod_sym_and_pos_list,(mod_sym,pos))
            end
)
end)
 in ( LrTable.NT 23, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 316, ( ( _, ( MlyValue.param param1, _, param1right)) :: _ :: ( _
, ( MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: (
 _, ( _, SUBSORTS1left, _)) :: rest671)) => let val  result = 
MlyValue.subsorts (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (param as param1) = param1 ()
 in (
let val mod_sym_and_pos_list = map (fn {name,pos,...}:A.param => (A.makeMS(Symbol.name name,SOME pos),pos)) one_or_more_params
                val (mod_sym,pos) = let val (name,pos) = (#name(param),#pos(param))
                                    in 
                                       (A.makeMS(Symbol.name name,SOME pos),pos)
                                    end
            in
              (mod_sym_and_pos_list,(mod_sym,pos))
            end
)
end)
 in ( LrTable.NT 23, ( result, SUBSORTS1left, param1right), rest671)

end
|  ( 317, ( ( _, ( _, LEFT_ASSOC1left, LEFT_ASSOC1right)) :: rest671))
 => let val  result = MlyValue.associativity (fn _ => (true))
 in ( LrTable.NT 131, ( result, LEFT_ASSOC1left, LEFT_ASSOC1right), 
rest671)
end
|  ( 318, ( ( _, ( _, RIGHT_ASSOC1left, RIGHT_ASSOC1right)) :: rest671
)) => let val  result = MlyValue.associativity (fn _ => (false))
 in ( LrTable.NT 131, ( result, RIGHT_ASSOC1left, RIGHT_ASSOC1right), 
rest671)
end
|  ( 319, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.one_or_more_expressions one_or_more_expressions1, _, _)) :: (
 _, ( _, LEFT_BRACKET1left, _)) :: rest671)) => let val  result = 
MlyValue.input_transformer_declaration (fn _ => let val  (
one_or_more_expressions as one_or_more_expressions1) = 
one_or_more_expressions1 ()
 in (one_or_more_expressions)
end)
 in ( LrTable.NT 42, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 320, ( rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=NONE})
)
 in ( LrTable.NT 129, ( result, defaultPos, defaultPos), rest671)
end
|  ( 321, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (
input_transformer_declaration as input_transformer_declaration1) = 
input_transformer_declaration1 ()
 in (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=SOME input_transformer_declaration}
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 322, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671))
 => let val  result = MlyValue.declaration_prec_assoc (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],NONE))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 323, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],SOME(input_transformer_declaration)))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 324, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],NONE))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 325, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],SOME input_transformer_declaration))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 326, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 327, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: 
rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn _
 => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],
                                                                                                                         SOME input_transformer_declaration))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 328, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left
), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],NONE))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 329, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],
                                                                                                         SOME input_transformer_declaration))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 330, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],NONE))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 331, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],SOME input_transformer_declaration))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 332, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID3, ID3left, _)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],SOME input_transformer_declaration))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 333, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID3, 
ID3left, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as LPAREN1left)
, _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],NONE))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 334, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 335, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LPARENleft as LPAREN1left), _))
 :: rest671)) => let val  result = MlyValue.declaration_prec_assoc (fn
 _ => let val  (associativity as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 336, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _,
 ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result
 = MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 337, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 338, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)
) :: ( _, ( _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let
 val  result = MlyValue.declaration_prec_assoc (fn _ => let val  ID1 =
 ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],NONE))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 339, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _,
 ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],SOME input_transformer_declaration))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LPARENleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 129, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 340, ( rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=NONE})
)
 in ( LrTable.NT 130, ( result, defaultPos, defaultPos), rest671)
end
|  ( 341, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( _, LEFT_BRACKET1left, _)) :: rest671)) => let val  
result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
input_transformer_declaration as input_transformer_declaration1) = 
input_transformer_declaration1 ()
 in (
{precedence=NONE,assoc=NONE,overload_sym=NONE,input_transformer=SOME input_transformer_declaration}
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 342, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left),
 _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],NONE))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 343, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (
LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val  
result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as 
ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft)],SOME input_transformer_declaration))
                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 344, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],NONE))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 345, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId(associativity),getPos associativityleft)],SOME input_transformer_declaration))
                                                      handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 346, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val 
 result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 347, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left)
, _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left)],
                                                                                         SOME input_transformer_declaration))
                                             handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 348, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],NONE))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 349, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID,getPos IDleft),
                                                                                                        (A.makeAssocId associativity,getPos associativityleft)],
                                                                                                         SOME input_transformer_declaration))
                                                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 350, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID1, IDleft, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],NONE))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 351, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 val  (ID as ID1) = ID1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                                                       (ID,getPos IDleft)],SOME input_transformer_declaration))
                                                         handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 352, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID3, ID3left, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],NONE))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 353, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID3, ID3left, _)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _,
 (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val 
 result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),(ID2,getPos ID2left),(ID3,getPos ID3left)],SOME input_transformer_declaration))
                                                     handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 354, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  (
associativity as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 355, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID 
ID1, ID1left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  (associativity
 as associativity1) = associativity1 ()
 val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(A.makeAssocId associativity,getPos associativityleft),
                                                                        (ID1,getPos ID1left),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 356, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( MlyValue.ID 
ID2, ID2left, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: ( _,
 ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let
 val  result = MlyValue.sb_declaration_prec_assoc (fn _ => let val  
ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],NONE))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 357, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  (associativity as associativity1) = associativity1 ()
 val  ID2 = ID2 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (A.makeAssocId associativity,getPos associativityleft),(ID2,getPos ID2left)],SOME input_transformer_declaration))
                           handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 358, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.associativity associativity1, associativityleft, _)) :: ( _, 
( MlyValue.ID ID2, ID2left, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)
) :: ( _, ( _, (LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671
)) => let val  result = MlyValue.sb_declaration_prec_assoc (fn _ =>
 let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],NONE))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 359, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.input_transformer_declaration input_transformer_declaration1,
 _, _)) :: ( _, ( MlyValue.associativity associativity1, 
associativityleft, _)) :: ( _, ( MlyValue.ID ID2, ID2left, _)) :: ( _,
 ( MlyValue.ID ID1, ID1left, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.sb_declaration_prec_assoc (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  (associativity as associativity1) = associativity1 ()
 val  (input_transformer_declaration as input_transformer_declaration1
) = input_transformer_declaration1 ()
 in (
(A.getPrecAssocOverloadSymFromFSymDeclaration([(ID1,getPos ID1left),
                                                                        (ID2,getPos ID2left),(A.makeAssocId associativity,getPos associativityleft)],SOME input_transformer_declaration))
                          handle _ => Data.genEx("Abbreviated precedence/associativity/overloading declaration error.",
                                                                    SOME(getPos LEFT_BRACKETleft),(!Paths.current_file))
)
end)
 in ( LrTable.NT 130, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right
), rest671)
end
|  ( 360, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, _, _)) :: _ :: ( _, (
 MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: _ :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_constant_sym (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
List.map (fn {name=n,pos=p} => 
			  	{name=n,pos=p,obtype_params = [],argument_types=[],input_transformer=NONE,
		                    range_type=athena_object_type,prec=NONE,assoc=NONE,overload_sym=NONE}) one_or_more_params
)
end)
 in ( LrTable.NT 24, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 361, ( ( _, ( MlyValue.athena_object_type athena_object_type1, _,
 athena_object_type1right)) :: _ :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, DECLARE1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_constant_sym (fn _
 => let val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
List.map (fn {name=n,pos=p} => 
			  	{name=n,pos=p,obtype_params = [],argument_types=[],input_transformer=NONE,
		                    range_type=athena_object_type,prec=NONE,assoc=NONE,overload_sym=NONE}) 
                     one_or_more_comma_separated_params
)
end)
 in ( LrTable.NT 24, ( result, DECLARE1left, athena_object_type1right)
, rest671)
end
|  ( 362, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, _, _)) :: ( _, ( 
MlyValue.param param1, _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.ath_constant_sym (fn _ => let
 val  (param as param1) = param1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in (
let val n = #name(param) 
                       val p = #pos(param)
                    in [{name=n,pos=p,obtype_params = [],argument_types=[],range_type=athena_object_type,
                         input_transformer=NONE,prec=NONE,assoc=NONE,overload_sym=NONE}]
                   end
)
end)
 in ( LrTable.NT 24, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 363, ( ( _, ( _, _, RPAREN4right)) :: ( _, ( 
MlyValue.declaration_prec_assoc declaration_prec_assoc1, _, _)) :: _
 :: ( _, ( MlyValue.athena_object_type athena_object_type1, _, _)) ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: _ :: ( _, ( MlyValue.possible_obtype_params 
possible_obtype_params1, _, _)) :: _ :: _ :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: _ :: _ :: (
 _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_fsym (fn _ => let val  (one_or_more_params as 
one_or_more_params1) = one_or_more_params1 ()
 val  (possible_obtype_params as possible_obtype_params1) = 
possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (declaration_prec_assoc as declaration_prec_assoc1) = 
declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt:A.param option,input_transformer_option)  = 
                                   (#precedence(declaration_prec_assoc),#assoc(declaration_prec_assoc),
                                    #overload_sym(declaration_prec_assoc),#input_transformer(declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
             in
               List.map (fn {name=n,pos=p} =>
			  {name=n,pos=p,obtype_params = possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
	                   input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type}) one_or_more_params
             end
)
end)
 in ( LrTable.NT 25, ( result, LPAREN1left, RPAREN4right), rest671)

end
|  ( 364, ( ( _, ( MlyValue.sb_declaration_prec_assoc 
sb_declaration_prec_assoc1, _, sb_declaration_prec_assoc1right)) :: (
 _, ( MlyValue.athena_object_type athena_object_type1, _, _)) :: _ ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: ( _, ( 
MlyValue.comma_separated_possible_obtype_params 
comma_separated_possible_obtype_params1, _, _)) :: _ :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, DECLARE1left,
 _)) :: rest671)) => let val  result = MlyValue.ath_fsym (fn _ => let
 val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 val  (comma_separated_possible_obtype_params as 
comma_separated_possible_obtype_params1) = 
comma_separated_possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (sb_declaration_prec_assoc as sb_declaration_prec_assoc1) = 
sb_declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name comma_separated_possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt,input_transformer_option)  = 
                            (#precedence(sb_declaration_prec_assoc),#assoc(sb_declaration_prec_assoc),
                             #overload_sym(sb_declaration_prec_assoc),#input_transformer(sb_declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
             in
               List.map (fn {name=n,pos=p} =>
			  {name=n,pos=p,obtype_params = comma_separated_possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
	                   input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type})
			  one_or_more_comma_separated_params
             end
)
end)
 in ( LrTable.NT 25, ( result, DECLARE1left, 
sb_declaration_prec_assoc1right), rest671)
end
|  ( 365, ( ( _, ( _, _, RPAREN3right)) :: ( _, ( 
MlyValue.declaration_prec_assoc declaration_prec_assoc1, _, _)) :: _
 :: ( _, ( MlyValue.athena_object_type athena_object_type1, _, _)) ::
 _ :: ( _, ( MlyValue.athena_object_type_list athena_object_type_list1
, _, _)) :: _ :: _ :: ( _, ( MlyValue.possible_obtype_params 
possible_obtype_params1, _, _)) :: _ :: ( _, ( MlyValue.param param1,
 _, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.ath_fsym (fn _ => let val  (param as param1) = 
param1 ()
 val  (possible_obtype_params as possible_obtype_params1) = 
possible_obtype_params1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 val  (declaration_prec_assoc as declaration_prec_assoc1) = 
declaration_prec_assoc1 ()
 in (
let val ob_type_names = map #name possible_obtype_params
                 val (prec_opt,assoc_opt,overload_sym_opt,input_transformer_option)  = 
                                                              (#precedence(declaration_prec_assoc),#assoc(declaration_prec_assoc),
                                                               #overload_sym(declaration_prec_assoc),#input_transformer(declaration_prec_assoc))
                 val new_arg_types = map (fn t => Terms.taggedSymConstantsToVars(t,ob_type_names)) 
                                          athena_object_type_list
                 val new_range_type = Terms.taggedSymConstantsToVars(athena_object_type,ob_type_names)
                 fun app_name(n) = Symbol.symbol((Symbol.name(n))^"goo")
             in
               List.map (fn {name=n,pos=p} =>
                         {name=n,pos=p,obtype_params = possible_obtype_params,prec=prec_opt,assoc=assoc_opt,overload_sym=overload_sym_opt,
                          input_transformer=input_transformer_option,argument_types=new_arg_types,range_type=new_range_type}) [param]
             end
)
end)
 in ( LrTable.NT 25, ( result, LPAREN1left, RPAREN3right), rest671)

end
|  ( 366, ( rest671)) => let val  result = 
MlyValue.possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 60, ( result, defaultPos, defaultPos), rest671)
end
|  ( 367, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.possible_obtype_params (fn _ => let val  (one_or_more_params
 as one_or_more_params1) = one_or_more_params1 ()
 in (one_or_more_params)
end)
 in ( LrTable.NT 60, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 368, ( rest671)) => let val  result = 
MlyValue.comma_separated_possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 59, ( result, defaultPos, defaultPos), rest671)
end
|  ( 369, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = 
MlyValue.comma_separated_possible_obtype_params (fn _ => let val  (
one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (one_or_more_comma_separated_params)
end)
 in ( LrTable.NT 59, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 370, ( rest671)) => let val  result = 
MlyValue.bracket_enclosed_possible_obtype_params (fn _ => ([]))
 in ( LrTable.NT 61, ( result, defaultPos, defaultPos), rest671)
end
|  ( 371, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( _, 
LEFT_BRACKET1left, _)) :: rest671)) => let val  result = 
MlyValue.bracket_enclosed_possible_obtype_params (fn _ => let val  (
one_or_more_params as one_or_more_params1) = one_or_more_params1 ()
 in (one_or_more_params)
end)
 in ( LrTable.NT 61, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 372, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.ath_structure_profile (fn _
 => let val  (ID as ID1) = ID1 ()
 in ({name=S.symbol ID,pos=getPos IDleft,obtype_params=[]})
end)
 in ( LrTable.NT 19, ( result, ID1left, ID1right), rest671)
end
|  ( 373, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_params one_or_more_params1, _, _)) :: ( _, ( 
MlyValue.ID ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.ath_structure_profile (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (one_or_more_params as one_or_more_params1) = 
one_or_more_params1 ()
 in (
{name=S.symbol ID,pos=getPos IDleft,
                           obtype_params=one_or_more_params}
)
end)
 in ( LrTable.NT 19, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 374, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.ath_structure_constructor (fn
 _ => let val  (ID as ID1) = ID1 ()
 in (
{name=S.symbol ID,pos=getPos IDleft,argument_types=[],selectors=[]})

end)
 in ( LrTable.NT 26, ( result, ID1left, ID1right), rest671)
end
|  ( 375, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type_list 
selector_tagged_athena_object_type_list1, _, _)) :: ( _, ( MlyValue.ID
 ID1, IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.ath_structure_constructor (fn _ => let val  (
ID as ID1) = ID1 ()
 val  (selector_tagged_athena_object_type_list as 
selector_tagged_athena_object_type_list1) = 
selector_tagged_athena_object_type_list1 ()
 in (
let val (sels,otypes) = Basic.unZip(selector_tagged_athena_object_type_list)
			       in
				  {name=S.symbol ID,pos=getPos IDleft,selectors=sels,
                                   argument_types=otypes}
			       end
)
end)
 in ( LrTable.NT 26, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 376, ( ( _, ( MlyValue.ath_structure_constructor 
ath_structure_constructor1, ath_structure_constructor1left, 
ath_structure_constructor1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_ath_structure_constructors (fn _ => let val  (
ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 in ([ath_structure_constructor])
end)
 in ( LrTable.NT 27, ( result, ath_structure_constructor1left, 
ath_structure_constructor1right), rest671)
end
|  ( 377, ( ( _, ( MlyValue.one_or_more_ath_structure_constructors 
one_or_more_ath_structure_constructors1, _, 
one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.ath_structure_constructor ath_structure_constructor1, 
ath_structure_constructor1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_ath_structure_constructors (fn _ => let val  (
ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 val  (one_or_more_ath_structure_constructors as 
one_or_more_ath_structure_constructors1) = 
one_or_more_ath_structure_constructors1 ()
 in (ath_structure_constructor::one_or_more_ath_structure_constructors
)
end)
 in ( LrTable.NT 27, ( result, ath_structure_constructor1left, 
one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 378, ( ( _, ( MlyValue.ath_structure_constructor 
ath_structure_constructor1, ath_structure_constructor1left, 
ath_structure_constructor1right)) :: rest671)) => let val  result = 
MlyValue.infix_one_or_more_ath_structure_constructors (fn _ => let
 val  (ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 in ([ath_structure_constructor])
end)
 in ( LrTable.NT 28, ( result, ath_structure_constructor1left, 
ath_structure_constructor1right), rest671)
end
|  ( 379, ( ( _, ( 
MlyValue.infix_one_or_more_ath_structure_constructors 
infix_one_or_more_ath_structure_constructors1, _, 
infix_one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, _, _)) :: ( _, ( 
MlyValue.ath_structure_constructor ath_structure_constructor1, 
ath_structure_constructor1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_one_or_more_ath_structure_constructors (fn _ => let
 val  (ath_structure_constructor as ath_structure_constructor1) = 
ath_structure_constructor1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_one_or_more_ath_structure_constructors as 
infix_one_or_more_ath_structure_constructors1) = 
infix_one_or_more_ath_structure_constructors1 ()
 in (
ath_structure_constructor::infix_one_or_more_ath_structure_constructors
)
end)
 in ( LrTable.NT 28, ( result, ath_structure_constructor1left, 
infix_one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 380, ( ( _, ( MlyValue.one_or_more_ath_structure_constructors 
one_or_more_ath_structure_constructors1, _, 
one_or_more_ath_structure_constructors1right)) :: ( _, ( 
MlyValue.ath_structure_profile ath_structure_profile1, 
ath_structure_profile1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_struc_clause (fn _ => let val  (ath_structure_profile as 
ath_structure_profile1) = ath_structure_profile1 ()
 val  (one_or_more_ath_structure_constructors as 
one_or_more_ath_structure_constructors1) = 
one_or_more_ath_structure_constructors1 ()
 in (
let val name = #name ath_structure_profile
                      val pos = #pos ath_structure_profile
                      val obtype_params = #obtype_params ath_structure_profile 
                      val obtype_names = map #name obtype_params
                      fun constantsToVars({name,pos,argument_types,selectors}:A.absyn_structure_constructor) =
                          let fun f(t) = Terms.taggedSymConstantsToVars(t,obtype_names)
                              val new_ob_types = map f argument_types
                          in
                             {name=name,pos=pos,argument_types=new_ob_types,selectors=selectors}
                          end
                      in 
                         {name=name,pos=pos,obtype_params=obtype_params,free=false,
                          constructors=(map constantsToVars
                                            one_or_more_ath_structure_constructors)}
                  end
)
end)
 in ( LrTable.NT 14, ( result, ath_structure_profile1left, 
one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 381, ( ( _, ( 
MlyValue.infix_one_or_more_ath_structure_constructors 
infix_one_or_more_ath_structure_constructors1, _, 
infix_one_or_more_ath_structure_constructors1right)) :: _ :: ( _, ( 
MlyValue.ath_structure_profile ath_structure_profile1, 
ath_structure_profile1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_struc_clause (fn _ => let val  (
ath_structure_profile as ath_structure_profile1) = 
ath_structure_profile1 ()
 val  (infix_one_or_more_ath_structure_constructors as 
infix_one_or_more_ath_structure_constructors1) = 
infix_one_or_more_ath_structure_constructors1 ()
 in (
let val name = #name ath_structure_profile
                      val pos = #pos ath_structure_profile
                      val obtype_params = #obtype_params ath_structure_profile 
                      val obtype_names = map #name obtype_params
                      fun constantsToVars({name,pos,argument_types,selectors}:A.absyn_structure_constructor) =
                          let fun f(t) = Terms.taggedSymConstantsToVars(t,obtype_names)
                              val new_ob_types = map f argument_types
                          in
                             {name=name,pos=pos,argument_types=new_ob_types,selectors=selectors}
                          end
                      in 
                         {name=name,pos=pos,obtype_params=obtype_params,free=false,
                          constructors=(map constantsToVars
                                            infix_one_or_more_ath_structure_constructors)}
                  end
)
end)
 in ( LrTable.NT 15, ( result, ath_structure_profile1left, 
infix_one_or_more_ath_structure_constructors1right), rest671)
end
|  ( 382, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.rec_ath_struc_clause (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (ath_struc_clause)
end)
 in ( LrTable.NT 16, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 383, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_structure (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (ath_struc_clause)
end)
 in ( LrTable.NT 7, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 384, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.ath_struc_clause ath_struc_clause1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_datatype (fn _ => let val  (ath_struc_clause as 
ath_struc_clause1) = ath_struc_clause1 ()
 in (A.makeFree(ath_struc_clause))
end)
 in ( LrTable.NT 8, ( result, LPAREN1left, RPAREN1right), rest671)
end
|  ( 385, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, _, infix_ath_struc_clause1right)) :: ( _, ( _
, DATATYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatype (fn _ => let val  (infix_ath_struc_clause
 as infix_ath_struc_clause1) = infix_ath_struc_clause1 ()
 in (A.makeFree(infix_ath_struc_clause))
end)
 in ( LrTable.NT 9, ( result, DATATYPE1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 386, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, _, infix_ath_struc_clause1right)) :: ( _, ( _
, STRUCTURE1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatype (fn _ => let val  (infix_ath_struc_clause
 as infix_ath_struc_clause1) = infix_ath_struc_clause1 ()
 in (A.makeNonFree(infix_ath_struc_clause))
end)
 in ( LrTable.NT 9, ( result, STRUCTURE1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 387, ( ( _, ( MlyValue.rec_ath_struc_clause rec_ath_struc_clause1
, rec_ath_struc_clause1left, rec_ath_struc_clause1right)) :: rest671))
 => let val  result = MlyValue.one_or_more_rec_ath_struc_clauses (fn _
 => let val  (rec_ath_struc_clause as rec_ath_struc_clause1) = 
rec_ath_struc_clause1 ()
 in ([rec_ath_struc_clause])
end)
 in ( LrTable.NT 17, ( result, rec_ath_struc_clause1left, 
rec_ath_struc_clause1right), rest671)
end
|  ( 388, ( ( _, ( MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, 
one_or_more_rec_ath_struc_clauses1right)) :: ( _, ( 
MlyValue.rec_ath_struc_clause rec_ath_struc_clause1, 
rec_ath_struc_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_struc_clauses (fn _ => let val  (
rec_ath_struc_clause as rec_ath_struc_clause1) = rec_ath_struc_clause1
 ()
 val  (one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (rec_ath_struc_clause::one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 17, ( result, rec_ath_struc_clause1left, 
one_or_more_rec_ath_struc_clauses1right), rest671)
end
|  ( 389, ( ( _, ( MlyValue.infix_ath_struc_clause 
infix_ath_struc_clause1, infix_ath_struc_clause1left, 
infix_ath_struc_clause1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_datatype_clauses (fn _ => let val  (
infix_ath_struc_clause as infix_ath_struc_clause1) = 
infix_ath_struc_clause1 ()
 in ([infix_ath_struc_clause])
end)
 in ( LrTable.NT 18, ( result, infix_ath_struc_clause1left, 
infix_ath_struc_clause1right), rest671)
end
|  ( 390, ( ( _, ( MlyValue.one_or_more_rec_ath_datatype_clauses 
one_or_more_rec_ath_datatype_clauses1, _, 
one_or_more_rec_ath_datatype_clauses1right)) :: _ :: ( _, ( 
MlyValue.infix_ath_struc_clause infix_ath_struc_clause1, 
infix_ath_struc_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_rec_ath_datatype_clauses (fn _ => let val  (
infix_ath_struc_clause as infix_ath_struc_clause1) = 
infix_ath_struc_clause1 ()
 val  (one_or_more_rec_ath_datatype_clauses as 
one_or_more_rec_ath_datatype_clauses1) = 
one_or_more_rec_ath_datatype_clauses1 ()
 in (infix_ath_struc_clause::one_or_more_rec_ath_datatype_clauses)
end
)
 in ( LrTable.NT 18, ( result, infix_ath_struc_clause1left, 
one_or_more_rec_ath_datatype_clauses1right), rest671)
end
|  ( 391, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_structures (fn _ => let val  (
one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 11, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 392, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_rec_ath_struc_clauses 
one_or_more_rec_ath_struc_clauses1, _, _)) :: _ :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.ath_datatypes (fn _ => let val  (
one_or_more_rec_ath_struc_clauses as 
one_or_more_rec_ath_struc_clauses1) = 
one_or_more_rec_ath_struc_clauses1 ()
 in (List.map A.makeFree one_or_more_rec_ath_struc_clauses)
end)
 in ( LrTable.NT 12, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 393, ( ( _, ( MlyValue.one_or_more_rec_ath_datatype_clauses 
one_or_more_rec_ath_datatype_clauses1, _, 
one_or_more_rec_ath_datatype_clauses1right)) :: ( _, ( _, 
DATATYPES1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_ath_datatypes (fn _ => let val  (
one_or_more_rec_ath_datatype_clauses as 
one_or_more_rec_ath_datatype_clauses1) = 
one_or_more_rec_ath_datatype_clauses1 ()
 in (List.map A.makeFree one_or_more_rec_ath_datatype_clauses)
end)
 in ( LrTable.NT 13, ( result, DATATYPES1left, 
one_or_more_rec_ath_datatype_clauses1right), rest671)
end
|  ( 394, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.athena_object_type (fn _ =>
 let val  (ID as ID1) = ID1 ()
 in (
let val id_pos = getPos(IDleft)
                       in 
                          SymTerm.makeTaggedConstant(A.makeMS(ID,SOME id_pos),id_pos)
                       end
)
end)
 in ( LrTable.NT 30, ( result, ID1left, ID1right), rest671)
end
|  ( 395, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, _)) :: ( _, ( _, FUNleft, _)) :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.athena_object_type (fn _ => let val  (
one_or_more_athena_object_types as one_or_more_athena_object_types1) =
 one_or_more_athena_object_types1 ()
 in (
let val id_pos = getPos(FUNleft)
                        in
                           SymTerm.makeTaggedApp(A.makeMS("Fun",SOME id_pos),id_pos,one_or_more_athena_object_types)
                        end
)
end)
 in ( LrTable.NT 30, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 396, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, _)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.athena_object_type (fn _ => let val  (ID as ID1) = 
ID1 ()
 val  (one_or_more_athena_object_types as 
one_or_more_athena_object_types1) = one_or_more_athena_object_types1
 ()
 in (
let val id_pos = getPos(IDleft)
                        in
                           SymTerm.makeTaggedApp(A.makeMS(ID,SOME id_pos),id_pos,one_or_more_athena_object_types)
                        end
)
end)
 in ( LrTable.NT 30, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 397, ( ( _, ( MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, athena_object_type1right)) :: rest671)) =>
 let val  result = MlyValue.selector_tagged_athena_object_type (fn _
 => let val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ((NONE,athena_object_type))
end)
 in ( LrTable.NT 33, ( result, athena_object_type1left, 
athena_object_type1right), rest671)
end
|  ( 398, ( ( _, ( MlyValue.athena_object_type athena_object_type1, _,
 athena_object_type1right)) :: _ :: ( _, ( MlyValue.param param1, 
param1left, _)) :: rest671)) => let val  result = 
MlyValue.selector_tagged_athena_object_type (fn _ => let val  (param
 as param1) = param1 ()
 val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ((SOME(param),athena_object_type))
end)
 in ( LrTable.NT 33, ( result, param1left, athena_object_type1right), 
rest671)
end
|  ( 399, ( rest671)) => let val  result = 
MlyValue.athena_object_type_list (fn _ => ([]))
 in ( LrTable.NT 36, ( result, defaultPos, defaultPos), rest671)
end
|  ( 400, ( ( _, ( MlyValue.athena_object_type_list 
athena_object_type_list1, _, athena_object_type_list1right)) :: ( _, (
 MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, _)) :: rest671)) => let val  result = 
MlyValue.athena_object_type_list (fn _ => let val  (athena_object_type
 as athena_object_type1) = athena_object_type1 ()
 val  (athena_object_type_list as athena_object_type_list1) = 
athena_object_type_list1 ()
 in (athena_object_type::athena_object_type_list)
end)
 in ( LrTable.NT 36, ( result, athena_object_type1left, 
athena_object_type_list1right), rest671)
end
|  ( 401, ( rest671)) => let val  result = 
MlyValue.selector_tagged_athena_object_type_list (fn _ => ([]))
 in ( LrTable.NT 37, ( result, defaultPos, defaultPos), rest671)
end
|  ( 402, ( ( _, ( MlyValue.selector_tagged_athena_object_type_list 
selector_tagged_athena_object_type_list1, _, 
selector_tagged_athena_object_type_list1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, _)) :: rest671)) => let val  
result = MlyValue.selector_tagged_athena_object_type_list (fn _ => let
 val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 val  (selector_tagged_athena_object_type_list as 
selector_tagged_athena_object_type_list1) = 
selector_tagged_athena_object_type_list1 ()
 in (
selector_tagged_athena_object_type::selector_tagged_athena_object_type_list
)
end)
 in ( LrTable.NT 37, ( result, selector_tagged_athena_object_type1left
, selector_tagged_athena_object_type_list1right), rest671)
end
|  ( 403, ( ( _, ( MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, athena_object_type1right)) :: rest671)) =>
 let val  result = MlyValue.one_or_more_athena_object_types (fn _ =>
 let val  (athena_object_type as athena_object_type1) = 
athena_object_type1 ()
 in ([athena_object_type])
end)
 in ( LrTable.NT 34, ( result, athena_object_type1left, 
athena_object_type1right), rest671)
end
|  ( 404, ( ( _, ( MlyValue.one_or_more_athena_object_types 
one_or_more_athena_object_types1, _, 
one_or_more_athena_object_types1right)) :: ( _, ( 
MlyValue.athena_object_type athena_object_type1, 
athena_object_type1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_athena_object_types (fn _ => let val  (
athena_object_type as athena_object_type1) = athena_object_type1 ()
 val  (one_or_more_athena_object_types as 
one_or_more_athena_object_types1) = one_or_more_athena_object_types1
 ()
 in (athena_object_type::one_or_more_athena_object_types)
end)
 in ( LrTable.NT 34, ( result, athena_object_type1left, 
one_or_more_athena_object_types1right), rest671)
end
|  ( 405, ( ( _, ( MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, 
selector_tagged_athena_object_type1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_selector_tagged_athena_object_types (fn
 _ => let val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 in ([selector_tagged_athena_object_type])
end)
 in ( LrTable.NT 35, ( result, selector_tagged_athena_object_type1left
, selector_tagged_athena_object_type1right), rest671)
end
|  ( 406, ( ( _, ( 
MlyValue.one_or_more_selector_tagged_athena_object_types 
one_or_more_selector_tagged_athena_object_types1, _, 
one_or_more_selector_tagged_athena_object_types1right)) :: ( _, ( 
MlyValue.selector_tagged_athena_object_type 
selector_tagged_athena_object_type1, 
selector_tagged_athena_object_type1left, _)) :: rest671)) => let val  
result = MlyValue.one_or_more_selector_tagged_athena_object_types (fn
 _ => let val  (selector_tagged_athena_object_type as 
selector_tagged_athena_object_type1) = 
selector_tagged_athena_object_type1 ()
 val  (one_or_more_selector_tagged_athena_object_types as 
one_or_more_selector_tagged_athena_object_types1) = 
one_or_more_selector_tagged_athena_object_types1 ()
 in (
selector_tagged_athena_object_type::one_or_more_selector_tagged_athena_object_types
)
end)
 in ( LrTable.NT 35, ( result, selector_tagged_athena_object_type1left
, one_or_more_selector_tagged_athena_object_types1right), rest671)
end
|  ( 407, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.param (fn _ => let val  (ID
 as ID1) = ID1 ()
 in ({name=S.symbol ID, pos=getPos IDleft})
end)
 in ( LrTable.NT 38, ( result, ID1left, ID1right), rest671)
end
|  ( 408, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.param_no_dots (fn _ => let
 val  (ID as ID1) = ID1 ()
 in (
A.checkNoDots(ID,getPos IDleft);{name=S.symbol ID, pos=getPos IDleft})

end)
 in ( LrTable.NT 39, ( result, ID1left, ID1right), rest671)
end
|  ( 409, ( rest671)) => let val  result = MlyValue.param_option (fn _
 => (NONE))
 in ( LrTable.NT 51, ( result, defaultPos, defaultPos), rest671)
end
|  ( 410, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = MlyValue.param_option (fn _ => let
 val  (param as param1) = param1 ()
 in (SOME(#name(param)))
end)
 in ( LrTable.NT 51, ( result, param1left, param1right), rest671)
end
|  ( 411, ( rest671)) => let val  result = 
MlyValue.param_option_no_dots (fn _ => (NONE))
 in ( LrTable.NT 52, ( result, defaultPos, defaultPos), rest671)
end
|  ( 412, ( ( _, ( MlyValue.param_no_dots param_no_dots1, 
param_no_dots1left, param_no_dots1right)) :: rest671)) => let val  
result = MlyValue.param_option_no_dots (fn _ => let val  (
param_no_dots as param_no_dots1) = param_no_dots1 ()
 in (SOME(#name(param_no_dots)))
end)
 in ( LrTable.NT 52, ( result, param_no_dots1left, param_no_dots1right
), rest671)
end
|  ( 413, ( rest671)) => let val  result = MlyValue.params (fn _ => (
[]))
 in ( LrTable.NT 53, ( result, defaultPos, defaultPos), rest671)
end
|  ( 414, ( ( _, ( MlyValue.params params1, _, params1right)) :: ( _, 
( MlyValue.param param1, param1left, _)) :: rest671)) => let val  
result = MlyValue.params (fn _ => let val  (param as param1) = param1
 ()
 val  (params as params1) = params1 ()
 in (param::params)
end)
 in ( LrTable.NT 53, ( result, param1left, params1right), rest671)
end
|  ( 415, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), ID1right)) ::
 rest671)) => let val  result = MlyValue.possibly_typed_param (fn _ =>
 let val  (ID as ID1) = ID1 ()
 in (

                          {name=S.symbol ID, pos=getPos IDleft,sort_as_sym_term=NONE,sort_as_fterm=NONE,op_tag=NONE,sort_as_exp=NONE}
)
end)
 in ( LrTable.NT 47, ( result, ID1left, ID1right), rest671)
end
|  ( 416, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671))
 => let val  result = MlyValue.possibly_typed_param (fn _ => let val 
 (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (

                                          {name=S.symbol ID, pos=getPos IDleft,sort_as_sym_term=SOME user_sort,op_tag=NONE,
					    sort_as_fterm=NONE,sort_as_exp=NONE}
)
end)
 in ( LrTable.NT 47, ( result, ID1left, user_sort1right), rest671)
end
|  ( 417, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID2, 
ID2left, _)) :: _ :: _ :: _ :: ( _, ( MlyValue.ID ID1, ID1left, _)) ::
 rest671)) => let val  result = MlyValue.possibly_typed_param (fn _ =>
 let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 in (

                               (case Int.fromString(ID2) of
                                  SOME(i) => 
                                      ({name=S.symbol ID1, pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,~1),
  				        sort_as_fterm=NONE,sort_as_exp=NONE})
                                | _ => Data.genEx("Operator annotation error: invalid arity",
                                                  SOME(getPos ID2left),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 47, ( result, ID1left, RPAREN1right), rest671)
end
|  ( 418, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID3, _,
 _)) :: ( _, ( MlyValue.ID ID2, _, _)) :: _ :: ( _, ( _, LPARENleft, _
)) :: _ :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: rest671)) => let
 val  result = MlyValue.possibly_typed_param (fn _ => let val  ID1 = 
ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (

                               (case (Int.fromString(ID2),Int.fromString(ID3)) of
                                   (SOME(i),SOME(j)) => 
                                       ({name=S.symbol ID1, pos=getPos ID1left,sort_as_sym_term=NONE,op_tag=SOME(i,j),
  				         sort_as_fterm=NONE,sort_as_exp=NONE})
                                 | _ => Data.genEx("Operator annotation error: invalid arity and/or precedence",
                                                   SOME(getPos LPARENleft),(!Paths.current_file)))
)
end)
 in ( LrTable.NT 47, ( result, ID1left, RPAREN1right), rest671)
end
|  ( 419, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_typed_param_no_dots (fn _ =>
 let val  (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in (
let val res as {name,pos,...} = possibly_typed_param
                                   in
                                      (A.checkNoDots(S.name name,pos);res)
                                   end
)
end)
 in ( LrTable.NT 48, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 420, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_typed_params (fn _ => let val 
 (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in ([possibly_typed_param])
end)
 in ( LrTable.NT 49, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 421, ( ( _, ( MlyValue.possibly_typed_params 
possibly_typed_params1, _, possibly_typed_params1right)) :: ( _, ( 
MlyValue.possibly_typed_param possibly_typed_param1, 
possibly_typed_param1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_typed_params (fn _ => let val  (possibly_typed_param
 as possibly_typed_param1) = possibly_typed_param1 ()
 val  (possibly_typed_params as possibly_typed_params1) = 
possibly_typed_params1 ()
 in (possibly_typed_param::possibly_typed_params)
end)
 in ( LrTable.NT 49, ( result, possibly_typed_param1left, 
possibly_typed_params1right), rest671)
end
|  ( 422, ( ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right)) :: rest671)) => let val  result =
 MlyValue.possibly_typed_params_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 in ([possibly_typed_param_no_dots])
end)
 in ( LrTable.NT 50, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right), rest671)
end
|  ( 423, ( ( _, ( MlyValue.possibly_typed_params_no_dots 
possibly_typed_params_no_dots1, _, possibly_typed_params_no_dots1right
)) :: ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, _))
 :: rest671)) => let val  result = 
MlyValue.possibly_typed_params_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 val  (possibly_typed_params_no_dots as possibly_typed_params_no_dots1
) = possibly_typed_params_no_dots1 ()
 in (possibly_typed_param_no_dots::possibly_typed_params_no_dots)
end)
 in ( LrTable.NT 50, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_params_no_dots1right), rest671)
end
|  ( 424, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.possibly_wildcard_param (fn _ => let
 val  (possibly_typed_param as possibly_typed_param1) = 
possibly_typed_param1 ()
 in (A.someParam(possibly_typed_param))
end)
 in ( LrTable.NT 43, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 425, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.possibly_wildcard_param
 (fn _ => (A.wildCard(getPos ANY_PATleft)))
 in ( LrTable.NT 43, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 426, ( ( _, ( MlyValue.possibly_typed_param_no_dots 
possibly_typed_param_no_dots1, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right)) :: rest671)) => let val  result =
 MlyValue.possibly_wildcard_param_no_dots (fn _ => let val  (
possibly_typed_param_no_dots as possibly_typed_param_no_dots1) = 
possibly_typed_param_no_dots1 ()
 in (A.someParam(possibly_typed_param_no_dots))
end)
 in ( LrTable.NT 44, ( result, possibly_typed_param_no_dots1left, 
possibly_typed_param_no_dots1right), rest671)
end
|  ( 427, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_no_dots (fn _ => (
A.wildCard(getPos ANY_PATleft)))
 in ( LrTable.NT 44, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 428, ( rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list (fn _ => ([]))
 in ( LrTable.NT 45, ( result, defaultPos, defaultPos), rest671)
end
|  ( 429, ( ( _, ( MlyValue.possibly_wildcard_param_list 
possibly_wildcard_param_list1, _, possibly_wildcard_param_list1right))
 :: ( _, ( MlyValue.possibly_wildcard_param possibly_wildcard_param1, 
possibly_wildcard_param1left, _)) :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 val  (possibly_wildcard_param_list as possibly_wildcard_param_list1)
 = possibly_wildcard_param_list1 ()
 in (possibly_wildcard_param::possibly_wildcard_param_list)
end)
 in ( LrTable.NT 45, ( result, possibly_wildcard_param1left, 
possibly_wildcard_param_list1right), rest671)
end
|  ( 430, ( rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list_no_dots (fn _ => ([]))
 in ( LrTable.NT 46, ( result, defaultPos, defaultPos), rest671)
end
|  ( 431, ( ( _, ( MlyValue.possibly_wildcard_param_list_no_dots 
possibly_wildcard_param_list_no_dots1, _, 
possibly_wildcard_param_list_no_dots1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param_no_dots 
possibly_wildcard_param_no_dots1, possibly_wildcard_param_no_dots1left
, _)) :: rest671)) => let val  result = 
MlyValue.possibly_wildcard_param_list_no_dots (fn _ => let val  (
possibly_wildcard_param_no_dots as possibly_wildcard_param_no_dots1) =
 possibly_wildcard_param_no_dots1 ()
 val  (possibly_wildcard_param_list_no_dots as 
possibly_wildcard_param_list_no_dots1) = 
possibly_wildcard_param_list_no_dots1 ()
 in (
possibly_wildcard_param_no_dots::possibly_wildcard_param_list_no_dots)

end)
 in ( LrTable.NT 46, ( result, possibly_wildcard_param_no_dots1left, 
possibly_wildcard_param_list_no_dots1right), rest671)
end
|  ( 432, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = 
MlyValue.one_or_more_comma_separated_params (fn _ => let val  (param
 as param1) = param1 ()
 in ([param])
end)
 in ( LrTable.NT 58, ( result, param1left, param1right), rest671)
end
|  ( 433, ( ( _, ( MlyValue.one_or_more_comma_separated_params 
one_or_more_comma_separated_params1, _, 
one_or_more_comma_separated_params1right)) :: _ :: ( _, ( 
MlyValue.param param1, param1left, _)) :: rest671)) => let val  result
 = MlyValue.one_or_more_comma_separated_params (fn _ => let val  (
param as param1) = param1 ()
 val  (one_or_more_comma_separated_params as 
one_or_more_comma_separated_params1) = 
one_or_more_comma_separated_params1 ()
 in (param::one_or_more_comma_separated_params)
end)
 in ( LrTable.NT 58, ( result, param1left, 
one_or_more_comma_separated_params1right), rest671)
end
|  ( 434, ( ( _, ( MlyValue.param param1, param1left, param1right)) ::
 rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps (fn _ => let val  (param
 as param1) = param1 ()
 in ([param])
end)
 in ( LrTable.NT 54, ( result, param1left, param1right), rest671)
end
|  ( 435, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps 
one_or_more_params_maybe_with_reps1, _, 
one_or_more_params_maybe_with_reps1right)) :: ( _, ( MlyValue.param 
param1, param1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps (fn _ => let val  (param
 as param1) = param1 ()
 val  (one_or_more_params_maybe_with_reps as 
one_or_more_params_maybe_with_reps1) = 
one_or_more_params_maybe_with_reps1 ()
 in (param::one_or_more_params_maybe_with_reps)
end)
 in ( LrTable.NT 54, ( result, param1left, 
one_or_more_params_maybe_with_reps1right), rest671)
end
|  ( 436, ( ( _, ( MlyValue.param_no_dots param_no_dots1, 
param_no_dots1left, param_no_dots1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_params_maybe_with_reps_no_dots (fn _ =>
 let val  (param_no_dots as param_no_dots1) = param_no_dots1 ()
 in ([param_no_dots])
end)
 in ( LrTable.NT 55, ( result, param_no_dots1left, param_no_dots1right
), rest671)
end
|  ( 437, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps_no_dots
 one_or_more_params_maybe_with_reps_no_dots1, _, 
one_or_more_params_maybe_with_reps_no_dots1right)) :: ( _, ( 
MlyValue.param_no_dots param_no_dots1, param_no_dots1left, _)) :: 
rest671)) => let val  result = 
MlyValue.one_or_more_params_maybe_with_reps_no_dots (fn _ => let val 
 (param_no_dots as param_no_dots1) = param_no_dots1 ()
 val  (one_or_more_params_maybe_with_reps_no_dots as 
one_or_more_params_maybe_with_reps_no_dots1) = 
one_or_more_params_maybe_with_reps_no_dots1 ()
 in (param_no_dots::one_or_more_params_maybe_with_reps_no_dots)
end)
 in ( LrTable.NT 55, ( result, param_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right), rest671)
end
|  ( 438, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps 
one_or_more_params_maybe_with_reps1, 
one_or_more_params_maybe_with_reps1left, 
one_or_more_params_maybe_with_reps1right)) :: rest671)) => let val  
result = MlyValue.one_or_more_params (fn _ => let val  (
one_or_more_params_maybe_with_reps as 
one_or_more_params_maybe_with_reps1) = 
one_or_more_params_maybe_with_reps1 ()
 in (A.getParams(one_or_more_params_maybe_with_reps))
end)
 in ( LrTable.NT 56, ( result, one_or_more_params_maybe_with_reps1left
, one_or_more_params_maybe_with_reps1right), rest671)
end
|  ( 439, ( ( _, ( MlyValue.one_or_more_params_maybe_with_reps_no_dots
 one_or_more_params_maybe_with_reps_no_dots1, 
one_or_more_params_maybe_with_reps_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right)) :: rest671)) => let
 val  result = MlyValue.one_or_more_params_no_dots (fn _ => let val  (
one_or_more_params_maybe_with_reps_no_dots as 
one_or_more_params_maybe_with_reps_no_dots1) = 
one_or_more_params_maybe_with_reps_no_dots1 ()
 in (A.getParams(one_or_more_params_maybe_with_reps_no_dots))
end)
 in ( LrTable.NT 57, ( result, 
one_or_more_params_maybe_with_reps_no_dots1left, 
one_or_more_params_maybe_with_reps_no_dots1right), rest671)
end
|  ( 440, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.struc_pattern (fn _ => (
A.anyPat({pos=getPos ANY_PATleft})))
 in ( LrTable.NT 89, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 441, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.struc_pattern (fn _ => let val  (
possibly_typed_param as possibly_typed_param1) = possibly_typed_param1
 ()
 in (A.idPat(possibly_typed_param))
end)
 in ( LrTable.NT 89, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 442, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.struc_patterns struc_patterns1, _, _)) :: ( _, ( _, (
LEFT_BRACKETleft as LEFT_BRACKET1left), _)) :: rest671)) => let val  
result = MlyValue.struc_pattern (fn _ => let val  (struc_patterns as 
struc_patterns1) = struc_patterns1 ()
 in (
A.listPats({member_pats=struc_patterns,pos=getPos LEFT_BRACKETleft}))

end)
 in ( LrTable.NT 89, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 443, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.struc_pattern struc_pattern2, _, _)) :: ( _, ( 
MlyValue.struc_pattern struc_pattern1, _, _)) :: ( _, ( _, LISTleft, _
)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.struc_pattern (fn _ => let val  struc_pattern1 = 
struc_pattern1 ()
 val  struc_pattern2 = struc_pattern2 ()
 in (
A.listPat({head_pat=struc_pattern1,tail_pat=struc_pattern2,pos=getPos LISTleft})
)
end)
 in ( LrTable.NT 89, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 444, ( rest671)) => let val  result = MlyValue.struc_patterns (fn
 _ => ([]))
 in ( LrTable.NT 91, ( result, defaultPos, defaultPos), rest671)
end
|  ( 445, ( ( _, ( MlyValue.struc_patterns struc_patterns1, _, 
struc_patterns1right)) :: ( _, ( MlyValue.struc_pattern struc_pattern1
, struc_pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.struc_patterns (fn _ => let val  (struc_pattern as 
struc_pattern1) = struc_pattern1 ()
 val  (struc_patterns as struc_patterns1) = struc_patterns1 ()
 in (struc_pattern::struc_patterns)
end)
 in ( LrTable.NT 91, ( result, struc_pattern1left, 
struc_patterns1right), rest671)
end
|  ( 446, ( ( _, ( _, (ANY_PATleft as ANY_PAT1left), ANY_PAT1right))
 :: rest671)) => let val  result = MlyValue.pattern (fn _ => (
A.anyPat({pos=getPos ANY_PATleft})))
 in ( LrTable.NT 88, ( result, ANY_PAT1left, ANY_PAT1right), rest671)

end
|  ( 447, ( ( _, ( MlyValue.expression expression1, expressionleft, 
expression1right)) :: ( _, ( _, EXCL_MARK1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  (expression as 
expression1) = expression1 ()
 in (A.makeCharConstraintRE(expression,getPos(expressionleft)))
end)
 in ( LrTable.NT 88, ( result, EXCL_MARK1left, expression1right), 
rest671)
end
|  ( 448, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => (A.unitValPat({pos=getPos LPARENleft})))
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 449, ( ( _, ( MlyValue.possibly_typed_param possibly_typed_param1
, possibly_typed_param1left, possibly_typed_param1right)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_typed_param as possibly_typed_param1) = possibly_typed_param1
 ()
 in (A.idPat(possibly_typed_param))
end)
 in ( LrTable.NT 88, ( result, possibly_typed_param1left, 
possibly_typed_param1right), rest671)
end
|  ( 450, ( ( _, ( MlyValue.STRING STRING1, (STRINGleft as STRING1left
), STRING1right)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (A.constantStringPat({str=STRING,pos=getPos STRINGleft}))
end)
 in ( LrTable.NT 88, ( result, STRING1left, STRING1right), rest671)

end
|  ( 451, ( ( _, ( _, _, RIGHT_BRACKET1right)) :: ( _, ( 
MlyValue.patterns patterns1, _, _)) :: ( _, ( _, (LEFT_BRACKETleft as 
LEFT_BRACKET1left), _)) :: rest671)) => let val  result = 
MlyValue.pattern (fn _ => let val  (patterns as patterns1) = patterns1
 ()
 in (A.listPats({member_pats=patterns,pos=getPos LEFT_BRACKETleft}))

end)
 in ( LrTable.NT 88, ( result, LEFT_BRACKET1left, RIGHT_BRACKET1right)
, rest671)
end
|  ( 452, ( ( _, ( MlyValue.athena_var athena_var1, (athena_varleft
 as athena_var1left), athena_var1right)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (athena_var as athena_var1
) = athena_var1 ()
 in (
A.constantTermVarPat({term_var=athena_var,pos=getPos athena_varleft}))

end)
 in ( LrTable.NT 88, ( result, athena_var1left, athena_var1right), 
rest671)
end
|  ( 453, ( ( _, ( MlyValue.user_sort user_sort1, _, user_sort1right))
 :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, (QMARKleft as 
QMARK1left), _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (user_sort as user_sort1) = user_sort1 ()
 in (
A.constantTermVarPat({term_var=AthTermVar.athTermVarWithSort(ID,FTerm.translateFromSymTerm(SymTerm.stripTags user_sort)),
						          pos=getPos QMARKleft})
)
end)
 in ( LrTable.NT 88, ( result, QMARK1left, user_sort1right), rest671)

end
|  ( 454, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, _,
 _)) :: ( _, ( _, META_IDleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (ID
 as ID1) = ID1 ()
 in (A.constantMetaIdPat({name=S.symbol ID,pos=getPos META_IDleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 455, ( ( _, ( MlyValue.ID ID1, _, ID1right)) :: ( _, ( _, (
QUOTE_SYMBOLleft as QUOTE_SYMBOL1left), _)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 in (
A.constantMetaIdPat({name=S.symbol ID,pos=getPos QUOTE_SYMBOLleft}))

end)
 in ( LrTable.NT 88, ( result, QUOTE_SYMBOL1left, ID1right), rest671)

end
|  ( 456, ( ( _, ( MlyValue.CHARACTER CHARACTER1, (CHARACTERleft as 
CHARACTER1left), CHARACTER1right)) :: rest671)) => let val  result = 
MlyValue.pattern (fn _ => let val  (CHARACTER as CHARACTER1) = 
CHARACTER1 ()
 in (A.constantCharPat({ch=CHARACTER,pos=getPos CHARACTERleft}))
end)
 in ( LrTable.NT 88, ( result, CHARACTER1left, CHARACTER1right), 
rest671)
end
|  ( 457, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( _, VAL_OFleft, _)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.pattern (fn _ => let val 
 (ID as ID1) = ID1 ()
 in (
A.valOfPat({id={name=S.symbol ID,pos=getPos IDleft},lex_ad=NONE,
                                               pos=getPos VAL_OFleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 458, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_VARleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someVarPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_VARleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 459, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_VECTORleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someVectorPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_VECTORleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 460, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_CHARleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someCharPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_CHARleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 461, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_QUANTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someQuantPat({id=possibly_wildcard_param,
                                                       pos=getPos SOME_QUANTleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 462, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_PROP_CONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.somePropConPat({id=possibly_wildcard_param,
                                                            pos=getPos SOME_PROP_CONleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 463, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_TERMleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someTermPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_TERMleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 464, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_ATOMleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someAtomPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_ATOMleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 465, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_PROPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.somePropPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_PROPleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 466, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_FUNCTIONleft, _)) :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someFunctionPat({id=possibly_wildcard_param,
                                                             pos=getPos SOME_FUNCTIONleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 467, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_METHODleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someMethodPat({id=possibly_wildcard_param,
                                                         pos=getPos SOME_METHODleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 468, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_SYMBOLleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671
)) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someSymbolPat({id=possibly_wildcard_param,
                                                         pos=getPos SOME_SYMBOLleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 469, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_SUBleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someSubPat({id=possibly_wildcard_param,
                                                   pos=getPos SOME_SUBleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 470, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_TABLEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)
) => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someTablePat({id=possibly_wildcard_param,pos=getPos SOME_TABLEleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 471, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_MAPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someMapPat({id=possibly_wildcard_param,pos=getPos SOME_MAPleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 472, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern2, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, LISTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.pattern (fn _ => let val  pattern1 = pattern1
 ()
 val  pattern2 = pattern2 ()
 in (
A.listPat({head_pat=pattern1,tail_pat=pattern2,pos=getPos LISTleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 473, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, CELLleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 in (A.cellPat({pat=pattern,pos=getPos CELLleft}))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 474, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.two_or_more_patterns two_or_more_patterns1, _, _)) :: ( _, (
 _, SPLIT_PATleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  (
two_or_more_patterns as two_or_more_patterns1) = two_or_more_patterns1
 ()
 in (
A.splitPat({pats=two_or_more_patterns,pos=getPos SPLIT_PATleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 475, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_STARleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.reStarPat({pat=pattern,pos=getPos RE_STARleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 476, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_OPTIONALleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.reOptPat({pat=pattern,pos=getPos RE_OPTIONALleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 477, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_PLUSleft, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (pattern as pattern1) = pattern1 ()
 in (
A.rePlusPat({pat=pattern,pos=getPos RE_PLUSleft,code=A.getRECode(),re_form=GeneralRE.any0(GeneralRE.trivial_tag)})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 478, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, RE_LITleft, _)) :: ( _, ( _, LPAREN1left
, _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 in (A.reLitPat({pat=pattern,pos=getPos RE_LITleft}))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 479, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern2, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, RE_RANGEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) =>
 let val  result = MlyValue.pattern (fn _ => let val  pattern1 = 
pattern1 ()
 val  pattern2 = pattern2 ()
 in (
let val (l,h) = A.getPatCodes(pattern1,pattern2)
              in
                 A.reRangePat({from_pat=pattern1,to_pat=pattern2,lo=l,hi=h,pos=getPos RE_RANGEleft})
              end
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 480, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, ( _, 
RE_REPleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.pattern (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (ID as ID1) = ID1 ()
 in (
case Int.fromString(ID) of
                                               SOME(i) => A.reRepPat({pat=pattern,times=i,pos=getPos RE_REPleft,re_form=GeneralRE.any0(GeneralRE.trivial_tag),code=A.getRECode()})
                                             | _ => raise A.SyntaxError("an integer numeral was expected here",SOME(getPos IDleft))
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 481, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_LISTleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someListPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_LISTleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 482, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.possibly_wildcard_param possibly_wildcard_param1, _, _)) :: (
 _, ( _, SOME_CELLleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671))
 => let val  result = MlyValue.pattern (fn _ => let val  (
possibly_wildcard_param as possibly_wildcard_param1) = 
possibly_wildcard_param1 ()
 in (
A.someCellPat({id=possibly_wildcard_param,
                                                     pos=getPos SOME_CELLleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 483, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.pattern pattern1, 
patternleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.pattern (fn _ => let val  (pattern as pattern1
) = pattern1 ()
 val  (expression as expression1) = expression1 ()
 in (A.wherePat({pat=pattern,guard=expression,pos=getPos patternleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 484, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_patterns one_or_more_patterns1, 
one_or_more_patternsleft, _)) :: _ :: ( _, ( _, LPAREN1left, _)) :: 
rest671)) => let val  result = MlyValue.pattern (fn _ => let val  (
one_or_more_patterns as one_or_more_patterns1) = one_or_more_patterns1
 ()
 in (
A.disjPat({pats=one_or_more_patterns,pos=getPos one_or_more_patternsleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 485, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.one_or_more_patterns one_or_more_patterns1, _, _)) :: ( _, ( 
MlyValue.pattern pattern1, patternleft, _)) :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.pattern (fn _ => let
 val  (pattern as pattern1) = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (
A.compoundPat({head_pat=pattern,rest_pats=one_or_more_patterns,pos=getPos patternleft})
)
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 486, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, 
NAMEleft, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 val  (pattern as pattern1) = pattern1 ()
 in (A.namedPat({name=S.symbol ID,pat=pattern,pos=getPos NAMEleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 487, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.pattern 
pattern1, _, _)) :: ( _, ( _, NAMEleft, _)) :: ( _, ( MlyValue.ID ID1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.pattern (fn _ => let val  (ID as ID1) = ID1 ()
 val  (pattern as pattern1) = pattern1 ()
 in (A.namedPat({name=S.symbol ID,pat=pattern,pos=getPos NAMEleft}))

end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 488, ( ( _, ( MlyValue.pattern pattern1, pattern1left, 
pattern1right)) :: rest671)) => let val  result = 
MlyValue.one_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 in ([pattern])
end)
 in ( LrTable.NT 101, ( result, pattern1left, pattern1right), rest671)

end
|  ( 489, ( ( _, ( MlyValue.one_or_more_patterns one_or_more_patterns1
, _, one_or_more_patterns1right)) :: ( _, ( MlyValue.pattern pattern1,
 pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.one_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (pattern::one_or_more_patterns)
end)
 in ( LrTable.NT 101, ( result, pattern1left, 
one_or_more_patterns1right), rest671)
end
|  ( 490, ( ( _, ( MlyValue.one_or_more_patterns one_or_more_patterns1
, _, one_or_more_patterns1right)) :: ( _, ( MlyValue.pattern pattern1,
 pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.two_or_more_patterns (fn _ => let val  (pattern as pattern1)
 = pattern1 ()
 val  (one_or_more_patterns as one_or_more_patterns1) = 
one_or_more_patterns1 ()
 in (pattern::one_or_more_patterns)
end)
 in ( LrTable.NT 102, ( result, pattern1left, 
one_or_more_patterns1right), rest671)
end
|  ( 491, ( rest671)) => let val  result = MlyValue.patterns (fn _ =>
 ([]))
 in ( LrTable.NT 90, ( result, defaultPos, defaultPos), rest671)
end
|  ( 492, ( ( _, ( MlyValue.patterns patterns1, _, patterns1right)) ::
 ( _, ( MlyValue.pattern pattern1, pattern1left, _)) :: rest671)) =>
 let val  result = MlyValue.patterns (fn _ => let val  (pattern as 
pattern1) = pattern1 ()
 val  (patterns as patterns1) = patterns1 ()
 in (pattern::patterns)
end)
 in ( LrTable.NT 90, ( result, pattern1left, patterns1right), rest671)

end
|  ( 493, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = MlyValue.condition (fn _ => let
 val  (phrase as phrase1) = phrase1 ()
 in (A.boolCond(phrase))
end)
 in ( LrTable.NT 100, ( result, phrase1left, phrase1right), rest671)

end
|  ( 494, ( ( _, ( _, ELSE1left, ELSE1right)) :: rest671)) => let val 
 result = MlyValue.condition (fn _ => (A.elseCond))
 in ( LrTable.NT 100, ( result, ELSE1left, ELSE1right), rest671)
end
|  ( 495, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.condition condition1, _, _)) ::
 ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.check_clause (fn _ => let val  (condition as condition1) = 
condition1 ()
 val  (expression as expression1) = expression1 ()
 in ({test=condition,result=expression})
end)
 in ( LrTable.NT 92, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 496, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.condition condition1, 
condition1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_check_clause (fn _ => let val  (condition as condition1
) = condition1 ()
 val  (expression as expression1) = expression1 ()
 in ({test=condition,result=expression})
end)
 in ( LrTable.NT 93, ( result, condition1left, expression1right), 
rest671)
end
|  ( 497, ( ( _, ( MlyValue.infix_check_clause infix_check_clause1, 
infix_check_clause1left, infix_check_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_check_clauses (fn _ => let val  (
infix_check_clause as infix_check_clause1) = infix_check_clause1 ()
 in ([infix_check_clause])
end)
 in ( LrTable.NT 94, ( result, infix_check_clause1left, 
infix_check_clause1right), rest671)
end
|  ( 498, ( ( _, ( MlyValue.infix_check_clauses infix_check_clauses1,
 _, infix_check_clauses1right)) :: ( _, ( MlyValue.single_logical_or 
single_logical_or1, _, _)) :: ( _, ( MlyValue.infix_check_clause 
infix_check_clause1, infix_check_clause1left, _)) :: rest671)) => let
 val  result = MlyValue.infix_check_clauses (fn _ => let val  (
infix_check_clause as infix_check_clause1) = infix_check_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_check_clauses as infix_check_clauses1) = 
infix_check_clauses1 ()
 in (infix_check_clause::infix_check_clauses)
end)
 in ( LrTable.NT 94, ( result, infix_check_clause1left, 
infix_check_clauses1right), rest671)
end
|  ( 499, ( rest671)) => let val  result = MlyValue.check_clauses (fn
 _ => ([]))
 in ( LrTable.NT 95, ( result, defaultPos, defaultPos), rest671)
end
|  ( 500, ( ( _, ( MlyValue.check_clauses check_clauses1, _, 
check_clauses1right)) :: ( _, ( MlyValue.check_clause check_clause1, 
check_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.check_clauses (fn _ => let val  (check_clause as 
check_clause1) = check_clause1 ()
 val  (check_clauses as check_clauses1) = check_clauses1 ()
 in (check_clause::check_clauses)
end)
 in ( LrTable.NT 95, ( result, check_clause1left, check_clauses1right)
, rest671)
end
|  ( 501, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.condition condition1, _, _)) :: 
( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.dcheck_clause (fn _ => let val  (condition as condition1) = 
condition1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({test=condition,result=deduction})
end)
 in ( LrTable.NT 96, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 502, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.condition condition1, condition1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_dcheck_clause (fn _ =>
 let val  (condition as condition1) = condition1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({test=condition,result=deduction})
end)
 in ( LrTable.NT 97, ( result, condition1left, deduction1right), 
rest671)
end
|  ( 503, ( ( _, ( MlyValue.infix_dcheck_clause infix_dcheck_clause1, 
infix_dcheck_clause1left, infix_dcheck_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_dcheck_clauses (fn _ => let val  (
infix_dcheck_clause as infix_dcheck_clause1) = infix_dcheck_clause1 ()
 in ([infix_dcheck_clause])
end)
 in ( LrTable.NT 98, ( result, infix_dcheck_clause1left, 
infix_dcheck_clause1right), rest671)
end
|  ( 504, ( ( _, ( MlyValue.infix_dcheck_clauses infix_dcheck_clauses1
, _, infix_dcheck_clauses1right)) :: ( _, ( MlyValue.single_logical_or
 single_logical_or1, _, _)) :: ( _, ( MlyValue.infix_dcheck_clause 
infix_dcheck_clause1, infix_dcheck_clause1left, _)) :: rest671)) =>
 let val  result = MlyValue.infix_dcheck_clauses (fn _ => let val  (
infix_dcheck_clause as infix_dcheck_clause1) = infix_dcheck_clause1 ()
 val  single_logical_or1 = single_logical_or1 ()
 val  (infix_dcheck_clauses as infix_dcheck_clauses1) = 
infix_dcheck_clauses1 ()
 in (infix_dcheck_clause::infix_dcheck_clauses)
end)
 in ( LrTable.NT 98, ( result, infix_dcheck_clause1left, 
infix_dcheck_clauses1right), rest671)
end
|  ( 505, ( rest671)) => let val  result = MlyValue.dcheck_clauses (fn
 _ => ([]))
 in ( LrTable.NT 99, ( result, defaultPos, defaultPos), rest671)
end
|  ( 506, ( ( _, ( MlyValue.dcheck_clauses dcheck_clauses1, _, 
dcheck_clauses1right)) :: ( _, ( MlyValue.dcheck_clause dcheck_clause1
, dcheck_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.dcheck_clauses (fn _ => let val  (dcheck_clause as 
dcheck_clause1) = dcheck_clause1 ()
 val  (dcheck_clauses as dcheck_clauses1) = dcheck_clauses1 ()
 in (dcheck_clause::dcheck_clauses)
end)
 in ( LrTable.NT 99, ( result, dcheck_clause1left, 
dcheck_clauses1right), rest671)
end
|  ( 507, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.match_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 103, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 508, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.deduction 
deduction1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _,
 ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.dmatch_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 105, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 509, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.pattern pattern1, pattern1left, _)) :: 
rest671)) => let val  result = MlyValue.infix_dmatch_clause (fn _ =>
 let val  (pattern as pattern1) = pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 106, ( result, pattern1left, deduction1right), 
rest671)
end
|  ( 510, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.pattern pattern1, 
pattern1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_match_clause (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 107, ( result, pattern1left, expression1right), 
rest671)
end
|  ( 511, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: _ :: ( _, ( MlyValue.pattern pattern1, _, _)) ::
 ( _, ( MlyValue.single_logical_or single_logical_or1, 
single_logical_or1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clause (fn _ => let val  single_logical_or1 =
 single_logical_or1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  (expression as expression1) = expression1 ()
 in ({pat=pattern,exp=expression})
end)
 in ( LrTable.NT 108, ( result, single_logical_or1left, 
expression1right), rest671)
end
|  ( 512, ( ( _, ( MlyValue.deduction deduction1, _, deduction1right))
 :: _ :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, ( 
MlyValue.single_logical_or single_logical_or1, single_logical_or1left,
 _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clause (fn _ => let val  single_logical_or1
 = single_logical_or1 ()
 val  (pattern as pattern1) = pattern1 ()
 val  (deduction as deduction1) = deduction1 ()
 in ({pat=pattern,ded=deduction})
end)
 in ( LrTable.NT 109, ( result, single_logical_or1left, 
deduction1right), rest671)
end
|  ( 513, ( rest671)) => let val  result = MlyValue.match_clauses (fn
 _ => ([]))
 in ( LrTable.NT 104, ( result, defaultPos, defaultPos), rest671)
end
|  ( 514, ( ( _, ( MlyValue.match_clauses match_clauses1, _, 
match_clauses1right)) :: ( _, ( MlyValue.match_clause match_clause1, 
match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.match_clauses (fn _ => let val  (match_clause as 
match_clause1) = match_clause1 ()
 val  (match_clauses as match_clauses1) = match_clauses1 ()
 in (match_clause::match_clauses)
end)
 in ( LrTable.NT 104, ( result, match_clause1left, match_clauses1right
), rest671)
end
|  ( 515, ( rest671)) => let val  result = MlyValue.dmatch_clauses (fn
 _ => ([]))
 in ( LrTable.NT 113, ( result, defaultPos, defaultPos), rest671)
end
|  ( 516, ( ( _, ( MlyValue.dmatch_clauses dmatch_clauses1, _, 
dmatch_clauses1right)) :: ( _, ( MlyValue.dmatch_clause dmatch_clause1
, dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.dmatch_clauses (fn _ => let val  (dmatch_clause as 
dmatch_clause1) = dmatch_clause1 ()
 val  (dmatch_clauses as dmatch_clauses1) = dmatch_clauses1 ()
 in (dmatch_clause::dmatch_clauses)
end)
 in ( LrTable.NT 113, ( result, dmatch_clause1left, 
dmatch_clauses1right), rest671)
end
|  ( 517, ( ( _, ( MlyValue.sep_infix_match_clause 
sep_infix_match_clause1, sep_infix_match_clause1left, 
sep_infix_match_clause1right)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clauses (fn _ => let val  (
sep_infix_match_clause as sep_infix_match_clause1) = 
sep_infix_match_clause1 ()
 in ([sep_infix_match_clause])
end)
 in ( LrTable.NT 110, ( result, sep_infix_match_clause1left, 
sep_infix_match_clause1right), rest671)
end
|  ( 518, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, _, sep_infix_match_clauses1right)) :: ( _, (
 MlyValue.sep_infix_match_clause sep_infix_match_clause1, 
sep_infix_match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_match_clauses (fn _ => let val  (
sep_infix_match_clause as sep_infix_match_clause1) = 
sep_infix_match_clause1 ()
 val  (sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (sep_infix_match_clause::sep_infix_match_clauses)
end)
 in ( LrTable.NT 110, ( result, sep_infix_match_clause1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 519, ( ( _, ( MlyValue.sep_infix_dmatch_clause 
sep_infix_dmatch_clause1, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clause1right)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clause as sep_infix_dmatch_clause1) = 
sep_infix_dmatch_clause1 ()
 in ([sep_infix_dmatch_clause])
end)
 in ( LrTable.NT 111, ( result, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clause1right), rest671)
end
|  ( 520, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, _, sep_infix_dmatch_clauses1right)) :: ( _,
 ( MlyValue.sep_infix_dmatch_clause sep_infix_dmatch_clause1, 
sep_infix_dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.sep_infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clause as sep_infix_dmatch_clause1) = 
sep_infix_dmatch_clause1 ()
 val  (sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (sep_infix_dmatch_clause::sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 111, ( result, sep_infix_dmatch_clause1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 521, ( ( _, ( MlyValue.infix_match_clause infix_match_clause1, 
infix_match_clause1left, infix_match_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_match_clauses (fn _ => let val  (
infix_match_clause as infix_match_clause1) = infix_match_clause1 ()
 in ([infix_match_clause])
end)
 in ( LrTable.NT 112, ( result, infix_match_clause1left, 
infix_match_clause1right), rest671)
end
|  ( 522, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, sep_infix_match_clauses1left, 
sep_infix_match_clauses1right)) :: rest671)) => let val  result = 
MlyValue.infix_match_clauses (fn _ => let val  (
sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (sep_infix_match_clauses)
end)
 in ( LrTable.NT 112, ( result, sep_infix_match_clauses1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 523, ( ( _, ( MlyValue.sep_infix_match_clauses 
sep_infix_match_clauses1, _, sep_infix_match_clauses1right)) :: ( _, (
 MlyValue.infix_match_clause infix_match_clause1, 
infix_match_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_match_clauses (fn _ => let val  (infix_match_clause as 
infix_match_clause1) = infix_match_clause1 ()
 val  (sep_infix_match_clauses as sep_infix_match_clauses1) = 
sep_infix_match_clauses1 ()
 in (infix_match_clause::sep_infix_match_clauses)
end)
 in ( LrTable.NT 112, ( result, infix_match_clause1left, 
sep_infix_match_clauses1right), rest671)
end
|  ( 524, ( ( _, ( MlyValue.infix_dmatch_clause infix_dmatch_clause1, 
infix_dmatch_clause1left, infix_dmatch_clause1right)) :: rest671)) =>
 let val  result = MlyValue.infix_dmatch_clauses (fn _ => let val  (
infix_dmatch_clause as infix_dmatch_clause1) = infix_dmatch_clause1 ()
 in ([infix_dmatch_clause])
end)
 in ( LrTable.NT 114, ( result, infix_dmatch_clause1left, 
infix_dmatch_clause1right), rest671)
end
|  ( 525, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, sep_infix_dmatch_clauses1left, 
sep_infix_dmatch_clauses1right)) :: rest671)) => let val  result = 
MlyValue.infix_dmatch_clauses (fn _ => let val  (
sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 114, ( result, sep_infix_dmatch_clauses1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 526, ( ( _, ( MlyValue.sep_infix_dmatch_clauses 
sep_infix_dmatch_clauses1, _, sep_infix_dmatch_clauses1right)) :: ( _,
 ( MlyValue.infix_dmatch_clause infix_dmatch_clause1, 
infix_dmatch_clause1left, _)) :: rest671)) => let val  result = 
MlyValue.infix_dmatch_clauses (fn _ => let val  (infix_dmatch_clause
 as infix_dmatch_clause1) = infix_dmatch_clause1 ()
 val  (sep_infix_dmatch_clauses as sep_infix_dmatch_clauses1) = 
sep_infix_dmatch_clauses1 ()
 in (infix_dmatch_clause::sep_infix_dmatch_clauses)
end)
 in ( LrTable.NT 114, ( result, infix_dmatch_clause1left, 
sep_infix_dmatch_clauses1right), rest671)
end
|  ( 527, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.phrase 
phrase1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, (
 _, (LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result =
 MlyValue.binding (fn _ => let val  (pattern as pattern1) = pattern1
 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val _ = A.checkNoDotsPat(pattern)
                                       in
                                          {bpat=pattern,def=phrase,pos=getPos LPARENleft}
                                       end
)
end)
 in ( LrTable.NT 115, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 528, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: ( _, 
( _, ASGNleft, _)) :: ( _, ( MlyValue.pattern pattern1, pattern1left,
 _)) :: rest671)) => let val  result = MlyValue.binding_assignment (fn
 _ => let val  (pattern as pattern1) = pattern1 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
let val _ = A.checkNoDotsPat(pattern)
                                         in
                                            {bpat=pattern,def=phrase,pos=getPos ASGNleft}
                                         end
)
end)
 in ( LrTable.NT 116, ( result, pattern1left, phrase1right), rest671)

end
|  ( 529, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: 
( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671)) => let
 val  result = MlyValue.assignment (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (phrase as phrase1) = phrase1 ()
 in (
{bpat=A.makePosLessIdPat(S.symbol ID),def=phrase,pos=getPos IDleft})

end)
 in ( LrTable.NT 122, ( result, ID1left, phrase1right), rest671)
end
|  ( 530, ( ( _, ( MlyValue.phrase phrase1, _, phrase1right)) :: _ :: 
( _, ( _, (ANY_PATleft as ANY_PAT1left), _)) :: rest671)) => let val  
result = MlyValue.assignment (fn _ => let val  (phrase as phrase1) = 
phrase1 ()
 in (
{bpat=A.anyPat({pos=getPos ANY_PATleft}),def=phrase,pos=getPos ANY_PATleft}
)
end)
 in ( LrTable.NT 122, ( result, ANY_PAT1left, phrase1right), rest671)

end
|  ( 531, ( ( _, ( MlyValue.assignment assignment1, assignment1left, 
assignment1right)) :: rest671)) => let val  result = 
MlyValue.assignments (fn _ => let val  (assignment as assignment1) = 
assignment1 ()
 in ([assignment])
end)
 in ( LrTable.NT 123, ( result, assignment1left, assignment1right), 
rest671)
end
|  ( 532, ( ( _, ( MlyValue.assignments assignments1, _, 
assignments1right)) :: _ :: ( _, ( MlyValue.assignment assignment1, 
assignment1left, _)) :: rest671)) => let val  result = 
MlyValue.assignments (fn _ => let val  (assignment as assignment1) = 
assignment1 ()
 val  (assignments as assignments1) = assignments1 ()
 in (assignment::assignments)
end)
 in ( LrTable.NT 123, ( result, assignment1left, assignments1right), 
rest671)
end
|  ( 533, ( rest671)) => let val  result = MlyValue.bindings (fn _ =>
 ([]))
 in ( LrTable.NT 117, ( result, defaultPos, defaultPos), rest671)
end
|  ( 534, ( ( _, ( MlyValue.bindings bindings1, _, bindings1right)) ::
 ( _, ( MlyValue.binding binding1, binding1left, _)) :: rest671)) =>
 let val  result = MlyValue.bindings (fn _ => let val  (binding as 
binding1) = binding1 ()
 val  (bindings as bindings1) = bindings1 ()
 in (binding::bindings)
end)
 in ( LrTable.NT 117, ( result, binding1left, bindings1right), rest671
)
end
|  ( 535, ( ( _, ( MlyValue.binding_assignment binding_assignment1, 
binding_assignment1left, binding_assignment1right)) :: rest671)) =>
 let val  result = MlyValue.semicolon_separated_bindings (fn _ => let
 val  (binding_assignment as binding_assignment1) = 
binding_assignment1 ()
 in ([binding_assignment])
end)
 in ( LrTable.NT 118, ( result, binding_assignment1left, 
binding_assignment1right), rest671)
end
|  ( 536, ( ( _, ( MlyValue.semicolon_separated_bindings 
semicolon_separated_bindings1, _, semicolon_separated_bindings1right))
 :: _ :: ( _, ( MlyValue.binding_assignment binding_assignment1, 
binding_assignment1left, _)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_bindings (fn _ => let val  (
binding_assignment as binding_assignment1) = binding_assignment1 ()
 val  (semicolon_separated_bindings as semicolon_separated_bindings1)
 = semicolon_separated_bindings1 ()
 in (binding_assignment::semicolon_separated_bindings)
end)
 in ( LrTable.NT 118, ( result, binding_assignment1left, 
semicolon_separated_bindings1right), rest671)
end
|  ( 537, ( ( _, ( MlyValue.phrase phrase1, phrase1left, phrase1right)
) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_phrases (fn _ => let val  (phrase as 
phrase1) = phrase1 ()
 in ([phrase])
end)
 in ( LrTable.NT 119, ( result, phrase1left, phrase1right), rest671)

end
|  ( 538, ( ( _, ( MlyValue.semicolon_separated_phrases 
semicolon_separated_phrases1, _, semicolon_separated_phrases1right))
 :: _ :: ( _, ( MlyValue.phrase phrase1, phrase1left, _)) :: rest671))
 => let val  result = MlyValue.semicolon_separated_phrases (fn _ =>
 let val  (phrase as phrase1) = phrase1 ()
 val  (semicolon_separated_phrases as semicolon_separated_phrases1) = 
semicolon_separated_phrases1 ()
 in (phrase::semicolon_separated_phrases)
end)
 in ( LrTable.NT 119, ( result, phrase1left, 
semicolon_separated_phrases1right), rest671)
end
|  ( 539, ( ( _, ( MlyValue.deduction deduction1, deduction1left, 
deduction1right)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_deductions (fn _ => let val  (deduction
 as deduction1) = deduction1 ()
 in ([deduction])
end)
 in ( LrTable.NT 120, ( result, deduction1left, deduction1right), 
rest671)
end
|  ( 540, ( ( _, ( MlyValue.semicolon_separated_deductions 
semicolon_separated_deductions1, _, 
semicolon_separated_deductions1right)) :: _ :: ( _, ( 
MlyValue.deduction deduction1, deduction1left, _)) :: rest671)) => let
 val  result = MlyValue.semicolon_separated_deductions (fn _ => let
 val  (deduction as deduction1) = deduction1 ()
 val  (semicolon_separated_deductions as 
semicolon_separated_deductions1) = semicolon_separated_deductions1 ()
 in (deduction::semicolon_separated_deductions)
end)
 in ( LrTable.NT 120, ( result, deduction1left, 
semicolon_separated_deductions1right), rest671)
end
|  ( 541, ( ( _, ( MlyValue.expression expression1, expression1left, 
expression1right)) :: rest671)) => let val  result = 
MlyValue.semicolon_separated_expressions (fn _ => let val  (expression
 as expression1) = expression1 ()
 in ([expression])
end)
 in ( LrTable.NT 121, ( result, expression1left, expression1right), 
rest671)
end
|  ( 542, ( ( _, ( MlyValue.semicolon_separated_expressions 
semicolon_separated_expressions1, _, 
semicolon_separated_expressions1right)) :: _ :: ( _, ( 
MlyValue.expression expression1, expression1left, _)) :: rest671)) =>
 let val  result = MlyValue.semicolon_separated_expressions (fn _ =>
 let val  (expression as expression1) = expression1 ()
 val  (semicolon_separated_expressions as 
semicolon_separated_expressions1) = semicolon_separated_expressions1
 ()
 in (expression::semicolon_separated_expressions)
end)
 in ( LrTable.NT 121, ( result, expression1left, 
semicolon_separated_expressions1right), rest671)
end
|  ( 543, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: ( _
, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,condition=A.desugarUB(expression)}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 544, ( ( _, ( MlyValue.expression expression1, _, 
expression1right)) :: ( _, ( MlyValue.ID ID1, IDleft, _)) :: ( _, ( _,
 DEFINE_SYMBOL1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,condition=A.desugarUB(expression)}
)
end)
 in ( LrTable.NT 124, ( result, DEFINE_SYMBOL1left, expression1right),
 rest671)
end
|  ( 545, ( ( _, ( _, _, RPAREN2right)) :: _ :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( MlyValue.athena_var 
athena_var1, _, _)) :: _ :: _ :: ( _, ( MlyValue.ID ID1, IDleft, _))
 :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = ID1 ()
 val  (athena_var as athena_var1) = athena_var1 ()
 val  (expression as expression1) = expression1 ()
 in (
let val id_pos = getPos IDleft
                      in
                      {name=S.symbol(ID),pos=id_pos,abbreviated=false,
                       condition=A.desugarUB(A.makeConstantSymCondition({constant_name=A.makeMS(ID,SOME id_pos),
                                                             the_var=athena_var,
                                                             def_description=expression}))}
                      end
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN2right), rest671)

end
|  ( 546, ( ( _, ( _, _, RPAREN3right)) :: _ :: ( _, ( 
MlyValue.expression expression1, _, _)) :: ( _, ( MlyValue.athena_var 
athena_var1, _, _)) :: _ :: _ :: _ :: ( _, ( 
MlyValue.one_or_more_athena_vars one_or_more_athena_vars1, _, _)) :: (
 _, ( MlyValue.ID ID1, IDleft, _)) :: _ :: _ :: ( _, ( _, LPAREN1left,
 _)) :: rest671)) => let val  result = MlyValue.symbol_definition (fn
 _ => let val  (ID as ID1) = ID1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 val  (athena_var as athena_var1) = athena_var1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=false,
                       condition=A.desugarUB(A.makeFunSymCondition({fun_name=S.symbol(ID),
                                                        arg_vars=one_or_more_athena_vars,
                                                        the_var=athena_var,def_description=expression}))}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN3right), rest671)

end
|  ( 547, ( ( _, ( _, _, RPAREN2right)) :: ( _, ( MlyValue.expression 
expression1, _, _)) :: _ :: ( _, ( MlyValue.one_or_more_athena_vars 
one_or_more_athena_vars1, _, _)) :: ( _, ( MlyValue.ID ID1, IDleft, _)
) :: _ :: _ :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.symbol_definition (fn _ => let val  (ID as ID1) = 
ID1 ()
 val  (one_or_more_athena_vars as one_or_more_athena_vars1) = 
one_or_more_athena_vars1 ()
 val  (expression as expression1) = expression1 ()
 in (
{name=S.symbol(ID),pos=getPos IDleft,abbreviated=true,
                       condition=A.desugarUB(A.makeFunOrRelSymCondition({fun_or_rel_name=S.symbol(ID),
                                                             arg_vars=one_or_more_athena_vars,
                                                             term_or_condition=expression}))}
)
end)
 in ( LrTable.NT 124, ( result, LPAREN1left, RPAREN2right), rest671)

end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.input_stream x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Athena_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_ANY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_WITNESS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.VOID,p1,p2))
fun PICK_WITNESSES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.VOID,p1,p2))
fun CHECK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.VOID,p1,p2))
fun DCHECK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun LOGICAL_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.VOID,p1,p2))
fun LOGICAL_OR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun EXPAND_INPUT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun PRIVATE_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.PRIVATE_ID (fn () => i),p1,p2))
fun PRIVATE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun OPEN_MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun EXTEND_MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun ANY_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.ANY_ID (fn () => i),p1,p2))
fun RE_STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_PLUS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_OPTIONAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_LIT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_REP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun RE_RANGE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun SOME_FUNCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun EXIT_ATHENA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun FROM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun FOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun START_LOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun END_LOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun TRANSFORM_OUTPUT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun CHARACTER (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.CHARACTER (fn () => i),p1,p2))
fun LOAD_FILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun DIF_ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun NAME (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_TERM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun OVERLOAD_INV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun MODULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_STAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_MEMOIZED (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_ATOM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_PROP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun QMARK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun EXCL_MARK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun QUOTE_WORD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun QUOTE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun EXPAND_NEXT_PROOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_CURLY_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_CURLY_BRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun BACK_QUOTE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun LETREC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun DLETREC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun SPLIT_PAT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun BY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun PRINT_STACK_TRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMI_COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun CONCLUDE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun DOUBLE_LEFT_CURLY_BRACE (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 61,(ParserData.MlyValue.VOID,p1,p2))
fun DOUBLE_RIGHT_CURLY_BRACE (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 62,(ParserData.MlyValue.VOID,p1,p2))
fun LPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun CLAIM (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_BRACKET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun SET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun WILDCARD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_CHAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun APPLYING (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun FUNCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun MATCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.VOID,p1,p2))
fun LET_UPPER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 78,(
ParserData.MlyValue.VOID,p1,p2))
fun DLET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 79,(
ParserData.MlyValue.VOID,p1,p2))
fun TRY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 80,(
ParserData.MlyValue.VOID,p1,p2))
fun DTRY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 81,(
ParserData.MlyValue.VOID,p1,p2))
fun APPLY_METHOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 82,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_VAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 83,(
ParserData.MlyValue.VOID,p1,p2))
fun SEQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 84,(
ParserData.MlyValue.VOID,p1,p2))
fun DSEQ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 85,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_VECTOR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 86,(
ParserData.MlyValue.VOID,p1,p2))
fun MAP_BEGIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 87,(
ParserData.MlyValue.VOID,p1,p2))
fun MAP_END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 88,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUAL_SIGN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 89,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSERT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 90,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSERT_CLOSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 91,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSUME (p1,p2) = Token.TOKEN (ParserData.LrTable.T 92,(
ParserData.MlyValue.VOID,p1,p2))
fun ASSUME_LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 93,(
ParserData.MlyValue.VOID,p1,p2))
fun SUPPOSE_ABSURD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 94,(
ParserData.MlyValue.VOID,p1,p2))
fun SUPPOSE_ABSURD_LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 95
,(ParserData.MlyValue.VOID,p1,p2))
fun ON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 96,(
ParserData.MlyValue.VOID,p1,p2))
fun PROVE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 97,(
ParserData.MlyValue.VOID,p1,p2))
fun DMATCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 98,(
ParserData.MlyValue.VOID,p1,p2))
fun EITHER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 99,(
ParserData.MlyValue.VOID,p1,p2))
fun ABSURD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 100,(
ParserData.MlyValue.VOID,p1,p2))
fun MP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 101,(
ParserData.MlyValue.VOID,p1,p2))
fun DN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 102,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUIV (p1,p2) = Token.TOKEN (ParserData.LrTable.T 103,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_IFF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 104,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_IFF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 105,(
ParserData.MlyValue.VOID,p1,p2))
fun BOTH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 106,(
ParserData.MlyValue.VOID,p1,p2))
fun ASGN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 107,(
ParserData.MlyValue.VOID,p1,p2))
fun BY_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 108,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 109,(
ParserData.MlyValue.VOID,p1,p2))
fun META_ID (p1,p2) = Token.TOKEN (ParserData.LrTable.T 110,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 111,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 112,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 113,(
ParserData.MlyValue.VOID,p1,p2))
fun CD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 114,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL_OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 115,(
ParserData.MlyValue.VOID,p1,p2))
fun VAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 116,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN_ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 117,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 118,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 119,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_SORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 120,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_LIST (p1,p2) = Token.TOKEN (ParserData.LrTable.T 121,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 122,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_SUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 123,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_TABLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 124,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_MAP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 125,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 126,(
ParserData.MlyValue.VOID,p1,p2))
fun POUND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 127,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 128,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 129,(
ParserData.MlyValue.VOID,p1,p2))
fun DOMAIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 130,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 131,(
ParserData.MlyValue.VOID,p1,p2))
fun PROVIDED (p1,p2) = Token.TOKEN (ParserData.LrTable.T 132,(
ParserData.MlyValue.VOID,p1,p2))
fun DECLARE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 133,(
ParserData.MlyValue.VOID,p1,p2))
fun DDECLARE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 134,(
ParserData.MlyValue.VOID,p1,p2))
fun DIRECTIVE_PREFIX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 135,(
ParserData.MlyValue.VOID,p1,p2))
fun EGEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 136,(
ParserData.MlyValue.VOID,p1,p2))
fun BEGIN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 137,(
ParserData.MlyValue.VOID,p1,p2))
fun WHILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 138,(
ParserData.MlyValue.VOID,p1,p2))
fun CLEAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 139,(
ParserData.MlyValue.VOID,p1,p2))
fun THE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 140,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_SYMBOL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 141,(
ParserData.MlyValue.VOID,p1,p2))
fun DOMAINS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 142,(
ParserData.MlyValue.VOID,p1,p2))
fun OVER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 143,(
ParserData.MlyValue.VOID,p1,p2))
fun EGEN_UNIQUE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 144,(
ParserData.MlyValue.VOID,p1,p2))
fun LEIBNIZ (p1,p2) = Token.TOKEN (ParserData.LrTable.T 145,(
ParserData.MlyValue.VOID,p1,p2))
fun EQ_REFLEX (p1,p2) = Token.TOKEN (ParserData.LrTable.T 146,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_QUANT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 147,(
ParserData.MlyValue.VOID,p1,p2))
fun USPEC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 148,(
ParserData.MlyValue.VOID,p1,p2))
fun FETCH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 149,(
ParserData.MlyValue.VOID,p1,p2))
fun RETRACT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 150,(
ParserData.MlyValue.VOID,p1,p2))
fun DEFINE_FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 151,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_DEMON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 152,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_DEMONS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 153,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME_PROP_CON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 154,(
ParserData.MlyValue.VOID,p1,p2))
fun UNEQUAL_TERMS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 155,(
ParserData.MlyValue.VOID,p1,p2))
fun INDUCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 156,(
ParserData.MlyValue.VOID,p1,p2))
fun STRUCTURE_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 157,(
ParserData.MlyValue.VOID,p1,p2))
fun LIST (p1,p2) = Token.TOKEN (ParserData.LrTable.T 158,(
ParserData.MlyValue.VOID,p1,p2))
fun CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 159,(
ParserData.MlyValue.VOID,p1,p2))
fun RULE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 160,(
ParserData.MlyValue.VOID,p1,p2))
fun GEN_OVER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 161,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_PREDICATE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 162,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_KEYS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 163,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH_WITNESS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 164,(
ParserData.MlyValue.VOID,p1,p2))
fun MAKE_CELL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 165,(
ParserData.MlyValue.VOID,p1,p2))
fun REF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 166,(
ParserData.MlyValue.VOID,p1,p2))
fun USE_TERM_PARSER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 167,(
ParserData.MlyValue.VOID,p1,p2))
fun USE_PROP_PARSER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 168,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 169,(
ParserData.MlyValue.VOID,p1,p2))
fun SPECIALIZE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 170,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_FLAG (p1,p2) = Token.TOKEN (ParserData.LrTable.T 171,(
ParserData.MlyValue.VOID,p1,p2))
fun TRUE_INTRODUCTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 172
,(ParserData.MlyValue.VOID,p1,p2))
fun EX_GENERALIZE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 173,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE_CASES (p1,p2) = Token.TOKEN (ParserData.LrTable.T 174,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE_CASES_ON_TERM (p1,p2) = Token.TOKEN (
ParserData.LrTable.T 175,(ParserData.MlyValue.VOID,p1,p2))
fun SUBSORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 176,(
ParserData.MlyValue.VOID,p1,p2))
fun SUBSORTS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 177,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_INIT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 178,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_SUB (p1,p2) = Token.TOKEN (ParserData.LrTable.T 179,(
ParserData.MlyValue.VOID,p1,p2))
fun VECTOR_SET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 180,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_CNF_CONVERTER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 181
,(ParserData.MlyValue.VOID,p1,p2))
fun GET_CNF_CONVERTER (p1,p2) = Token.TOKEN (ParserData.LrTable.T 182
,(ParserData.MlyValue.VOID,p1,p2))
fun ANY_PAT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 183,(
ParserData.MlyValue.VOID,p1,p2))
fun SET_PRECEDENCE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 184,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFT_ASSOC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 185,(
ParserData.MlyValue.VOID,p1,p2))
fun RIGHT_ASSOC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 186,(
ParserData.MlyValue.VOID,p1,p2))
fun BIN_OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 187,(
ParserData.MlyValue.VOID,p1,p2))
fun ADD_PATH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 188,(
ParserData.MlyValue.VOID,p1,p2))
end
end
