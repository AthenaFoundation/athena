% ------------------------------------------------------------------------
% file `main-exercise-10-solution-body.tex'
%
%     solution of type `exercise' with id `10'
%
% generated by the `solution' environment of the
%   `xsim' package v0.16a (2020/01/16)
% from source `main' on 2024/06/09 on line 71
% ------------------------------------------------------------------------
\begin{tcAthena}
conclude mult-0-r := (forall n . n * Zero = Zero)
  by-induction mult-0-r {
    Zero     => (!chain [(Zero * Zero) = Zero  [mult-nat-def]])
  | (Succ k) => let {ih := (k * Zero = Zero)}
                  (!chain [((Succ k) * Zero)
                         = (Zero + (k * Zero)) [mult-nat-def]
                         = (k * Zero)          [plus-nat-def]
                         = Zero                [ih]])
  }

conclude plus-n-Sm := (forall n m . Succ (n + m) = n + Succ m)
  by-induction plus-n-Sm {
    (n as Zero) => pick-any m:Nat
                     (!chain [(Succ (Zero + m))
                            = (Succ m)         [plus-nat-def]
                            = (Zero + Succ m)  [plus-nat-def]
                            = (n + Succ m)     [(n = Zero)]])
  | (Succ k) =>
      let {ih := (forall m . Succ (k + m) = k + Succ m)}
        pick-any m:Nat
          (!chain [(Succ ((Succ k) + m))
                 = (Succ (Succ (k + m)))       [plus-nat-def]
                 = (Succ (k + Succ m))         [ih]
                 = ((Succ k) + (Succ m))       [plus-nat-def]])
  }

conclude plus-comm := (forall n m . n + m = m + n)
  by-induction plus-comm {
    Zero => pick-any m:Nat
              (!chain [(Zero + m)
                     = m                       [plus-nat-def]
                     = (m + Zero)              [plus-n-Z]])
  | (Succ k) => let {ih := (forall m . k + m = m + k)}
                  pick-any m:Nat
                    (!chain [((Succ k) + m)
                           = (Succ (k + m))    [plus-nat-def]
                           = (Succ (m + k))    [ih]
                           = (m + Succ k)      [plus-n-Sm]])
  }


conclude plus-assoc := (forall n m k . n + (m + k) = (n + m) + k)
  by-induction plus-assoc {
    Zero => pick-any m:Nat k:Nat
             (!chain [(Zero + (m + k))
                    = (m + k)                  [plus-nat-def]
                    = ((Zero + m) + k)         [plus-nat-def]])
  | (Succ n') =>
      let {ih := (forall m k . n' + (m + k) = (n' + m) + k)}
        pick-any m:Nat k:Nat
          (!chain [((Succ n') + (m + k))
                  = (Succ (n' + (m + k)))      [plus-nat-def]
                  = (Succ ((n' + m) + k))      [ih]
                  = ((Succ (n' + m)) + k)      [plus-nat-def]
                  = (((Succ n') + m) + k)      [plus-nat-def]])
  }
\end{tcAthena}
